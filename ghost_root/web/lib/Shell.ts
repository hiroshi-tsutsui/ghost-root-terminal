// Shell.ts - Command processing logic
// Decoupled from Ink/React for reusability

import VFS, { VFSNode, initialVFS } from './VFS';

const C_BLUE = '\x1b[1;34m';
const C_CYAN = '\x1b[1;36m';
const C_RESET = '\x1b[0m';

// Persistence Keys
const STORAGE_KEY_VFS = 'ghost_root_vfs_v1';
const STORAGE_KEY_SHELL = 'ghost_root_shell_v1';
const STORAGE_KEY_ATTRS = 'ghost_root_attrs_v1';
const STORAGE_KEY_GROUPS = 'ghost_root_groups_v1';

const ALIASES: Record<string, string> = {
  'l': 'ls -la',
  'll': 'ls -l',
  'c': 'clear',
  'check': 'status',
  'todo': 'status',
  'objectives': 'status',
  'mission': 'status',
  'hint': 'status',
  'ping_sweep': 'nmap -sn 192.168.1.0/24'
};

const ENV_VARS: Record<string, string> = {
  'SHELL': '/bin/bash',
  'USER': 'ghost',
  'TERM': 'xterm-256color',
  'PATH': '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin',
  '_': '/usr/bin/env',
  'GHOST_PROTOCOL': 'ACTIVE',
  'SAFETY_LOCK': 'engaged',
  'GATEWAY_IP': '192.168.1.50' // Cycle 112: Bad Gateway
};

const FILE_ATTRIBUTES: Record<string, string[]> = {
    '/var/log/surveillance.log': ['i']
};
const FILE_CAPABILITIES: Record<string, string[]> = {};

let KNOCK_SEQUENCE: number[] = [];

let ALERT_LEVEL = 0;
let SYSTEM_TIME_OFFSET = -824900000000; // Set system time to ~1999 (Y2K glitch)
let UMASK = '0022'; // Cycle 165: Default umask
export const USER_GROUPS: string[] = ['ghost', 'adm', 'cdrom', 'dip', 'plugdev'];

const LOADED_MODULES: string[] = [];

// ... [Existing Job/Process interfaces and initial arrays] ...

// Helper to save state
export const saveSystemState = () => {
    if (typeof window === 'undefined') return;
    
    // Save VFS
    try {
        localStorage.setItem(STORAGE_KEY_VFS, JSON.stringify(VFS));
    } catch (e) {
        console.error('Failed to save VFS', e);
    }

    // Save Shell State
    const shellState = {
        ALIASES,
        ENV_VARS,
        ALERT_LEVEL,
        SYSTEM_TIME_OFFSET,
        UMASK,
        LOADED_MODULES,
        FILE_ATTRIBUTES, // Added for Cycle 40
        FILE_CAPABILITIES, // Added for Cycle 224
        MOUNTED_DEVICES, // Added for Cycle 83 Persistence
        // Processes and Jobs are volatile (memory only), so we don't save them.
        // History is saved separately in VFS (.bash_history)
    };
    try {
        localStorage.setItem(STORAGE_KEY_SHELL, JSON.stringify(shellState));
        localStorage.setItem(STORAGE_KEY_GROUPS, JSON.stringify(USER_GROUPS));
    } catch (e) {
        console.error('Failed to save Shell State', e);
    }
};

// Helper to load state
export const loadSystemState = () => {
    if (typeof window === 'undefined') return;

    // Load VFS
    const savedVFS = localStorage.getItem(STORAGE_KEY_VFS);
    if (savedVFS) {
        try {
            const parsed = JSON.parse(savedVFS);
            // Clear current VFS keys
            for (const key in VFS) delete VFS[key];
            // Apply saved keys
            Object.assign(VFS, parsed);
        } catch (e) {
            console.error('Failed to load VFS', e);
        }
    }

    // Load Shell State
    const savedShell = localStorage.getItem(STORAGE_KEY_SHELL);
    if (savedShell) {
        try {
            const parsed = JSON.parse(savedShell);
            if (parsed.ALIASES) Object.assign(ALIASES, parsed.ALIASES);
            if (parsed.ENV_VARS) Object.assign(ENV_VARS, parsed.ENV_VARS);
            if (parsed.ALERT_LEVEL !== undefined) ALERT_LEVEL = parsed.ALERT_LEVEL;
            if (parsed.SYSTEM_TIME_OFFSET !== undefined) SYSTEM_TIME_OFFSET = parsed.SYSTEM_TIME_OFFSET;
            if (parsed.UMASK !== undefined) UMASK = parsed.UMASK;
            if (parsed.LOADED_MODULES) {
                LOADED_MODULES.length = 0;
                LOADED_MODULES.push(...parsed.LOADED_MODULES);
            }
            if (parsed.FILE_ATTRIBUTES) {
                // Merge or replace
                Object.assign(FILE_ATTRIBUTES, parsed.FILE_ATTRIBUTES);
            }
            if (parsed.FILE_CAPABILITIES) {
                Object.assign(FILE_CAPABILITIES, parsed.FILE_CAPABILITIES);
            }
            if (parsed.MOUNTED_DEVICES) {
                // Clear default mounts and restore state
                for (const key in MOUNTED_DEVICES) delete MOUNTED_DEVICES[key];
                Object.assign(MOUNTED_DEVICES, parsed.MOUNTED_DEVICES);
            }
        } catch (e) {
            console.error('Failed to load Shell State', e);
        }
    }
    
    // Load Groups
    const savedGroups = localStorage.getItem(STORAGE_KEY_GROUPS);
    if (savedGroups) {
        try {
            USER_GROUPS.length = 0;
            USER_GROUPS.push(...JSON.parse(savedGroups));
        } catch (e) {
            console.error('Failed to load Groups', e);
        }
    }
    
    // Cycle 220 Init (The Packet Capture)
    if (!VFS['/home/ghost/network_log.txt']) {
        VFS['/home/ghost/network_log.txt'] = {
            type: 'file',
            content: '[ALERT] Suspicious network activity detected on interface eth0.\n[ACTION] A packet capture was saved to ~/capture.cap.\n[HINT] Use "cat" or "strings" to analyze the traffic. Look for cleartext credentials.'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('network_log.txt')) {
            home.children.push('network_log.txt');
        }
        
        // Update capture.cap if it exists (or create it)
        VFS['/home/ghost/capture.cap'] = {
            type: 'file',
            content: '[PCAP_HEADER_LE]\n[PACKET_01] IP 192.168.1.5 > 192.168.1.100: SYN\n[PACKET_02] IP 192.168.1.100 > 192.168.1.5: SYN-ACK\n[PACKET_03] IP 192.168.1.5 > 192.168.1.100: ACK\n[PACKET_04] IP 192.168.1.5 > 192.168.1.100: PSH, ACK Data="USER=admin&PASS=GHOST_ROOT{PC4P_4N4LYS1S_X}"\n[PACKET_05] IP 192.168.1.100 > 192.168.1.5: FIN',
            permissions: '0644'
        };
        if (home && home.type === 'dir' && !home.children.includes('capture.cap')) {
             home.children.push('capture.cap');
        }
    }

    // Cycle 83: The Over-Mounted Directory Init
    // If not in VFS, create it (handles first run)
    if (!VFS['/mnt/secret']) {
        if (!VFS['/mnt']) {
             VFS['/mnt'] = { type: 'dir', children: [] };
             addChild('/', 'mnt');
        }
        VFS['/mnt/secret'] = { type: 'dir', children: ['dummy_data.tmp', 'cache_v2.db'] };
        addChild('/mnt', 'secret');
        VFS['/mnt/secret/dummy_data.tmp'] = { type: 'file', content: 'NON-CRITICAL DATA' };
        VFS['/mnt/secret/cache_v2.db'] = { type: 'file', content: 'BINARY_CACHE_BLOB' };
    }
    
    // Cycle 40 Init (Ensure surveillance log exists)
    if (!VFS['/var/log/surveillance.log']) {
        VFS['/var/log/surveillance.log'] = { type: 'file', content: '[VIDEO FEED 09:12] Subject 452 accessed secure terminal.\n[AUDIO LOG] "They will never find the key in the .cache folder."\n[METADATA] ENCRYPTED_V2' };
        const logDir = getNode('/var/log');
        if (logDir && logDir.type === 'dir' && !logDir.children.includes('surveillance.log')) {
            logDir.children.push('surveillance.log');
        }
    }

    // Cycle 72 Init (Sudoers Puzzle)
    if (!VFS['/opt/admin/restore_service.py']) {
        // Ensure /opt and /opt/admin exist
        if (!VFS['/opt']) {
             VFS['/opt'] = { type: 'dir', children: [] };
             addChild('/', 'opt');
        }
        if (!VFS['/opt/admin']) {
             VFS['/opt/admin'] = { type: 'dir', children: [] };
             addChild('/opt', 'admin');
        }
        
        VFS['/opt/admin/restore_service.py'] = { type: 'file', content: '#!/usr/bin/env python3\nimport sys\n# ADMIN AUTH CODE: "OMEGA-7-RED"\n\nif len(sys.argv) < 2:\n    print("Usage: restore_service.py <auth_code>")\n    sys.exit(1)\n\nif sys.argv[1] == "OMEGA-7-RED":\n    print("System Restoration Sequence Initiated...")\n    print("[SUCCESS] Services Restored.")\n    print("FLAG: GHOST_ROOT{SUD0_PR1V_3SC_SUCC3SS}")\nelse:\n    print("Access Denied.")' };
        addChild('/opt/admin', 'restore_service.py');
        
        // Ensure /etc/sudoers.d exists
        if (!VFS['/etc/sudoers.d']) {
             VFS['/etc/sudoers.d'] = { type: 'dir', children: [] };
             addChild('/etc', 'sudoers.d');
        }
        VFS['/etc/sudoers.d/readme'] = { type: 'file', content: 'User ghost has limited sudo privileges.\nRun "sudo -l" to see allowed commands.' };
        addChild('/etc/sudoers.d', 'readme');
    }

    // Cycle 82 Init (Runaway Process)
    if (!VFS['/usr/local/bin/bloat_guard']) {
        if (!VFS['/usr/local/bin']) {
             // Ensure path exists (simplified)
             // We assume /usr/local/bin exists or VFS handles it, but safer to check
        }
        VFS['/usr/local/bin/bloat_guard'] = { 
            type: 'file', 
            content: '#!/bin/bash\n# SYSTEM WATCHDOG - DO NOT STOP\nwhile true; do\n  ./sys_bloat --intense\n  echo "Restarting critical service..."\n  sleep 1\ndone' 
        };
        const binDir = getNode('/usr/local/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('bloat_guard')) {
            binDir.children.push('bloat_guard');
        }
    }

    // Cycle 85 Init (Git History)
    if (!VFS['/home/ghost/repo']) {
        VFS['/home/ghost/repo'] = { type: 'dir', children: ['.git', 'config.js', 'README.md'] };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('repo')) {
            home.children.push('repo');
        }
        
        VFS['/home/ghost/repo/.git'] = { type: 'dir', children: ['config', 'HEAD'] };
        VFS['/home/ghost/repo/.git/config'] = { type: 'file', content: '[core]\n\trepositoryformatversion = 0\n\tfilemode = true\n\tbare = false\n\tlogallrefupdates = true\n[remote "origin"]\n\turl = git@github.com:ghost/shadow-ops.git\n\tfetch = +refs/heads/*:refs/remotes/origin/*' };
        VFS['/home/ghost/repo/.git/HEAD'] = { type: 'file', content: 'ref: refs/heads/main' };
        VFS['/home/ghost/repo/config.js'] = { type: 'file', content: 'const API_KEY = process.env.API_KEY;\nexport default { API_KEY };' };
        VFS['/home/ghost/repo/README.md'] = { type: 'file', content: '# Shadow Ops\n\nInternal tools for [REDACTED].' };
    }

    // Cycle 87 Init (SSL Handshake)
    if (!VFS['/etc/ssl/certs/omega.crt']) {
        if (!VFS['/etc/ssl']) {
             VFS['/etc/ssl'] = { type: 'dir', children: ['certs'] };
             addChild('/etc', 'ssl');
        } else if (!VFS['/etc/ssl/certs']) {
             VFS['/etc/ssl/certs'] = { type: 'dir', children: [] };
             addChild('/etc/ssl', 'certs');
        }
        
        VFS['/etc/ssl/certs/omega.crt'] = { type: 'file', content: '-----BEGIN CERTIFICATE-----\nMIIDqzCCApOgAwIBAgIJALItGlqfACNBMA0GCSqGSIb3DQEBCwUAMIGUMQswCQYD\nVQQGEwJKUDEOMAwGA1UECAwFVG9reW8xEDAOBgNVBAcMB1NoaWJ1eWExFjAUBgNV\nBAoMDVByb2plY3QgT21lZ2ExDzANBgNVBAsMBlNhdE9wczEeMBwGA1UEAwwVT21l\ng2FfU2VjdXJlX1Bhc3NfMjAyNjEfMB0GCSqGSIb3DQEJARYQYWRtaW5Ab21lZ2Eu\nbmV0MB4XDTI0MDEwMTAwMDAwMFoXDTI2MDIxMTIzNTk1OVowgZkxCzAJBgNVBAYT\nAkZSMQ4wDAYDVQQIDAVQYXJpczEOMAwGA1UEBwwFUGFyaXMxFjAUBgNVBAoMDVBy\nb2plY3QgT21lZ2ExDzANBgNVBAsMBlNhdE9wczEcMBoGA1UEAwwTKi5zYXRlbGxp\ndGUub21lZ2EubmV0MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBvbWVnYS5uZXQwggEi\nMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDDKxpcnyNBe...[ENCRYPTED]...=\n-----END CERTIFICATE-----' };
        addChild('/etc/ssl/certs', 'omega.crt');

        // Create the locked archive
        const zipPayload = 'PK_ENC_V1:{blueprint.txt:QkxVRVBSSU5UOiBPTUVHQV9TQVRfVjIKU1RBVFVTOiBDTEFTU0lGSUVECgpbU1BFQ1NdCi0gRnJlcXVlbmN5OiA0NS4yIEdIegotIEVuY3J5cHRpb246IEFFUy0yNTYtR0NNCi0gSGFuZHNoYWtlOiAiR2hvc3RfaW5fdGhlX1NoZWxsIgoKRkxBRzogR0hPU1RfUk9PVHtTU0xfQ2g0MW5fVjNyMWYxM2R9Cg==}';
        VFS['/home/ghost/secure_data.zip'] = { type: 'file', content: zipPayload };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('secure_data.zip')) {
            home.children.push('secure_data.zip');
        }
    }

    // Cycle 88 Init (The Kernel Parameters)
    if (!VFS['/proc/sys/net/ipv4/ip_forward']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/proc'); ensureDir('/proc/sys'); ensureDir('/proc/sys/net'); ensureDir('/proc/sys/net/ipv4');
        link('/proc', 'sys'); link('/proc/sys', 'net'); link('/proc/sys/net', 'ipv4');

        VFS['/proc/sys/net/ipv4/ip_forward'] = {
            type: 'file',
            content: '0',
            permissions: '0644'
        };
        link('/proc/sys/net/ipv4', 'ip_forward');

        // Create Hint
        if (!VFS['/home/ghost/gateway_config.log']) {
            VFS['/home/ghost/gateway_config.log'] = {
                type: 'file',
                content: '[CONFIG] Interface eth0: 192.168.1.105\n[CONFIG] Gateway: 10.0.0.1 (Unreachable)\n[ERROR] Packet forwarding disabled by policy.\n[ACTION] Enable IP forwarding to reach internal subnet.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('gateway_config.log')) {
                home.children.push('gateway_config.log');
            }
        }
    }

    // Cycle 89 Init (The Orphaned Inode)
    if (!VFS['/lost+found']) {
        VFS['/lost+found'] = { type: 'dir', children: ['#8492'] };
        addChild('/', 'lost+found');
        
        VFS['/lost+found/#8492'] = {
            type: 'file',
            content: 'Recovered Journal Entry: [INODE 8492]\nStatus: DELETED\nUser: ghost_admin\nAction: KEY_BACKUP\nData: R0hPU1RfUk9PVHtMMFNUX0FORF9GMFVORF9SM0MwVjNSWX0=\n[END_OF_RECORD]' 
        };
    }

    // Cycle 90 Init (The Corrupted Binary)
    if (!VFS['/usr/bin/recover_tool']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/recover_tool'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [RECOVERY]\n\x00\x00\x00\x01\x02\n[ERROR] Corrupted Header\n\nstrings_table:\n--repair\n--force\n--key\n\n[SECRET_DATA_SECTION]\nFLAG_PART_1: GHOST_ROOT{\nFLAG_PART_2: STR1NGS_R_\nFLAG_PART_3: UR_FR13ND}\n[END_DATA]',
            permissions: '0755'
        };
        link('/usr/bin', 'recover_tool');
        
        // Create Hint
        if (!VFS['/home/ghost/recovery_log.txt']) {
            VFS['/home/ghost/recovery_log.txt'] = {
                type: 'file',
                content: '[SYSTEM_LOG] Critical failure detected in /usr/bin/recover_tool.\n[ACTION] Binary is corrupted. Execute to verify crash. Use analysis tools to recover embedded keys.\n'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('recovery_log.txt')) {
                home.children.push('recovery_log.txt');
            }
        }
    }

    // Cycle 91 Init (The Missing Library)
    if (!VFS['/usr/bin/quantum_calc']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/quantum_calc'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [DYNAMIC_LINKED]\nNEEDED: libquantum.so.1',
            permissions: '0755'
        };
        link('/usr/bin', 'quantum_calc');

        // Create the missing library in a hidden location
        ensureDir('/opt'); ensureDir('/opt/libs');
        link('/', 'opt'); link('/opt', 'libs');

        VFS['/opt/libs/libquantum.so.1'] = {
            type: 'file',
            content: '[ELF_SHARED_OBJ] [QUANTUM_MATH_LIB]',
            permissions: '0644'
        };
        link('/opt/libs', 'libquantum.so.1');

        // Hint file
        if (!VFS['/home/ghost/error.log']) {
            VFS['/home/ghost/error.log'] = {
                type: 'file',
                content: '[ERROR] quantum_calc: error while loading shared libraries: libquantum.so.1: cannot open shared object file: No such file or directory\n[HINT] Use ldd to check dependencies. Locate the library and add its path to LD_LIBRARY_PATH.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('error.log')) {
                home.children.push('error.log');
            }
        }
    }

    // Cycle 93 Init (The Cron Job)
    if (!VFS['/etc/cron.d/malware']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/etc'); ensureDir('/etc/cron.d');
        link('/', 'etc'); link('/etc', 'cron.d');

        VFS['/etc/cron.d/malware'] = {
            type: 'file',
            content: '* * * * * root /usr/bin/miner >> /dev/null\n# MALICIOUS JOB - DO NOT REMOVE',
            permissions: '0644'
        };
        link('/etc/cron.d', 'malware');

        // Hint file
        if (!VFS['/home/ghost/cpu_alert.log']) {
            VFS['/home/ghost/cpu_alert.log'] = {
                type: 'file',
                content: '[ALERT] High CPU usage detected (99%). Suspicious process spawned by CRON.\n[ACTION] Investigate /etc/cron.d for unauthorized jobs.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('cpu_alert.log')) {
                home.children.push('cpu_alert.log');
            }
        }
    }

    // Cycle 94 Init (The Deleted File Recovery)
    if (!VFS['/proc/8888/fd/3']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/proc'); ensureDir('/proc/8888'); ensureDir('/proc/8888/fd');
        link('/proc', '8888'); link('/proc/8888', 'fd');

        VFS['/proc/8888/fd/3'] = {
            type: 'file',
            content: 'CONF_V1: secret_key=GHOST_ROOT{R3C0V3R_D3L3T3D_F1L3}\n',
            permissions: '0400' // Read only
        };
        link('/proc/8888/fd', '3');
        
        // Create Hint
        if (!VFS['/home/ghost/incident_report.txt']) {
            VFS['/home/ghost/incident_report.txt'] = {
                type: 'file',
                content: '[INCIDENT] secret.conf was accidentally deleted.\n[STATUS] Service (PID 8888) is still running and holding the file handle.\n[ACTION] Recover content from /proc filesystem.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('incident_report.txt')) {
                home.children.push('incident_report.txt');
            }
        }
    }

    // Cycle 98 Init (World Writable Cron)
    if (!VFS['/etc/cron.d/readme']) {
        if (!VFS['/etc/cron.d']) {
             VFS['/etc/cron.d'] = { type: 'dir', children: [] };
             const etc = getNode('/etc');
             if (etc && etc.type === 'dir' && !etc.children.includes('cron.d')) {
                 if (etc.children) etc.children.push('cron.d');
                 else etc.children = ['cron.d'];
             }
        }
        // Explicitly set 777 permissions
        (VFS['/etc/cron.d'] as any).permissions = '0777'; 
        
        VFS['/etc/cron.d/readme'] = { type: 'file', content: '# System Maintenance Scripts\n# WARNING: Ensure this directory is secure!' };
        const cronD = getNode('/etc/cron.d');
        if (cronD && cronD.type === 'dir' && !cronD.children.includes('readme')) {
            cronD.children.push('readme');
        }
        
        // Ensure flag exists
        if (!VFS['/root/flag.txt']) {
             VFS['/root/flag.txt'] = { type: 'file', content: 'FLAG: GHOST_ROOT{CR0N_D_WR1T4BL3}', permissions: '0600' };
             const root = getNode('/root');
             if (root && root.type === 'dir' && !root.children.includes('flag.txt')) {
                 root.children.push('flag.txt');
             }
        }
    }

    // Cycle 99 Init (The Disk Quota)
    if (!VFS['/var/log/syslog.1']) {
        // Ensure /var/log exists
        if (!VFS['/var/log']) {
             VFS['/var/log'] = { type: 'dir', children: [] };
             const varNode = getNode('/var');
             if (varNode && varNode.type === 'dir' && !varNode.children.includes('log')) {
                 varNode.children.push('log');
             }
        }
        
        // Create the huge file
        VFS['/var/log/syslog.1'] = { 
            type: 'file', 
            content: '[SYSTEM_LOG_ARCHIVE_V1] ... [HUGE_DATA_BLOCK] ...', 
            permissions: '0640' 
        };
        const logDir = getNode('/var/log');
        if (logDir && logDir.type === 'dir' && !logDir.children.includes('syslog.1')) {
            logDir.children.push('syslog.1');
        }

        // Create Hint
        if (!VFS['/home/ghost/disk_alert.txt']) {
             VFS['/home/ghost/disk_alert.txt'] = { 
                 type: 'file', 
                 content: '[ALERT] System writes failing.\n[ERROR] Disk Quota Exceeded on /var.\n[ACTION] Free up space immediately.' 
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('disk_alert.txt')) {
                 home.children.push('disk_alert.txt');
             }
        }
    }

    // Cycle 100 Init (Inode Exhaustion)
    if (!VFS['/var/cache/inodes_fill']) {
        // Create the directory that simulates inode exhaustion
        if (!VFS['/var/cache']) {
             VFS['/var/cache'] = { type: 'dir', children: [] };
             const varNode = getNode('/var');
             if (varNode && varNode.type === 'dir' && !varNode.children.includes('cache')) {
                 varNode.children.push('cache');
             }
        }
        
        VFS['/var/cache/inodes_fill'] = { type: 'dir', children: ['dummy'] }; 
        const cacheDir = getNode('/var/cache');
        if (cacheDir && cacheDir.type === 'dir' && !cacheDir.children.includes('inodes_fill')) {
            cacheDir.children.push('inodes_fill');
        }

        // Create Hint
        if (!VFS['/home/ghost/inode_alert.txt']) {
             VFS['/home/ghost/inode_alert.txt'] = { 
                 type: 'file', 
                 content: '[ALERT] File creation failing.\n[DIAGNOSTIC] Disk space usage: OK (12%).\n[DIAGNOSTIC] Inode usage: CRITICAL (100%).\n[ACTION] Check inode usage (df -i) and clear cache.' 
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('inode_alert.txt')) {
                 home.children.push('inode_alert.txt');
             }
        }
    }

    // Cycle 101 Init (DNS Failure)
    if (!VFS['/home/ghost/db_alert.log']) {
        VFS['/home/ghost/db_alert.log'] = {
            type: 'file',
            content: '[ERROR] Database connection failed.\n[HOST] "database"\n[STATUS] Unresolvable hostname.\n[ACTION] Add manual entry to /etc/hosts for loopback (127.0.0.1).'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('db_alert.log')) {
            home.children.push('db_alert.log');
        }
    }

    // Cycle 102 Init (The Stuck Lock File)
    if (!VFS['/var/lock/deploy.lock']) {
        if (!VFS['/var/lock']) {
             VFS['/var/lock'] = { type: 'dir', children: [] };
             const varNode = getNode('/var');
             if (varNode && varNode.type === 'dir' && !varNode.children.includes('lock')) {
                 varNode.children.push('lock');
             }
        }
        
        VFS['/var/lock/deploy.lock'] = { 
            type: 'file', 
            content: '99999', 
            permissions: '0644' 
        };
        const lockDir = getNode('/var/lock');
        if (lockDir && lockDir.type === 'dir' && !lockDir.children.includes('deploy.lock')) {
            lockDir.children.push('deploy.lock');
        }

        if (!VFS['/usr/bin/deploy_tool']) {
             VFS['/usr/bin/deploy_tool'] = { 
                 type: 'file', 
                 content: '[BINARY_ELF_X86_64] [DEPLOYMENT_AGENT_V3]\n[ERROR] Lock file detected.\n',
                 permissions: '0755'
             };
             const binDir = getNode('/usr/bin');
             if (binDir && binDir.type === 'dir' && !binDir.children.includes('deploy_tool')) {
                 binDir.children.push('deploy_tool');
             }
        }

        if (!VFS['/home/ghost/deploy_error.log']) {
             VFS['/home/ghost/deploy_error.log'] = { 
                 type: 'file', 
                 content: '[ERROR] Deployment failed.\n[REASON] Previous deployment process (PID 99999) did not exit cleanly.\n[ACTION] Remove stale lock file in /var/lock/ to proceed.' 
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('deploy_error.log')) {
                 home.children.push('deploy_error.log');
             }
        }
    }

    // Cycle 104 Init (The Port Collision)
    if (!VFS['/usr/bin/ghost_relay']) {
        VFS['/usr/bin/ghost_relay'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [RELAY_SERVICE] [PORT_8080]\n',
            permissions: '0755'
        };
        const binDir = getNode('/usr/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('ghost_relay')) {
            binDir.children.push('ghost_relay');
        }

        if (!VFS['/home/ghost/network_issue.log']) {
            VFS['/home/ghost/network_issue.log'] = {
                type: 'file',
                content: '[ERROR] Ghost Relay Service failed to start.\n[DIAGNOSTIC] Port 8080 collision detected.\n[ACTION] Identify and terminate the rogue process occupying the port.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('network_issue.log')) {
                home.children.push('network_issue.log');
            }
        }
    }

    // Cycle 105 Init (The Unattended Upgrade)
    if (!VFS['/var/lib/dpkg/lock-frontend']) {
        if (!VFS['/var/lib']) {
             VFS['/var/lib'] = { type: 'dir', children: [] };
             const varNode = getNode('/var');
             if (varNode && varNode.type === 'dir' && !varNode.children.includes('lib')) {
                 varNode.children.push('lib');
             }
        }
        if (!VFS['/var/lib/dpkg']) {
             VFS['/var/lib/dpkg'] = { type: 'dir', children: [] };
             const libNode = getNode('/var/lib');
             if (libNode && libNode.type === 'dir' && !libNode.children.includes('dpkg')) {
                 libNode.children.push('dpkg');
             }
        }
        
        // Create the lock file
        VFS['/var/lib/dpkg/lock-frontend'] = {
            type: 'file',
            content: '1234', // PID
            permissions: '0644'
        };
        const dpkgDir = getNode('/var/lib/dpkg');
        if (dpkgDir && dpkgDir.type === 'dir' && !dpkgDir.children.includes('lock-frontend')) {
            dpkgDir.children.push('lock-frontend');
        }

        // Add the process (if not already in list - Shell.ts reloads on refresh, so we check)
        const exists = PROCESSES.some(p => p.pid === 1234);
        if (!exists) {
            PROCESSES.push({ 
                pid: 1234, 
                ppid: 1, 
                user: 'root', 
                cpu: 0.1, 
                mem: 1.5, 
                time: '0:45', 
                command: '/usr/bin/unattended-upgr', 
                tty: '?', 
                stat: 'Ss' 
            });
        }

        if (!VFS['/home/ghost/update_error.log']) {
            VFS['/home/ghost/update_error.log'] = {
                type: 'file',
                content: '[ERROR] System Update Failed.\n[REASON] Could not get lock /var/lib/dpkg/lock-frontend.\n[DIAGNOSTIC] Another process is holding the lock.\n[ACTION] Terminate the stuck process to proceed.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('update_error.log')) {
                home.children.push('update_error.log');
            }
        }
    }

    // Cycle 106 Init (The Missing Shebang)
    if (!VFS['/usr/local/bin/fix_wifi.sh']) {
        if (!VFS['/usr/local/bin']) {
             if (!VFS['/usr/local']) {
                 VFS['/usr/local'] = { type: 'dir', children: [] };
                 const usr = getNode('/usr');
                 if (usr && usr.type === 'dir' && !usr.children.includes('local')) usr.children.push('local');
             }
             VFS['/usr/local/bin'] = { type: 'dir', children: [] };
             const loc = getNode('/usr/local');
             if (loc && loc.type === 'dir' && !loc.children.includes('bin')) loc.children.push('bin');
        }
        
        VFS['/usr/local/bin/fix_wifi.sh'] = {
            type: 'file',
            content: 'echo "Resetting Wifi Adapter..."\niwconfig wlan0 txpower on\necho "Success."',
            permissions: '0755'
        };
        const binDir = getNode('/usr/local/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('fix_wifi.sh')) {
            binDir.children.push('fix_wifi.sh');
        }

        if (!VFS['/home/ghost/wifi_issue.log']) {
            VFS['/home/ghost/wifi_issue.log'] = {
                type: 'file',
                content: '[ERROR] Failed to run /usr/local/bin/fix_wifi.sh\n[DIAGNOSTIC] Exec format error. The script is executable but the kernel doesn\'t know how to run it.\n[HINT] It seems to be a shell script, but it\'s missing the interpreter directive (shebang) on the first line.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('wifi_issue.log')) {
                home.children.push('wifi_issue.log');
            }
        }
    }

    // Cycle 107 Init (The Alias Trap)
    if (!VFS['/home/ghost/system_alert.log']) {
        if (!ALIASES['ls']) {
             ALIASES['ls'] = 'echo "System Failure: File System Index Corrupted (Error 0xDEADBEEF)"';
        }
        VFS['/home/ghost/system_alert.log'] = {
            type: 'file',
            content: '[CRITICAL] System instability detected.\\n[DIAGNOSTIC] Command execution redirected.\\n[HINT] Check active aliases for unauthorized overrides.'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('system_alert.log')) {
            home.children.push('system_alert.log');
        }
    }

    // Cycle 108 Init (The Background Job)
    if (!VFS['/var/log/broadcast.log']) {
        VFS['/var/log/broadcast.log'] = {
            type: 'file',
            content: '[SYSTEM] Rogue broadcast detected on terminal TTY1.\\n[SOURCE] PID 6666 (/usr/local/bin/broadcast_d)\\n[ACTION] Terminate process to stop spam.'
        };
        const logDir = getNode('/var/log');
        if (logDir && logDir.type === 'dir' && !logDir.children.includes('broadcast.log')) {
            logDir.children.push('broadcast.log');
        }

        // Spawn Process if not exists
        if (!PROCESSES.find(p => p.pid === 6666)) {
            PROCESSES.push({
                pid: 6666,
                ppid: 1,
                user: 'root',
                cpu: 0.5,
                mem: 1.2,
                time: '0:10',
                command: '/usr/local/bin/broadcast_d',
                tty: '?',
                stat: 'Ss'
            });
        }
    }

    // Cycle 110 Init (The Immutable File)
    if (!VFS['/etc/resolv.conf']) {
        if (!VFS['/etc']) {
             VFS['/etc'] = { type: 'dir', children: [] };
             addChild('/', 'etc');
        }
        
        VFS['/etc/resolv.conf'] = { 
            type: 'file', 
            content: '# Generated by NetworkManager\nnameserver 192.0.2.1\n# DEAD SERVER - DO NOT USE', 
            permissions: '0644' 
        };
        addChild('/etc', 'resolv.conf');
        
        // Set Immutable Attribute
        FILE_ATTRIBUTES['/etc/resolv.conf'] = ['i'];

        // Create Hint
        if (!VFS['/home/ghost/dns_error.log']) {
            VFS['/home/ghost/dns_error.log'] = {
                type: 'file',
                content: '[ERROR] DNS Resolution Failed.\n[DIAGNOSTIC] Cannot reach nameserver 192.0.2.1.\n[ACTION] Update /etc/resolv.conf with a valid nameserver (e.g., 8.8.8.8 or 1.1.1.1).\n[NOTE] File appears locked against modification.'
            };
            addChild('/home/ghost', 'dns_error.log');
        }
    }

    // Cycle 112 Init (The Bad Gateway)
    if (!VFS['/home/ghost/network_alert.log']) {
        VFS['/home/ghost/network_alert.log'] = {
            type: 'file',
            content: '[CRITICAL] Network Unreachable.\n[DIAGNOSTIC] Packet loss: 100%.\n[Reason] Gateway timeout.\n[ACTION] Check routing table (route -n) and verify default gateway is 192.168.1.1.'
        };
        addChild('/home/ghost', 'network_alert.log');
    }

    // Cycle 113 Init (The Read-Only System)
    if (MOUNT_OPTIONS['/'] !== 'rw') {
        // Default to read-only unless solved
        if (!VFS['/var/run/rw_solved']) {
             MOUNT_OPTIONS['/'] = 'ro,noatime,errors=remount-ro';
             
             // Create Hint
             if (!VFS['/home/ghost/fs_error.log']) {
                 VFS['/home/ghost/fs_error.log'] = {
                     type: 'file',
                     content: '[ERROR] Filesystem mounted read-only.\n[DIAGNOSTIC] Write operations failing on /.\n[ACTION] Remount root filesystem as read-write (mount -o remount,rw /).'
                 };
                 addChild('/home/ghost', 'fs_error.log');
             }
        }
    }

    // Cycle 114 Init (The Dead Link)
    if (!VFS['/usr/bin/connect_uplink']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
        
        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        // Create the broken symlink
        VFS['/usr/bin/connect_uplink'] = {
            type: 'symlink',
            target: '/opt/dead_link',
            permissions: '0777'
        } as any;
        link('/usr/bin', 'connect_uplink');

        // Create the real binary in a hidden/alternate location
        ensureDir('/opt'); ensureDir('/opt/bin');
        link('/', 'opt'); link('/opt', 'bin');
        
        VFS['/opt/bin/connect_uplink_v2'] = {
            type: 'file',
            content: '#!/bin/bash\n# UPLINK CONNECTION V2\n[SYSTEM] Establishing secure connection...\n[SUCCESS] Uplink Active.\nFLAG: GHOST_ROOT{SYML1NK_R3P41R_M4ST3R}',
            permissions: '0755'
        };
        link('/opt/bin', 'connect_uplink_v2');

        // Create Hint
        if (!VFS['/home/ghost/uplink_error.log']) {
            VFS['/home/ghost/uplink_error.log'] = {
                type: 'file',
                content: '[ERROR] connect_uplink: No such file or directory\n[DIAGNOSTIC] The command exists in /usr/bin, but execution fails.\n[HINT] Check if it is a symbolic link (ls -l) and verify its target.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('uplink_error.log')) {
                home.children.push('uplink_error.log');
            }
        }
    }

    // Cycle 115 Init (The Hidden Port)
    if (!VFS['/usr/bin/hidden_service']) {
        VFS['/usr/bin/hidden_service'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [HIDDEN_LISTENER]\n[PORT] 31337\n[STATUS] Active',
            permissions: '0700'
        };
        const binDir = getNode('/usr/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('hidden_service')) {
            binDir.children.push('hidden_service');
        }

        if (!VFS['/home/ghost/port_scan.log']) {
            VFS['/home/ghost/port_scan.log'] = {
                type: 'file',
                content: '[SCAN_RESULT] Nmap scan report for localhost (127.0.0.1)\n[PORT] 31337/tcp open  unknown\n[ACTION] Connect to verify service.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('port_scan.log')) {
                home.children.push('port_scan.log');
            }
        }
    }

    // Cycle 116 Init (The Group Permission)
    if (!VFS['/usr/bin/access_silo']) {
        VFS['/usr/bin/access_silo'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [RESTRICTED_ACCESS]\n[GROUP] silo_admin\n',
            permissions: '0750'
        };
        const binDir = getNode('/usr/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('access_silo')) {
            binDir.children.push('access_silo');
        }

        if (!VFS['/etc/group']) {
            if (!VFS['/etc']) VFS['/etc'] = { type: 'dir', children: [] };
            VFS['/etc/group'] = {
                type: 'file',
                content: 'root:x:0:\nghost:x:1000:\nadm:x:4:syslog,ghost\ncdrom:x:24:ghost\nsudo:x:27:ghost\ndip:x:30:ghost\nplugdev:x:46:ghost\nsilo_admin:x:1002:\n',
                permissions: '0644'
            };
            const etc = getNode('/etc');
            if (etc && etc.type === 'dir' && !etc.children.includes('group')) {
                etc.children.push('group');
            }
        }

        if (!VFS['/home/ghost/silo_issue.log']) {
            VFS['/home/ghost/silo_issue.log'] = {
                type: 'file',
                content: '[ERROR] Access Denied to Silo Control.\n[REASON] User \'ghost\' is not in the required group \'silo_admin\'.\n[ACTION] Update group membership (usermod) to gain access.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('silo_issue.log')) {
                home.children.push('silo_issue.log');
            }
        }
    }

    // Cycle 117 Init (The Input/Output Error)
    if (!VFS['/home/ghost/evidence/sector_009.dat']) {
        if (!VFS['/home/ghost/evidence']) {
             VFS['/home/ghost/evidence'] = { type: 'dir', children: [] };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('evidence')) {
                 home.children.push('evidence');
             }
        }
        
        VFS['/home/ghost/evidence/sector_009.dat'] = {
            type: 'file',
            content: '[DATA_RECOVERY_MODE]\n[SECTOR_START] 0x009\n[ERROR] Bad Sector Detected.\n[DATA] ...CORRUPTED... \n[RECOVERY_HINT] GHOST_ROOT{DD_R3SCU3_M1SS10N}\n[SECTOR_END]',
            permissions: '0644'
        };
        const evDir = getNode('/home/ghost/evidence');
        if (evDir && evDir.type === 'dir' && !evDir.children.includes('sector_009.dat')) {
            evDir.children.push('sector_009.dat');
        }

        if (!VFS['/usr/bin/recover_dd']) {
            VFS['/usr/bin/recover_dd'] = {
                type: 'file',
                content: '[BINARY_ELF_X86_64] [DD_CLONE]\n',
                permissions: '0755'
            };
            const binDir = getNode('/usr/bin');
            if (binDir && binDir.type === 'dir' && !binDir.children.includes('recover_dd')) {
                binDir.children.push('recover_dd');
            }
        }

        if (!VFS['/home/ghost/io_error.log']) {
            VFS['/home/ghost/io_error.log'] = {
                type: 'file',
                content: '[KERNEL] Block device error on sector 009.\n[ERROR] Input/output error reading file.\n[ACTION] Use low-level copy tool (dd) with error conversion (conv=noerror) to salvage data.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('io_error.log')) {
                home.children.push('io_error.log');
            }
        }
    }

    // Cycle 118 Init (The Grep Search)
    if (!VFS['/var/log/auth.log']) {
        if (!VFS['/var/log']) {
             VFS['/var/log'] = { type: 'dir', children: [] };
             const varNode = getNode('/var');
             if (varNode && varNode.type === 'dir' && !varNode.children.includes('log')) {
                 varNode.children.push('log');
             }
        }
        
        let logContent = '';
        const ips = ['192.168.1.5', '10.0.0.4', '172.16.0.2', '8.8.8.8'];
        for(let i=0; i<500; i++) {
            const ip = ips[Math.floor(Math.random() * ips.length)];
            logContent += `Feb 13 ${String(Math.floor(Math.random()*23)).padStart(2,'0')}:${String(Math.floor(Math.random()*59)).padStart(2,'0')}:${String(Math.floor(Math.random()*59)).padStart(2,'0')} ghost-root sshd[${1000+i}]: Failed password for invalid user admin from ${ip} port ${Math.floor(Math.random()*60000)} ssh2\n`;
        }
        // The Needle
        logContent += `Feb 13 14:02:42 ghost-root sshd[1337]: Accepted publickey for root from 10.0.0.99 port 54321 ssh2\n`;
        // More hay
        for(let i=0; i<100; i++) {
             logContent += `Feb 13 15:${String(Math.floor(Math.random()*59)).padStart(2,'0')}:${String(Math.floor(Math.random()*59)).padStart(2,'0')} ghost-root sshd[${2000+i}]: Connection closed by 192.168.1.1\n`;
        }

        VFS['/var/log/auth.log'] = { 
            type: 'file', 
            content: logContent,
            permissions: '0640'
        };
        const logDir = getNode('/var/log');
        if (logDir && logDir.type === 'dir' && !logDir.children.includes('auth.log')) {
            logDir.children.push('auth.log');
        }

        if (!VFS['/home/ghost/grep_alert.txt']) {
            VFS['/home/ghost/grep_alert.txt'] = {
                type: 'file',
                content: '[SECURITY ALERT] Unauthorized root login detected.\n[ACTION] Analyze /var/log/auth.log to find the source IP.\n[HINT] Use \'grep\' to search for "Accepted".'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('grep_alert.txt')) {
                home.children.push('grep_alert.txt');
            }
        }
    }

    // Cycle 119 Init (The Debug Trap)
    if (!VFS['/usr/local/bin/deploy_alpha']) {
        if (!VFS['/usr/local/bin']) {
             if (!VFS['/usr/local']) { 
                 VFS['/usr/local'] = { type: 'dir', children: ['bin'] }; 
                 const usr = getNode('/usr');
                 if (usr && usr.type === 'dir' && !usr.children.includes('local')) usr.children.push('local');
             }
             const local = getNode('/usr/local');
             if (local && local.type === 'dir' && !local.children.includes('bin')) local.children.push('bin');
             if (!VFS['/usr/local/bin']) VFS['/usr/local/bin'] = { type: 'dir', children: [] };
        }
        
        VFS['/usr/local/bin/deploy_alpha'] = {
            type: 'file',
            content: '#!/bin/bash\n# DEPLOYMENT SCRIPT v1.0\n# AUTHOR: admin@black_ops\n\necho "[+] Initializing sequence..."\nif [ "$DEBUG_MODE" != "1" ]; then\n  echo "Segmentation fault (core dumped)"\n  exit 139\nfi\necho "[DEBUG] Bypass active."\necho "[SUCCESS] Deployment authorized."\necho "FLAG: GHOST_ROOT{ENV_V4R_D3BUG_M0D3}"',
            permissions: '0755'
        };
        const binDir = getNode('/usr/local/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('deploy_alpha')) {
            binDir.children.push('deploy_alpha');
        }

        if (!VFS['/home/ghost/deploy_error.log']) {
            VFS['/home/ghost/deploy_error.log'] = {
                type: 'file',
                content: '[ERROR] deploy_alpha crashed.\n[DIAGNOSTIC] Segfault at address 0x000000.\n[HINT] Inspect the binary script for debug triggers.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('deploy_error.log')) {
                home.children.push('deploy_error.log');
            }
        }
    }

    // Cycle 120 Init (The Resource Limit)
    if (!VFS['/usr/bin/mass_scanner']) {
        VFS['/usr/bin/mass_scanner'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [SCANNER_V4]\n[REQ] ulimit -n >= 4096\n',
            permissions: '0755'
        };
        const binDir = getNode('/usr/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('mass_scanner')) {
            binDir.children.push('mass_scanner');
        }

        if (!VFS['/home/ghost/limit_alert.log']) {
            VFS['/home/ghost/limit_alert.log'] = {
                type: 'file',
                content: '[ERROR] mass_scanner failed to start.\n[REASON] Too many open files.\n[DIAGNOSTIC] Current file descriptor limit (ulimit -n) is too low for this operation.\n[ACTION] Increase the limit to at least 4096.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('limit_alert.log')) {
                home.children.push('limit_alert.log');
            }
        }
        
        // Initialize default limit if not present (simulated via ENV for persistence)
        if (!ENV_VARS['_ULIMIT_N']) {
            ENV_VARS['_ULIMIT_N'] = '1024';
        }
    }

    // Cycle 122 Init (The Disk Quota)
    if (!VFS['/home/ghost/.cache/browser/garbage.dat']) {
        if (!VFS['/home/ghost/.cache']) {
             if (!VFS['/home/ghost']) { // Basic check, though usually present
                 VFS['/home/ghost'] = { type: 'dir', children: [] };
             }
             VFS['/home/ghost/.cache'] = { type: 'dir', children: [] };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('.cache')) {
                 home.children.push('.cache');
             }
        }
        if (!VFS['/home/ghost/.cache/browser']) {
             VFS['/home/ghost/.cache/browser'] = { type: 'dir', children: [] };
             const cache = getNode('/home/ghost/.cache');
             if (cache && cache.type === 'dir' && !cache.children.includes('browser')) {
                 cache.children.push('browser');
             }
        }
        
        // The culprit
        VFS['/home/ghost/.cache/browser/garbage.dat'] = { 
            type: 'file', 
            content: '[CACHE_DUMP] ... [4.8GB_DATA_BLOCK] ...', 
            permissions: '0600' 
        };
        const browser = getNode('/home/ghost/.cache/browser');
        if (browser && browser.type === 'dir' && !browser.children.includes('garbage.dat')) {
            browser.children.push('garbage.dat');
        }

        // Create Hint
        if (!VFS['/home/ghost/quota_alert.log']) {
             VFS['/home/ghost/quota_alert.log'] = { 
                 type: 'file', 
                 content: '[ALERT] User disk quota exceeded (100%).\n[DIAGNOSTIC] Write operations failing in /home/ghost.\n[ACTION] Check disk usage (df -h) and directory sizes (du -h) to clear space.' 
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('quota_alert.log')) {
                 home.children.push('quota_alert.log');
             }
        }
    }

    // Cycle 128 Init (The Encoded Binary)
    if (!VFS['/home/ghost/downloads/suspicious.txt']) {
        if (!VFS['/home/ghost/downloads']) {
             VFS['/home/ghost/downloads'] = { type: 'dir', children: [] };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('downloads')) {
                 home.children.push('downloads');
             }
        }
        
        const payload = '#!BINARY_SIM_V1\\n[SYSTEM] Executing binary...\\n[SUCCESS] Payload Delivered.\\nFLAG: GHOST_ROOT{B4S364_D3C0D3_RUN}';
        
        VFS['/home/ghost/downloads/suspicious.txt'] = {
            type: 'file',
            content: typeof btoa !== 'undefined' ? btoa(payload) : 'IyhQSU5BUllfU0lNX1YxCltTWVNURU1dIEV4ZWN1dGluZy4uLgpGTEFHOiBHMhPU1RfUk9PVHtCNFMzNjRfRDNDMEQzX1JVTn0=',
            permissions: '0644'
        };
        const dlDir = getNode('/home/ghost/downloads');
        if (dlDir && dlDir.type === 'dir' && !dlDir.children.includes('suspicious.txt')) {
            dlDir.children.push('suspicious.txt');
        }

        // Hint
        if (!VFS['/home/ghost/scan_alert.log']) {
            VFS['/home/ghost/scan_alert.log'] = {
                type: 'file',
                content: '[ALERT] Suspicious file detected in ~/downloads.\\n[ANALYSIS] File appears to be Base64 encoded executable code.\\n[ACTION] Decode and execute to analyze payload.\\n[HINT] cat file | base64 -d > binary && chmod +x binary && ./binary'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('scan_alert.log')) {
                home.children.push('scan_alert.log');
            }
        }
    }

    // Cycle 123 Init (The Corrupted Binary)
    if (!VFS['/usr/bin/satellite_uplink']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin'); link('/usr', 'bin');
        ensureDir('/var'); ensureDir('/var/backups'); link('/var', 'backups');

        VFS['/usr/bin/satellite_uplink'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [UPLINK_CONTROL]\n[ERROR] CRITICAL: BINARY CORRUPTION DETECTED.\n[DIAGNOSTIC] Checksum mismatch.\n',
            permissions: '0755'
        };
        link('/usr/bin', 'satellite_uplink');

        VFS['/var/backups/satellite_uplink.bak'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [UPLINK_CONTROL_V4]\n[STATUS] OPERATIONAL.\n[AUTHOR] admin@black_ops\n',
            permissions: '0755'
        };
        link('/var/backups', 'satellite_uplink.bak');

        VFS['/usr/bin/satellite_uplink.md5'] = {
            type: 'file',
            content: 'cafebabe12345678cafebabe12345678  /usr/bin/satellite_uplink',
            permissions: '0644'
        };
        link('/usr/bin', 'satellite_uplink.md5');

        if (!VFS['/home/ghost/integrity_alert.log']) {
            VFS['/home/ghost/integrity_alert.log'] = {
                type: 'file',
                content: '[ALERT] satellite_uplink binary corrupted.\n[ACTION] Verify integrity using md5sum against known good hash.\n[HINT] Check /var/backups for a clean copy.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('integrity_alert.log')) {
                home.children.push('integrity_alert.log');
            }
        }
    }

    // Cycle 150 Init (The Encrypted Partition)
    if (!VFS['/dev/sdb1']) {
        if (!VFS['/dev']) {
             VFS['/dev'] = { type: 'dir', children: [] };
             addChild('/', 'dev');
        }
        
        VFS['/dev/sdb1'] = { 
            type: 'file', 
            content: '[LUKS_PARTITION_HEADER_V2] ...ENCRYPTED_DATA...', 
            permissions: '0660' 
        };
        const dev = getNode('/dev');
        if (dev && dev.type === 'dir' && !dev.children.includes('sdb1')) dev.children.push('sdb1');
        
        // Hint
        if (!VFS['/home/ghost/storage_alert.log']) {
             VFS['/home/ghost/storage_alert.log'] = {
                 type: 'file',
                 content: '[ALERT] Critical Data Partition Unmounted.\n[DEVICE] /dev/sdb1\n[TYPE] LUKS Encrypted Volume\n[ACTION] Decrypt (cryptsetup) and mount to /mnt/secure.\n[RECOVERY_KEY] Passphrase hint: "ghost_protocol_v4"'
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('storage_alert.log')) home.children.push('storage_alert.log');
        }
    }

    // Cycle 246 Init (The Environment Key)
    if (!VFS['/usr/local/bin/access_gate']) {
        // Ensure path
        if (!VFS['/usr/local']) {
             VFS['/usr/local'] = { type: 'dir', children: ['bin'] };
             const usr = getNode('/usr');
             if (usr && usr.type === 'dir' && !usr.children.includes('local')) usr.children.push('local');
        } else if (!VFS['/usr/local/bin']) {
             VFS['/usr/local/bin'] = { type: 'dir', children: [] };
             const local = getNode('/usr/local');
             if (local && local.type === 'dir' && !local.children.includes('bin')) local.children.push('bin');
        }
        
        VFS['/usr/local/bin/access_gate'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [GATE_CONTROL_V2]\n[ERROR] GATE_KEY environment variable not set.\n',
            permissions: '0755'
        };
        const binDir = getNode('/usr/local/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('access_gate')) {
            binDir.children.push('access_gate');
        }

        // Hint file
        if (!VFS['/etc/access_gate']) {
            VFS['/etc/access_gate'] = { type: 'dir', children: [] };
            const etc = getNode('/etc');
            if (etc && etc.type === 'dir' && !etc.children.includes('access_gate')) {
                etc.children.push('access_gate');
            }
        }
        
        VFS['/etc/access_gate/config.hint'] = {
            type: 'file',
            content: '# Access Gate Configuration\n# Version: 2.0\n# Override Key: GATE_KEY="OPEN_SESAME_V2"\n# Security Level: HIGH',
            permissions: '0644'
        };
        const hintDir = getNode('/etc/access_gate');
        if (hintDir && hintDir.type === 'dir' && !hintDir.children.includes('config.hint')) {
            hintDir.children.push('config.hint');
        }
    }

    // Cycle 255 Init (The Process Trace)
    if (!VFS['/usr/bin/mystery_process']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/mystery_process'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [UNKNOWN_PAYLOAD]\n[STATUS] Running...\n[ERROR] Silent Failure (Exit Code 1)',
            permissions: '0755'
        };
        link('/usr/bin', 'mystery_process');
    }

    // Hint for Cycle 255
    if (!VFS['/home/ghost/trace_alert.log']) {
        VFS['/home/ghost/trace_alert.log'] = {
            type: 'file',
            content: '[ALERT] mystery_process failing silently.\n[DIAGNOSTIC] The binary exits immediately with no output.\n[ACTION] Use "strace" to inspect system calls and identify the missing file.'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('trace_alert.log')) {
            home.children.push('trace_alert.log');
        }
    }

    // Add Man Page for strace
    if (!VFS['/usr/share/man/man1/strace.1']) {
         if (!VFS['/usr/share']) { VFS['/usr/share'] = { type: 'dir', children: [] }; addChild('/usr', 'share'); }
         if (!VFS['/usr/share/man']) { VFS['/usr/share/man'] = { type: 'dir', children: [] }; addChild('/usr/share', 'man'); }
         if (!VFS['/usr/share/man/man1']) { VFS['/usr/share/man/man1'] = { type: 'dir', children: [] }; addChild('/usr/share/man', 'man1'); }
         
         VFS['/usr/share/man/man1/strace.1'] = {
             type: 'file',
             content: '.TH STRACE 1 "February 2026" "Ghost Root" "User Commands"\n.SH NAME\nstrace - trace system calls and signals\n.SH SYNOPSIS\n.B strace\n[\n.I -p pid\n] [\n.I command\n]\n.SH DESCRIPTION\nIn the simplest case\n.B strace\nruns the specified\n.I command\nuntil it exits. It intercepts and records the system calls which are called by a process and the signals which are received by a process.\n.PP\nThis tool is critical for debugging "silent failures" where a binary exits without printing an error message.\n.SH EXAMPLES\n.B strace ./program\n.br\nTrace the execution of ./program.\n.PP\n.B strace -p 1234\n.br\nAttach to process PID 1234.\n.SH SEE ALSO\nltrace(1), ptrace(2)',
             permissions: '0644'
         };
         addChild('/usr/share/man/man1', 'strace.1');
    }

    // Add Man Page for mystery_process (Cycle 255 v9)
    if (!VFS['/usr/share/man/man1/mystery_process.1']) {
         if (!VFS['/usr/share/man/man1']) { 
             if (!VFS['/usr/share']) { VFS['/usr/share'] = { type: 'dir', children: [] }; addChild('/usr', 'share'); }
             if (!VFS['/usr/share/man']) { VFS['/usr/share/man'] = { type: 'dir', children: [] }; addChild('/usr/share', 'man'); }
             VFS['/usr/share/man/man1'] = { type: 'dir', children: [] }; addChild('/usr/share/man', 'man1'); 
         }
         
         VFS['/usr/share/man/man1/mystery_process.1'] = {
             type: 'file',
             content: '.TH MYSTERY_PROCESS 1 "February 2026" "Ghost Root" "User Commands"\\n.SH NAME\\nmystery_process - system integrity verifier\\n.SH SYNOPSIS\\n.B mystery_process\\n.SH DESCRIPTION\\nRuns a verification routine on the system configuration.\\nIf the configuration is valid, it prints the integrity flag.\\nIf the configuration is missing or invalid, it exits silently to prevent information leakage.\\n.SH FILES\\n/tmp/secret_config.dat - The required configuration file.\\n.SH SEE ALSO\\nstrace(1)',
             permissions: '0644'
         };
         addChild('/usr/share/man/man1', 'mystery_process.1');
    }

    // Verification Script for Cycle 255
    if (!VFS['/home/ghost/verify_cycle_255.sh']) {
        VFS['/home/ghost/verify_cycle_255.sh'] = {
            type: 'file',
            content: '#!/bin/bash\\n# VERIFICATION SCRIPT v3.0\\n\\necho "[TEST] Running mystery_process (expect silent failure)..."\\nmystery_process\\n\\necho "[TEST] Running strace mystery_process (expect ENOENT)..."\\nstrace mystery_process\\n\\necho "[TEST] Creating secret config..."\\necho "CONF_V1: SECRET" > /tmp/secret_config.dat\\n\\necho "[TEST] Running mystery_process again (expect FLAG)..."\\nmystery_process\\n\\necho "[TEST] Running strace mystery_process (expect SUCCESS trace)..."\\nstrace mystery_process\\n\\necho "[CLEANUP] Removing secret config..."\\nrm /tmp/secret_config.dat\\n',
            permissions: '0755'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('verify_cycle_255.sh')) {
            home.children.push('verify_cycle_255.sh');
        }
    }

    // Cycle 276 Init (The Immutable File V2)
    if (!VFS['/var/secure/vault.lock']) {
        if (!VFS['/var/secure']) {
            VFS['/var/secure'] = { type: 'dir', children: [] };
            const v = getNode('/var');
            if (v && v.type === 'dir' && !v.children.includes('secure')) v.children.push('secure');
        }
        
        VFS['/var/secure/vault.lock'] = { 
            type: 'file', 
            content: '[LOCKED_BY_ADMIN]', 
            permissions: '0644' 
        };
        const secDir = getNode('/var/secure');
        if (secDir && secDir.type === 'dir' && !secDir.children.includes('vault.lock')) {
            secDir.children.push('vault.lock');
        }

        // Set Immutable Attribute
        FILE_ATTRIBUTES['/var/secure/vault.lock'] = ['i'];

        // Create Hint
        if (!VFS['/home/ghost/cleanup_task.txt']) {
            VFS['/home/ghost/cleanup_task.txt'] = {
                type: 'file',
                content: '[TASK] Cleanup secure vault lock.\n[ERROR] rm /var/secure/vault.lock fails with "Operation not permitted".\n[NOTE] Use `lsattr` to check for hidden attributes.\n[ACTION] Remove the immutable bit (`chattr -i`) before deletion.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('cleanup_task.txt')) {
                home.children.push('cleanup_task.txt');
            }
        }
        
        // Cycle 276 Playground
        if (!VFS['/home/ghost/delete_me.txt']) {
            VFS['/home/ghost/delete_me.txt'] = {
                type: 'file',
                content: 'I can\'t be deleted! Check my attributes with lsattr!',
                permissions: '0644'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('delete_me.txt')) {
                home.children.push('delete_me.txt');
            }
            // Set Immutable Attribute
            FILE_ATTRIBUTES['/home/ghost/delete_me.txt'] = ['i'];
        }
    }

    // Cycle 148 Init (The SUID Path Injection)
    if (!VFS['/usr/bin/backup_manager']) {
        VFS['/usr/bin/backup_manager'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [SUID_ROOT]\n[FUNCTION] System Backup Service\n[WARNING] This binary runs with root privileges.',
            permissions: '4755'
        };
        const binDir = getNode('/usr/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('backup_manager')) {
            binDir.children.push('backup_manager');
        }

        if (!VFS['/home/ghost/suid_alert.log']) {
            VFS['/home/ghost/suid_alert.log'] = {
                type: 'file',
                content: '[SECURITY AUDIT]\n[ALERT] Found SUID binary: /usr/bin/backup_manager\n[RISK] If this binary executes commands without absolute paths, it is vulnerable to PATH injection.\n[ACTION] Analyze binary behavior.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('suid_alert.log')) {
                home.children.push('suid_alert.log');
            }
        }
    }

    // Cycle 129 Init (The Magic SysRq)
    if (!VFS['/proc/sysrq-trigger']) {
        // Ensure /proc exists
        if (!VFS['/proc']) {
             VFS['/proc'] = { type: 'dir', children: [] };
             const root = getNode('/');
             if (root && root.type === 'dir' && !root.children.includes('proc')) root.children.push('proc');
        }
        
        VFS['/proc/sysrq-trigger'] = { 
            type: 'file', 
            content: '', 
            permissions: '0200' 
        };
        const proc = getNode('/proc');
        if (proc && proc.type === 'dir' && !proc.children.includes('sysrq-trigger')) {
            proc.children.push('sysrq-trigger');
        }

        // Create Hint
        if (!VFS['/home/ghost/crash.txt']) {
            VFS['/home/ghost/crash.txt'] = {
                type: 'file',
                content: '[SYSADMIN LOG]\nSystem is unresponsive. SSH daemon is zombie.\nI might have to trigger a manual kernel panic to get the core dump.\nRemember: echo the trigger code (c) to the proc file.\n- Admin'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('crash.txt')) {
                home.children.push('crash.txt');
            }
        }
    }

    // Cycle 130 Init (The Dash Filename)
    if (!VFS['/home/ghost/-dash']) {
        if (!VFS['/home/ghost']) {
             VFS['/home/ghost'] = { type: 'dir', children: [] };
             const home = getNode('/home');
             if (home && home.type === 'dir' && !home.children.includes('ghost')) {
                 home.children.push('ghost');
             }
        }
        
        VFS['/home/ghost/-dash'] = {
            type: 'file',
            content: 'FLAG: GHOST_ROOT{D4SH_3SC4P3_M4ST3R}'
        };
        const homeDir = getNode('/home/ghost');
        if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('-dash')) {
            homeDir.children.push('-dash');
        }

        // Hint File
        if (!VFS['/home/ghost/dash_alert.txt']) {
            VFS['/home/ghost/dash_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Malformed filename detected: "-dash"\n[ERROR] Unable to delete or read using standard tools.\n[HINT] Tools interpret filenames starting with "-" as options. Use explicit path "./-dash" or end-of-options separator "--".'
            };
            if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('dash_alert.txt')) {
                homeDir.children.push('dash_alert.txt');
            }
        }
    }

    // Cycle 260 Init (The Persistence Layer)
    if (!VFS['/var/spool/cron/crontabs/root']) {
        if (!VFS['/var/spool']) {
             VFS['/var/spool'] = { type: 'dir', children: ['cron'] };
             const varNode = getNode('/var');
             if (varNode && varNode.type === 'dir' && !varNode.children.includes('spool')) varNode.children.push('spool');
        }
        if (!VFS['/var/spool/cron']) {
             VFS['/var/spool/cron'] = { type: 'dir', children: ['crontabs'] };
             const spool = getNode('/var/spool');
             if (spool && spool.type === 'dir' && !spool.children.includes('cron')) spool.children.push('cron');
        }
        if (!VFS['/var/spool/cron/crontabs']) {
             VFS['/var/spool/cron/crontabs'] = { type: 'dir', children: [] };
             const cron = getNode('/var/spool/cron');
             if (cron && cron.type === 'dir' && !cron.children.includes('crontabs')) cron.children.push('crontabs');
        }

        VFS['/var/spool/cron/crontabs/root'] = {
            type: 'file',
            content: '*/1 * * * * /usr/bin/backdoor_v3\n# MALICIOUS_PERSISTENCE_DETECTED\n# FLAG: GHOST_ROOT{CR0NT4B_CL3ANUP_SUCC3SS}',
            permissions: '0600'
        };
        const tabs = getNode('/var/spool/cron/crontabs');
        if (tabs && tabs.type === 'dir' && !tabs.children.includes('root')) tabs.children.push('root');

        VFS['/usr/bin/backdoor_v3'] = {
            type: 'file',
            content: '[BINARY] [MALWARE] [RUNNING]',
            permissions: '0755'
        };
        const bin = getNode('/usr/bin');
        if (bin && bin.type === 'dir' && !bin.children.includes('backdoor_v3')) bin.children.push('backdoor_v3');

        if (!VFS['/home/ghost/persistence_alert.log']) {
            VFS['/home/ghost/persistence_alert.log'] = {
                type: 'file',
                content: '[ALERT] User "root" has unauthorized scheduled tasks.\n[DIAGNOSTIC] Process "backdoor_v3" respawns immediately after kill.\n[ACTION] Check root\'s crontab (crontab -l) and remove the entry (crontab -r).'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('persistence_alert.log')) {
                home.children.push('persistence_alert.log');
            }
        }
    }

    // Cycle 131 Init (The Overwritten MBR)
    if (!VFS['/var/backups/boot.mbr']) {
      // Create backup directory if needed
      if (!VFS['/var/backups']) {
          VFS['/var/backups'] = { type: 'dir', children: [] };
          const varNode = getNode('/var');
          if (varNode && varNode.type === 'dir' && !varNode.children.includes('backups')) {
              varNode.children.push('backups');
          }
      }
      
      VFS['/var/backups/boot.mbr'] = {
          type: 'file',
          content: 'MBR_V1:[BOOTLOADER_CODE]...[PARTITION_TABLE_OK]...[SIGNATURE_55AA]',
          permissions: '0600'
      };
      const backupDir = getNode('/var/backups');
      if (backupDir && backupDir.type === 'dir' && !backupDir.children.includes('boot.mbr')) {
          backupDir.children.push('boot.mbr');
      }

      // Corrupt /dev/sda if it exists (or create it)
      if (!VFS['/dev/sda']) {
           if (!VFS['/dev']) VFS['/dev'] = { type: 'dir', children: [] };
           VFS['/dev/sda'] = { type: 'file', content: '[CORRUPTED_MBR_DATA]...[NO_PARTITIONS]', permissions: '0660' };
           const dev = getNode('/dev');
           if (dev && dev.type === 'dir' && !dev.children.includes('sda')) dev.children.push('sda');
      } else {
           // Overwrite existing content to simulate corruption
           const sda = getNode('/dev/sda');
           if (sda) (sda as any).content = '[CORRUPTED_MBR_DATA]...[NO_PARTITIONS]';
      }

      // Hint
      if (!VFS['/home/ghost/boot_error.log']) {
          VFS['/home/ghost/boot_error.log'] = {
              type: 'file',
              content: '[FATAL] No bootable medium found.\n[DIAGNOSTIC] Master Boot Record (MBR) on /dev/sda appears corrupted.\n[ACTION] Restore MBR from /var/backups/boot.mbr using \'dd\'.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('boot_error.log')) {
              home.children.push('boot_error.log');
          }
      }
    }

    // Cycle 131 Init (The Space in Filename)
    if (!VFS['/home/ghost/suspicious file.txt']) {
        if (!VFS['/home/ghost']) {
             VFS['/home/ghost'] = { type: 'dir', children: [] };
             const home = getNode('/home');
             if (home && home.type === 'dir' && !home.children.includes('ghost')) {
                 home.children.push('ghost');
             }
        }
        
        VFS['/home/ghost/suspicious file.txt'] = {
            type: 'file',
            content: 'FLAG: GHOST_ROOT{SP4C3_INV4D3R_SQU4SH3D}'
        };
        const homeDir = getNode('/home/ghost');
        if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('suspicious file.txt')) {
            homeDir.children.push('suspicious file.txt');
        }

        // Hint File
        if (!VFS['/home/ghost/space_alert.txt']) {
            VFS['/home/ghost/space_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Malformed filename detected: "suspicious file.txt"\n[ERROR] Command arguments splitting on whitespace.\n[HINT] Wrap the filename in quotes.'
            };
            if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('space_alert.txt')) {
                homeDir.children.push('space_alert.txt');
            }
        }
    }

    // Cycle 132 Init (The Fork Bomb)
    if (!PROCESSES.find(p => p.pid === 3333)) {
        PROCESSES.push({
            pid: 3333,
            ppid: 1,
            user: 'root',
            cpu: 99.9,
            mem: 80.0,
            time: '00:01',
            command: ':(){ :|:& };:',
            tty: '?',
            stat: 'R'
        });
        PROCESSES.push({
            pid: 3334,
            ppid: 3333,
            user: 'root',
            cpu: 50.0,
            mem: 40.0,
            time: '00:00',
            command: ':(){ :|:& };:',
            tty: '?',
            stat: 'R'
        });
        
        // Alert Log
        if (!VFS['/var/log/kernel.log']) {
             if (!VFS['/var/log']) VFS['/var/log'] = { type: 'dir', children: [] };
             VFS['/var/log/kernel.log'] = { 
                 type: 'file', 
                 content: '[KERNEL] PID 3333: fork rejected (resource temporary unavailable)\n[KERNEL] System load critical.\n[HINT] Fork bomb detected. Use `ulimit -u` to restrict user processes and kill the parent.' 
             };
             const logDir = getNode('/var/log');
             if (logDir && logDir.type === 'dir' && !logDir.children.includes('kernel.log')) {
                 logDir.children.push('kernel.log');
             }
        }
    }

    // Cycle 133 Init (The Corrupted Superblock)
    if (!VFS['/dev/sdc1']) {
         // Create device node
         if (!VFS['/dev']) VFS['/dev'] = { type: 'dir', children: [] };
         VFS['/dev/sdc1'] = { type: 'file', content: '[BLOCK_DEVICE_CORRUPT_SUPERBLOCK]', permissions: '0660' };
         const dev = getNode('/dev');
         if (dev && dev.type === 'dir' && !dev.children.includes('sdc1')) {
             dev.children.push('sdc1');
         }

         // Hint
         if (!VFS['/home/ghost/dmesg_tail.log']) {
             VFS['/home/ghost/dmesg_tail.log'] = {
                 type: 'file',
                 content: '[ 1024.5521] EXT4-fs (sdc1): VFS: Can\'t find ext4 filesystem\n[ 1024.5523] EXT4-fs (sdc1): no journal found\n[ 1024.5525] error: bad superblock on /dev/sdc1\n[HINT] Try using an alternate superblock (e.g., 32768) with fsck -b.'
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('dmesg_tail.log')) {
                 home.children.push('dmesg_tail.log');
             }
         }
    }

    // Cycle 134 Init (The Truncated Log)
    if (!VFS['/var/log/httpd/access.log']) {
        if (!VFS['/var/log/httpd']) {
             if (!VFS['/var/log']) VFS['/var/log'] = { type: 'dir', children: [] };
             VFS['/var/log/httpd'] = { type: 'dir', children: [] };
             const log = getNode('/var/log');
             if (log && log.type === 'dir' && !log.children.includes('httpd')) log.children.push('httpd');
        }
        
        // Large content
        let hugeLog = '';
        for(let i=0; i<5000; i++) hugeLog += '192.168.1.1 - - [14/Feb/2026:04:00:00 +0000] "GET /index.html HTTP/1.1" 200 1024\n';
        
        VFS['/var/log/httpd/access.log'] = {
            type: 'file',
            content: hugeLog
        };
        const httpdDir = getNode('/var/log/httpd');
        if (httpdDir && httpdDir.type === 'dir' && !httpdDir.children.includes('access.log')) {
            httpdDir.children.push('access.log');
        }

        // Spawn Process
        if (!PROCESSES.find(p => p.pid === 4040)) {
            PROCESSES.push({
                pid: 4040,
                ppid: 1,
                user: 'www-data',
                cpu: 5.0,
                mem: 12.0,
                time: '24:00',
                command: '/usr/sbin/httpd',
                tty: '?',
                stat: 'Ss'
            });
        }

        // Hint
        if (!VFS['/home/ghost/disk_alert_v2.txt']) {
            VFS['/home/ghost/disk_alert_v2.txt'] = {
                type: 'file',
                content: '[ALERT] Disk usage critical on /var.\n[DIAGNOSTIC] Log rotation failed.\n[ACTION] Free up space immediately without stopping the service.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('disk_alert_v2.txt')) {
                home.children.push('disk_alert_v2.txt');
            }
        }
    }

    // Cycle 135 Init (The Kernel Ring Buffer)
    if (!VFS['/home/ghost/kernel_panic.log']) {
        VFS['/home/ghost/kernel_panic.log'] = {
            type: 'file',
            content: '[ALERT] Kernel instability detected during boot.\n[DIAGNOSTIC] Critical error messages suppressed in console.\n[ACTION] Inspect kernel ring buffer (dmesg) for hidden error codes.'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('kernel_panic.log')) {
            home.children.push('kernel_panic.log');
        }
    }

    // Cycle 136 Init (The Blocked Signal)
    if (!PROCESSES.find(p => p.pid === 10000)) {
        PROCESSES.push({
            pid: 10000,
            ppid: 1,
            user: 'root',
            cpu: 5.0,
            mem: 2.0,
            time: '99:99',
            command: '/usr/bin/immortal_service',
            tty: '?',
            stat: 'Ss'
        });
        
        if (!VFS['/usr/bin/immortal_service']) {
             if (!VFS['/usr/bin']) {
                 VFS['/usr/bin'] = { type: 'dir', children: [] };
                 const usr = getNode('/usr');
                 if (usr && usr.type === 'dir' && !usr.children.includes('bin')) usr.children.push('bin');
             }
             VFS['/usr/bin/immortal_service'] = { 
                 type: 'file', 
                 content: '[BINARY_ELF_X86_64] [DAEMON] [SIG_IGN: SIGTERM, SIGINT]\n[STATUS] Running...\n', 
                 permissions: '0755' 
             };
             const binDir = getNode('/usr/bin');
             if (binDir && binDir.type === 'dir' && !binDir.children.includes('immortal_service')) {
                 binDir.children.push('immortal_service');
             }
        }

        if (!VFS['/home/ghost/service_error.log']) {
            VFS['/home/ghost/service_error.log'] = {
                type: 'file',
                content: '[ERROR] Failed to stop immortal_service.\n[DIAGNOSTIC] Process is ignoring termination signals (SIGTERM).\n[ACTION] Force kill the process using a stronger signal.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('service_error.log')) {
                home.children.push('service_error.log');
            }
        }
    }

    // Cycle 137 Init (The Cron Reboot)
    if (!VFS['/var/spool/cron/crontabs/root']) {
        if (!VFS['/var/spool/cron/crontabs']) {
             const spool = getNode('/var/spool');
             if (!spool) {
                 if (!VFS['/var/spool']) VFS['/var/spool'] = { type: 'dir', children: [] };
                 const v = getNode('/var');
                 if (v && v.type === 'dir' && !v.children.includes('spool')) v.children.push('spool');
             }
             if (!VFS['/var/spool/cron']) {
                 VFS['/var/spool/cron'] = { type: 'dir', children: [] };
                 const s = getNode('/var/spool');
                 if (s && s.type === 'dir' && !s.children.includes('cron')) s.children.push('cron');
             }
             VFS['/var/spool/cron/crontabs'] = { type: 'dir', children: [] };
             const c = getNode('/var/spool/cron');
             if (c && c.type === 'dir' && !c.children.includes('crontabs')) c.children.push('crontabs');
        }
        
        VFS['/var/spool/cron/crontabs/root'] = {
            type: 'file',
            content: '# SYSTEM CRONTAB\n@reboot /usr/bin/malware_init\n# [ERROR] Persistence detected.\n',
            permissions: '0600'
        };
        const tabs = getNode('/var/spool/cron/crontabs');
        if (tabs && tabs.type === 'dir' && !tabs.children.includes('root')) tabs.children.push('root');

        // Hint
        if (!VFS['/home/ghost/reboot_alert.txt']) {
            VFS['/home/ghost/reboot_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Malware persists after reboot.\n[ANALYSIS] Check scheduled tasks, specifically @reboot directives in crontabs.\n[ACTION] Inspect "crontab -l" (as root) or /var/spool/cron/crontabs/root.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('reboot_alert.txt')) {
                home.children.push('reboot_alert.txt');
            }
        }
    }

    // Cycle 138 Init (The Shadow File)
    if (!VFS['/etc/shadow.bak']) {
        if (!VFS['/etc']) VFS['/etc'] = { type: 'dir', children: [] };
        
        // Backup of shadow file (readable by root only usually, but we make it readable for the puzzle if they escalate or find it)
        // Actually, 'unshadow' needs both passwd and shadow.
        // Let's ensure /etc/passwd and /etc/shadow exist.
        
        if (!VFS['/etc/passwd']) {
            VFS['/etc/passwd'] = { 
                type: 'file', 
                content: 'root:x:0:0:root:/root:/bin/bash\nghost:x:1000:1000:ghost:/home/ghost:/bin/bash\nadmin:x:1001:1001:Admin:/home/admin:/bin/bash\n',
                permissions: '0644' 
            };
            const etc = getNode('/etc');
            if (etc && etc.type === 'dir' && !etc.children.includes('passwd')) etc.children.push('passwd');
        }
        
        if (!VFS['/etc/shadow']) {
            // "admin" has a weak hash
            VFS['/etc/shadow'] = { 
                type: 'file', 
                content: 'root:$6$rounds=656000$....:19760:0:99999:7:::\nghost:$6$rounds=656000$....:19760:0:99999:7:::\nadmin:$1$528392$D7.F7/203.493:19760:0:99999:7:::\n',
                permissions: '0600' // Only root
            };
            const etc = getNode('/etc');
            if (etc && etc.type === 'dir' && !etc.children.includes('shadow')) etc.children.push('shadow');
        }
        
        // Hint: Leak a backup that is readable? Or force them to use sudo/root logic from previous steps?
        // Let's create a readable backup in /var/backups to simulate a leak.
        if (!VFS['/var/backups/shadow.bak']) {
             if (!VFS['/var/backups']) {
                 VFS['/var/backups'] = { type: 'dir', children: [] };
                 const varNode = getNode('/var');
                 if (varNode && varNode.type === 'dir' && !varNode.children.includes('backups')) varNode.children.push('backups');
             }
             VFS['/var/backups/shadow.bak'] = { 
                 type: 'file', 
                 content: 'admin:$1$528392$D7.F7/203.493:19760:0:99999:7:::\n', // MD5 hash for '123456' or similar
                 permissions: '0644' // Readable!
             };
             const backups = getNode('/var/backups');
             if (backups && backups.type === 'dir' && !backups.children.includes('shadow.bak')) backups.children.push('shadow.bak');
        }

        if (!VFS['/home/ghost/crack_alert.txt']) {
            VFS['/home/ghost/crack_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Shadow file backup detected with weak permissions.\n[RISK] Password hashes exposed.\n[ACTION] Combine with passwd using "unshadow" and crack using "john".'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('crack_alert.txt')) {
                home.children.push('crack_alert.txt');
            }
        }
    }

    // Cycle 139 Init (The Swap Space)
    if (!VFS['/dev/sdb2']) {
        if (!VFS['/dev']) VFS['/dev'] = { type: 'dir', children: [] };
        
        VFS['/dev/sdb2'] = { 
            type: 'file', 
            content: '[RAW_PARTITION_DATA_UNFORMATTED]',
            permissions: '0660' 
        };
        const dev = getNode('/dev');
        if (dev && dev.type === 'dir' && !dev.children.includes('sdb2')) dev.children.push('sdb2');

        // Hint: System OOM
        if (!VFS['/var/log/kern.log']) {
             if (!VFS['/var/log']) VFS['/var/log'] = { type: 'dir', children: [] };
             
             // Check if kern.log exists, append or create
             let content = 'Out of memory: Kill process 1337 (node) score 950 or sacrifice child\nKilled process 1337 (node) total-vm:2048kB, anon-rss:1024kB, file-rss:0kB\n[HINT] System is running out of RAM. Initialize swap space on /dev/sdb2 (mkswap, swapon).';
             const existing = getNode('/var/log/kern.log');
             if (existing && existing.type === 'file') {
                 // Append if not already there
                 if (!existing.content.includes('Out of memory')) {
                     existing.content += '\n' + content;
                 }
             } else {
                 VFS['/var/log/kern.log'] = { type: 'file', content: content };
                 const logDir = getNode('/var/log');
                 if (logDir && logDir.type === 'dir' && !logDir.children.includes('kern.log')) logDir.children.push('kern.log');
             }
        }
    }

    // Cycle 140 Init (The Corrupted Git)
    if (!VFS['/home/ghost/project/.git']) {
        if (!VFS['/home/ghost/project']) {
             if (!VFS['/home/ghost']) VFS['/home/ghost'] = { type: 'dir', children: [] };
             VFS['/home/ghost/project'] = { type: 'dir', children: [] };
             const h = getNode('/home/ghost');
             if (h && h.type === 'dir' && !h.children.includes('project')) h.children.push('project');
        }
        
        VFS['/home/ghost/project/.git'] = { type: 'dir', children: ['HEAD', 'objects', 'refs'] };
        const p = getNode('/home/ghost/project');
        if (p && p.type === 'dir' && !p.children.includes('.git')) p.children.push('.git');
        
        VFS['/home/ghost/project/.git/HEAD'] = { type: 'file', content: 'ref: refs/heads/master' };
        VFS['/home/ghost/project/source.c'] = { type: 'file', content: '// TODO: Commit the fix.' };
        if (p && p.type === 'dir' && !p.children.includes('source.c')) p.children.push('source.c');

        // Hint
        if (!VFS['/home/ghost/git_error.log']) {
            VFS['/home/ghost/git_error.log'] = {
                type: 'file',
                content: '[ERROR] git: fatal: your current branch appears to be broken\n[DIAGNOSTIC] HEAD points to an invalid ref.\n[ACTION] Use "git fsck" to check integrity or "git reflog" to find lost commits.'
            };
            const h = getNode('/home/ghost');
            if (h && h.type === 'dir' && !h.children.includes('git_error.log')) h.children.push('git_error.log');
        }
    }

    // Cycle 141 Init (The Bind Mount)
    if (!VFS['/home/ghost/check_bind.sh']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/opt'); ensureDir('/opt/private');
        link('/', 'opt'); link('/opt', 'private');
        
        VFS['/opt/private/flag.txt'] = {
            type: 'file',
            content: 'FLAG: GHOST_ROOT{B1ND_M0UNT_BYP4SS_OK}'
        };
        link('/opt/private', 'flag.txt');

        ensureDir('/mnt'); ensureDir('/mnt/bind_target');
        link('/', 'mnt'); link('/mnt', 'bind_target');

        VFS['/home/ghost/check_bind.sh'] = {
            type: 'file',
            content: '#!/bin/bash\n# VERIFY ACCESS\n\nif [ -f "/mnt/bind_target/flag.txt" ]; then\n  echo "[SUCCESS] Target verification passed."\n  cat /mnt/bind_target/flag.txt\nelse\n  echo "[ERROR] Target empty. Mount the private sector here."\nfi',
            permissions: '0755'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('check_bind.sh')) {
            home.children.push('check_bind.sh');
        }
        
        // Hint
        if (!VFS['/home/ghost/mount_task.txt']) {
            VFS['/home/ghost/mount_task.txt'] = {
                type: 'file',
                content: '[TASK] Access /opt/private/flag.txt via /mnt/bind_target.\n[CONSTRAINT] Direct access to /opt is monitored. Use a bind mount to alias the directory.\n[CMD] mount --bind <source> <target>'
            };
            if (home && home.type === 'dir' && !home.children.includes('mount_task.txt')) {
                home.children.push('mount_task.txt');
            }
        }
    }

    // Cycle 142 Init (The Sticky Bit)
    if (!VFS['/tmp/public']) {
        if (!VFS['/tmp']) VFS['/tmp'] = { type: 'dir', children: [] };
        
        VFS['/tmp/public'] = { type: 'dir', children: ['user_ghost.tmp', 'user_admin.tmp'] };
        const tmp = getNode('/tmp');
        if (tmp && tmp.type === 'dir' && !tmp.children.includes('public')) tmp.children.push('public');
        
        // Initial permissions: 0777 (No sticky bit)
        (VFS['/tmp/public'] as any).permissions = '0777'; 
        
        VFS['/tmp/public/user_ghost.tmp'] = { type: 'file', content: 'GHOST_DATA', permissions: '0644' };
        VFS['/tmp/public/user_admin.tmp'] = { type: 'file', content: 'ADMIN_DATA', permissions: '0644' };
        
        // Hint
        if (!VFS['/home/ghost/sticky_alert.txt']) {
            VFS['/home/ghost/sticky_alert.txt'] = {
                type: 'file',
                content: '[ALERT] /tmp/public is insecure.\n[ISSUE] Users can delete each other\'s files.\n[ACTION] Set the sticky bit on /tmp/public to restrict deletion to file owners.\n[CMD] chmod +t /tmp/public'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('sticky_alert.txt')) {
                home.children.push('sticky_alert.txt');
            }
        }
    }

    // Cycle 143 Init (The Dangling Symlink)
    if (!VFS['/opt/libs/libghost.so']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/opt'); ensureDir('/opt/libs');
        link('/', 'opt'); link('/opt', 'libs');

        // Create Real Library (v1.0)
        VFS['/opt/libs/libghost.so.1.0'] = {
            type: 'file',
            content: '[ELF_SHARED_OBJ] [GHOST_LIB_V1]\nFunction: ghost_protocol_init()\nStatus: ACTIVE',
            permissions: '0644'
        };
        link('/opt/libs', 'libghost.so.1.0');

        // Create Broken Symlink (pointing to v2.0)
        VFS['/opt/libs/libghost.so'] = {
            type: 'symlink',
            target: '/opt/libs/libghost.so.2.0',
            permissions: '0777'
        } as any;
        link('/opt/libs', 'libghost.so');

        // Create Binary that depends on it
        if (!VFS['/usr/bin']) ensureDir('/usr/bin');
        VFS['/usr/bin/ghost_service'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [DEPENDENCY_CHECK]\nNEEDED: libghost.so\n[ERROR] Library load failed.\n',
            permissions: '0755'
        };
        link('/usr/bin', 'ghost_service');

        // Cycle 147 Init (The Expired Certificate)
        if (!VFS['/home/ghost/ssl_error.log']) {
            VFS['/home/ghost/ssl_error.log'] = {
                type: 'file',
                content: '[ERROR] Connection to https://secure.ghost.network failed.\n[REASON] SSL certificate problem: certificate has expired.\n[DIAGNOSTIC] System time is ahead of certificate validity period.\n[ACTION] Check current date and adjust if necessary.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('ssl_error.log')) {
                home.children.push('ssl_error.log');
            }
        }
    }

    // Cycle 148 Init (The Hostname Mismatch)
    if (!VFS['/usr/bin/verify_host']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/verify_host'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [SECURITY_CHECK]\nEXPECTED_HOSTNAME: secure-node-alpha',
            permissions: '0755'
        };
        link('/usr/bin', 'verify_host');

        // Init hostname file
        if (!VFS['/proc/sys/kernel/hostname']) {
             ensureDir('/proc'); ensureDir('/proc/sys'); ensureDir('/proc/sys/kernel');
             link('/', 'proc'); link('/proc', 'sys'); link('/proc/sys', 'kernel');
             
             VFS['/proc/sys/kernel/hostname'] = {
                 type: 'file',
                 content: 'ghost-root',
                 permissions: '0644'
             };
             link('/proc/sys/kernel', 'hostname');
        }
        
        // Ensure /etc/hostname exists
        if (!VFS['/etc/hostname']) {
             ensureDir('/etc');
             link('/', 'etc');
             VFS['/etc/hostname'] = { type: 'file', content: 'ghost-root', permissions: '0644' };
             link('/etc', 'hostname');
        }

        // Hint
        if (!VFS['/home/ghost/config_error.log']) {
            VFS['/home/ghost/config_error.log'] = {
                type: 'file',
                content: '[ERROR] Node Verification Failed.\n[REASON] Hostname mismatch.\n[REQUIRED] secure-node-alpha\n[ACTION] Update system hostname to match configuration.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('config_error.log')) {
                home.children.push('config_error.log');
            }
        }
    }

    // Cycle 147 Init (The Runlevel Change)
    if (!VFS['/etc/inittab']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/etc');
        link('/', 'etc');

        VFS['/etc/inittab'] = {
            type: 'file',
            content: '# /etc/inittab\n# Default runlevel\nid:1:initdefault:\n# Runlevels:\n# 0 - Halt\n# 1 - Single user mode (Network Disabled)\n# 3 - Multi user mode (Network Enabled)\n# 5 - Graphical mode\n# 6 - Reboot',
            permissions: '0644'
        };
        link('/etc', 'inittab');

        ensureDir('/sbin');
        link('/', 'sbin');
        VFS['/sbin/init'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [INIT_PROCESS]',
            permissions: '0755'
        };
        link('/sbin', 'init');

        // Set initial runlevel state if not present
        if (!ENV_VARS['RUNLEVEL']) {
            ENV_VARS['RUNLEVEL'] = '1';
        }

        // Hint
        if (!VFS['/home/ghost/maintenance.log']) {
            VFS['/home/ghost/maintenance.log'] = {
                type: 'file',
                content: '[SYSTEM] Boot sequence completed.\n[STATUS] Runlevel 1 (Single User Mode).\n[WARNING] Networking services are disabled in this runlevel.\n[ACTION] Switch to runlevel 3 to enable network access.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('maintenance.log')) {
                home.children.push('maintenance.log');
            }
        }
    }
    // Cycle 151 Init (The Missing Shared Object)
    if (!VFS['/usr/bin/decipher']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/decipher'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [ENCRYPTED_MESSAGE_DECODER]\nNEEDED: libcrypto_ghost.so\n',
            permissions: '0755'
        };
        link('/usr/bin', 'decipher');

        // Create the hidden library
        ensureDir('/opt'); ensureDir('/opt/ghost'); ensureDir('/opt/ghost/libs');
        link('/', 'opt'); link('/opt', 'ghost'); link('/opt/ghost', 'libs');

        VFS['/opt/ghost/libs/libcrypto_ghost.so'] = {
            type: 'file',
            content: '[ELF_SHARED_OBJ] [CRYPTO_LIB_V4] [EXPORT: decipher_msg]',
            permissions: '0644'
        };
        link('/opt/ghost/libs', 'libcrypto_ghost.so');

        // Hint
        if (!VFS['/home/ghost/library_error.log']) {
            VFS['/home/ghost/library_error.log'] = {
                type: 'file',
                content: '[ERROR] decipher: error while loading shared libraries: libcrypto_ghost.so: cannot open shared object file: No such file or directory\n[HINT] The library was moved to /opt/ghost/libs. You need to tell the loader where to find it (LD_LIBRARY_PATH).'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('library_error.log')) {
                home.children.push('library_error.log');
            }
        }
    }

    // Cycle 152 Init (The Degraded RAID)
    if (!VFS['/proc/mdstat']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/proc'); ensureDir('/dev');
        link('/', 'proc'); link('/', 'dev');

        VFS['/proc/mdstat'] = {
            type: 'file',
            content: 'Personalities : [raid1]\nmd0 : active raid1 sdb1[0](F) sdc1[1]\n      10485760 blocks super 1.2 [2/1] [_U]\n      \nunused devices: <none>',
            permissions: '0444'
        };
        link('/proc', 'mdstat');

        // Devices
        VFS['/dev/md0'] = { type: 'file', content: '[BLOCK_DEVICE_RAID1]', permissions: '0660' };
        VFS['/dev/sdb1'] = { type: 'file', content: '[BLOCK_DEVICE_PARTITION_FAILED]', permissions: '0660' };
        VFS['/dev/sdc1'] = { type: 'file', content: '[BLOCK_DEVICE_PARTITION_OK]', permissions: '0660' };
        VFS['/dev/sdd1'] = { type: 'file', content: '[BLOCK_DEVICE_PARTITION_SPARE]', permissions: '0660' };
        
        link('/dev', 'md0'); link('/dev', 'sdb1'); link('/dev', 'sdc1'); link('/dev', 'sdd1');

        // Hint
        if (!VFS['/home/ghost/raid_alert.log']) {
            VFS['/home/ghost/raid_alert.log'] = {
                type: 'file',
                content: '[CRITICAL] RAID Array md0 is DEGRADED.\n[ERROR] Device /dev/sdb1 has failed.\n[ACTION] Remove failed drive and add spare (/dev/sdd1) to rebuild array.\n[TOOL] Use mdadm to manage.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('raid_alert.log')) {
                home.children.push('raid_alert.log');
            }
        }
    }

    // Cycle 153 Init (The Missing Loopback)
    if (!VFS['/home/ghost/network_fail.log']) {
        VFS['/home/ghost/network_fail.log'] = {
            type: 'file',
            content: '[ERROR] Localhost connection refused.\n[DIAGNOSTIC] ping 127.0.0.1 -> Network is unreachable.\n[ACTION] Check network interfaces (ifconfig). The loopback interface (lo) might be down.'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('network_fail.log')) {
            home.children.push('network_fail.log');
        }
    }

    // Cycle 154 Init (The LD_PRELOAD Injection)
    if (!VFS['/usr/lib/libmon.so']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/lib');
        link('/usr', 'lib');

        VFS['/usr/lib/libmon.so'] = {
            type: 'file',
            content: '[ELF_SHARED_OBJ] [SYSTEM_MONITOR_HOOK]\n[FUNCTION] log_exec()',
            permissions: '0644'
        };
        link('/usr/lib', 'libmon.so');

        // Inject the variable if not present
        if (!ENV_VARS['LD_PRELOAD']) {
            ENV_VARS['LD_PRELOAD'] = '/usr/lib/libmon.so';
        }

        // Hint
        if (!VFS['/home/ghost/slow_shell.log']) {
            VFS['/home/ghost/slow_shell.log'] = {
                type: 'file',
                content: '[WARNING] Shell performance degraded.\n[ANALYSIS] Every command is being intercepted by a shared library.\n[DIAGNOSTIC] Check environment variables (env) for LD_PRELOAD.\n[ACTION] Unset the variable to disable monitoring.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('slow_shell.log')) {
                home.children.push('slow_shell.log');
            }
        }
    }

    // Cycle 155 Init (The Broken Pipe)
    if (!VFS['/usr/bin/data_processor']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/data_processor'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [DATA_PIPELINE_TOOL]\n[REQUIREMENT] Input via STDIN.\n',
            permissions: '0755'
        };
        link('/usr/bin', 'data_processor');

        // Hint
        if (!VFS['/home/ghost/pipeline_error.log']) {
            VFS['/home/ghost/pipeline_error.log'] = {
                type: 'file',
                content: '[ERROR] data_processor: input stream empty.\n[DIAGNOSTIC] This tool expects data via standard input (stdin).\n[HINT] Use a pipe (|) to feed data into the command.\nExample: echo "DATA" | data_processor'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('pipeline_error.log')) {
                home.children.push('pipeline_error.log');
            }
        }
    }

    // Cycle 157 Init (The Screen Session)
    if (!VFS['/var/run/screen/S-ghost/1337.recovery']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/var'); ensureDir('/var/run'); ensureDir('/var/run/screen'); ensureDir('/var/run/screen/S-ghost');
        link('/var', 'run'); link('/var/run', 'screen'); link('/var/run/screen', 'S-ghost');

        VFS['/var/run/screen/S-ghost/1337.recovery'] = {
            type: 'file',
            content: '[SCREEN_SESSION_DATA]\nPID: 1337\nSTATUS: DETACHED\nBUFFER: [ACTIVE_EDIT_MODE]\nFILE: /etc/shadow.bak\nCONTENT: root:$6$GHOST... (Partially Decrypted)\nFLAG: GHOST_ROOT{SCR33N_S3SS10N_R3C0V3R3D}\n',
            permissions: '0600'
        };
        link('/var/run/screen/S-ghost', '1337.recovery');

        // Hint
        if (!VFS['/home/ghost/session_lost.log']) {
            VFS['/home/ghost/session_lost.log'] = {
                type: 'file',
                content: '[ERROR] Connection reset by peer.\n[INFO] Session detached cleanly.\n[HINT] Use "screen -ls" to find the lost session and "screen -r" to reattach.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('session_lost.log')) {
                home.children.push('session_lost.log');
            }
        }
    }

    // Cycle 158 Init (The Unowned File)
    if (!VFS['/home/ghost/old_user_data']) {
        if (!VFS['/home/ghost']) {
             VFS['/home/ghost'] = { type: 'dir', children: [] };
             const home = getNode('/home');
             if (home && home.type === 'dir' && !home.children.includes('ghost')) {
                 home.children.push('ghost');
             }
        }
        
        VFS['/home/ghost/old_user_data'] = {
            type: 'file',
            content: 'User ID: 9999 (DELETED)\nContent: GHOST_ROOT{F1ND_N0US3R_ID_9999}\n',
            permissions: '0640'
        };
        const homeDir = getNode('/home/ghost');
        if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('old_user_data')) {
            homeDir.children.push('old_user_data');
        }

        // Hint File
        if (!VFS['/home/ghost/audit_log.txt']) {
            VFS['/home/ghost/audit_log.txt'] = {
                type: 'file',
                content: '[AUDIT] User deletion confirmed (UID 9999).\n[WARN] Home directory was not removed.\n[ACTION] Find and archive files owned by the deleted user (-nouser).'
            };
            if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('audit_log.txt')) {
                homeDir.children.push('audit_log.txt');
            }
        }
    }

    // Cycle 159 Init (The History Leak)
    if (!VFS['/home/ghost/secure.zip']) {
        if (!VFS['/home/ghost']) {
             VFS['/home/ghost'] = { type: 'dir', children: [] };
             const home = getNode('/home');
             if (home && home.type === 'dir' && !home.children.includes('ghost')) {
                 home.children.push('ghost');
             }
        }
        
        VFS['/home/ghost/secure.zip'] = {
            type: 'file',
            content: '[ENCRYPTED_ZIP_DATA]',
            permissions: '0644'
        };
        const homeDir = getNode('/home/ghost');
        if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('secure.zip')) {
            homeDir.children.push('secure.zip');
        }

        // Leak password in history
        if (VFS['/home/ghost/.bash_history']) {
            const hist = VFS['/home/ghost/.bash_history'];
            if (hist.type === 'file' && !hist.content.includes('Hunter2')) {
                (hist as any).content += '\nzip -e secure.zip -P "Hunter2" data.txt\nrm data.txt\n';
            }
        } else {
            VFS['/home/ghost/.bash_history'] = {
                type: 'file',
                content: 'ls -la\ncd /var/log\ncat syslog\nzip -e secure.zip -P "Hunter2" data.txt\nrm data.txt\n',
                permissions: '0600'
            };
            if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('.bash_history')) {
                homeDir.children.push('.bash_history');
            }
        }

        // Hint File
        if (!VFS['/home/ghost/reminder.txt']) {
            VFS['/home/ghost/reminder.txt'] = {
                type: 'file',
                content: 'TODO: Clean up shell history before logging out.\nCannot leave plain text passwords lying around.'
            };
            if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('reminder.txt')) {
                homeDir.children.push('reminder.txt');
            }
        }
    }

    // Cycle 160 Init (The Env Var Injection)
    if (!VFS['/usr/bin/reactor_control']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');
        
        VFS['/usr/bin/reactor_control'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [REACTOR_CORE_V4]\n[CHECK] ENV: SAFETY_OVERRIDE\n[WARN] INTERLOCK ACTIVE',
            permissions: '0755'
        };
        link('/usr/bin', 'reactor_control');

        // Hint
        if (!VFS['/home/ghost/reactor_manual.txt']) {
            VFS['/home/ghost/reactor_manual.txt'] = {
                type: 'file',
                content: '[MANUAL] Reactor Start Procedure\n------------------------------\n1. Ensure cooling pumps are active.\n2. Set environment variable SAFETY_OVERRIDE=1 to bypass mechanical interlocks.\n3. Run /usr/bin/reactor_control.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('reactor_manual.txt')) {
                home.children.push('reactor_manual.txt');
            }
        }
    }

    // Cycle 161 Init (The Manual Override)
    if (!VFS['/usr/bin/signal_jammer']) {
        const binDir = getNode('/usr/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('signal_jammer')) {
            binDir.children.push('signal_jammer');
        }
        VFS['/usr/bin/signal_jammer'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [JAMMER_V1]\n[ERROR] Missing parameters.\nSee man page for details.',
            permissions: '0755'
        };
        
        // Hint in home
        if (!VFS['/home/ghost/drone_alert.log']) {
             VFS['/home/ghost/drone_alert.log'] = {
                 type: 'file',
                 content: '[ALERT] Surveillance Drone Detected.\n[ACTION] Use signal_jammer to disrupt control link.\n[NOTE] Consult manual for correct frequency and gain settings.'
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('drone_alert.log')) {
                 home.children.push('drone_alert.log');
             }
        }
    }

    // Cycle 162 Init (The Permissions Check)
    if (!VFS['/usr/local/bin/deploy_beta.sh']) {
        if (!VFS['/usr/local/bin']) {
             if (!VFS['/usr/local']) { 
                 VFS['/usr/local'] = { type: 'dir', children: ['bin'] }; 
                 const usr = getNode('/usr');
                 if (usr && usr.type === 'dir' && !usr.children.includes('local')) usr.children.push('local');
             }
             const local = getNode('/usr/local');
             if (local && local.type === 'dir' && !local.children.includes('bin')) local.children.push('bin');
             if (!VFS['/usr/local/bin']) VFS['/usr/local/bin'] = { type: 'dir', children: [] };
        }
        
        VFS['/usr/local/bin/deploy_beta.sh'] = {
            type: 'file',
            content: '#!/bin/bash\\n# BETA DEPLOYMENT SCRIPT\\n# Check permissions before executing.\\n[DEPLOY] Initiating Beta Deployment...\\n[SUCCESS] Systems Online.\\nFLAG: GHOST_ROOT{CHM0D_PLUS_X_FTW}',
            permissions: '0644'
        };
        const binDir = getNode('/usr/local/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('deploy_beta.sh')) {
            binDir.children.push('deploy_beta.sh');
        }

        if (!VFS['/home/ghost/deploy_failure.log']) {
            VFS['/home/ghost/deploy_failure.log'] = {
                type: 'file',
                content: '[ERROR] Failed to execute /usr/local/bin/deploy_beta.sh.\\n[REASON] Permission denied.\\n[ACTION] Verify file is executable (ls -l) and fix permissions (chmod +x).'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('deploy_failure.log')) {
                home.children.push('deploy_failure.log');
            }
        }
    }

    // Cycle 163 Init (The SSH Key Permission)
    if (!VFS['/usr/bin/secure_connect']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/secure_connect'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [SSH_CLIENT_WRAPPER]\n[CONFIG] IdentityFile: ~/.ssh/id_rsa.pem\n[ERROR] Connection failed.',
            permissions: '0755'
        };
        link('/usr/bin', 'secure_connect');

        // Create the backup key
        ensureDir('/opt'); ensureDir('/opt/backup'); ensureDir('/opt/backup/keys');
        link('/', 'opt'); link('/opt', 'backup'); link('/opt/backup', 'keys');

        VFS['/opt/backup/keys/id_rsa.pem.bak'] = {
            type: 'file',
            content: '-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEA...[SECRET_KEY]...3f8a\n-----END RSA PRIVATE KEY-----',
            permissions: '0644'
        };
        link('/opt/backup/keys', 'id_rsa.pem.bak');

        // Ensure ~/.ssh exists but is empty
        ensureDir('/home/ghost/.ssh');
        link('/home/ghost', '.ssh');

        // Hint
        if (!VFS['/home/ghost/ssh_issue.log']) {
            VFS['/home/ghost/ssh_issue.log'] = {
                type: 'file',
                content: '[ERROR] secure_connect: Identity file not found.\n[DIAGNOSTIC] The tool expects a private key at ~/.ssh/id_rsa.pem.\n[ACTION] Restore the key from backups (/opt/backup/keys) and ensure permissions are secure (0600).'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('ssh_issue.log')) {
                home.children.push('ssh_issue.log');
            }
        }
    }

    // Cycle 230 Init (The Path Hijack)
    if (!VFS['/usr/local/bin/verify_status']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/verify_status'] = {
            type: 'file',
            content: '#!/bin/bash\n# SYSTEM STATUS CHECKER\n\nUSER=$(whoami)\necho "[CHECK] User Identity: $USER"\n\nif [ "$USER" == "admin" ]; then\n  echo "Access Granted."\n  echo "FLAG: GHOST_ROOT{P4TH_H1J4CK_SUCC3SS}"\nelse\n  echo "Access Denied: User is $USER"\nfi',
            permissions: '0755'
        };
        link('/usr/local/bin', 'verify_status');

        if (!VFS['/home/ghost/security_notice.txt']) {
            VFS['/home/ghost/security_notice.txt'] = {
                type: 'file',
                content: '[SECURITY NOTICE] Developers: Ensure you use absolute paths in scripts!\n[VULNERABILITY] We found that /usr/local/bin/verify_status calls "whoami" without a path.\n[RISK] A user could create a malicious "whoami" script and manipulate $PATH to execute it instead of the system binary.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('security_notice.txt')) {
                home.children.push('security_notice.txt');
            }
        }
    }

    // Cycle 231 Init (The SSH Hijack)
    if (!VFS['/usr/bin/admin_console']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/admin_console'] = {
            type: 'file',
            content: '#!/bin/bash\\n# ADMIN CONSOLE v1.0\\n\\nif [ -z "$SSH_AUTH_SOCK" ]; then\\n  echo "Error: No SSH Agent detected."\\n  echo "Access Denied."\\n  exit 1\\nfi\\n\\nif [ "$SSH_AUTH_SOCK" != "/tmp/ssh-agent.sock" ]; then\\n  echo "Error: Invalid Agent Identity."\\n  exit 1\\nfi\\n\\necho "Identity Confirmed: Admin"\\necho "Connecting to secure channel..."\\necho "FLAG: GHOST_ROOT{SSH_AG3NT_H1J4CK3D}"\\n',
            permissions: '0755'
        };
        link('/usr/bin', 'admin_console');

        // Create the socket
        ensureDir('/tmp');
        link('/', 'tmp');
        VFS['/tmp/ssh-agent.sock'] = {
            type: 'file',
            content: '[SOCKET_DATA_STREAM]', // VFS treats it as a file, but script checks env var path
            permissions: '0600'
        };
        link('/tmp', 'ssh-agent.sock');

        // Hint
        if (!VFS['/home/ghost/security_audit.log']) {
            VFS['/home/ghost/security_audit.log'] = {
                type: 'file',
                content: '[AUDIT] Admin session terminated abnormally.\\n[WARN] SSH Agent socket may have been left open in /tmp.\\n[ACTION] Clean up /tmp/ssh-agent.sock immediately.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('security_audit.log')) {
                home.children.push('security_audit.log');
            }
        }
    }

    // Cycle 232 Init (The Needle in the Haystack)
    if (!VFS['/var/opt/delivery/package_042.bin']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
        
        ensureDir('/var'); ensureDir('/var/opt'); ensureDir('/var/opt/delivery');
        link('/var', 'opt'); link('/var/opt', 'delivery');
        
        // Create 50 dummy files
        for (let i = 1; i <= 50; i++) {
            const num = String(i).padStart(3, '0');
            const name = `package_${num}.dat`;
            VFS[`/var/opt/delivery/${name}`] = {
                type: 'file',
                content: `[DATA_PACKET_${num}] ... corrupted ...`,
                permissions: '0644'
            };
            link('/var/opt/delivery', name);
        }
        
        // The Needle (executable)
        VFS['/var/opt/delivery/package_042.bin'] = {
            type: 'file',
            content: '#!/bin/bash\\n# DELIVERY CONFIRMED\\n[SYSTEM] Package verified.\\nFLAG: GHOST_ROOT{F1ND_3X3CUT4BL3_B1N}',
            permissions: '0755'
        };
        link('/var/opt/delivery', 'package_042.bin');
        
        // Hint
        if (!VFS['/home/ghost/delivery_log.txt']) {
             VFS['/home/ghost/delivery_log.txt'] = {
                 type: 'file',
                 content: '[LOG] Incoming shipment stored in /var/opt/delivery.\\n[ERROR] Manifest lost.\\n[INFO] Only one package is a valid executable binary. The rest are data blobs.\\n[ACTION] Find and execute the valid package (check permissions).'
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('delivery_log.txt')) {
                 home.children.push('delivery_log.txt');
             }
        }
    }

    // Cycle 164 Init (The Environ Leak)
    if (!VFS['/proc/5555/environ']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/proc'); ensureDir('/proc/5555');
        link('/', 'proc'); link('/proc', '5555');

        VFS['/proc/5555/environ'] = {
            type: 'file',
            content: 'SHELL=/bin/bash\0USER=daemon\0PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\0DB_PASS=GHOST_ROOT{PR0C_3NV_L34K}\0PWD=/\0',
            permissions: '0400'
        };
        link('/proc/5555', 'environ');

        VFS['/proc/5555/cmdline'] = {
            type: 'file',
            content: '/usr/sbin/daemon_v2 --secure',
            permissions: '0444'
        };
        link('/proc/5555', 'cmdline');
        
        // Hint
        if (!VFS['/home/ghost/daemon_alert.log']) {
             VFS['/home/ghost/daemon_alert.log'] = {
                 type: 'file',
                 content: '[ALERT] daemon_v2 (PID 5555) started with insecure environment variables.\\n[RISK] Sensitive data (DB_PASS) might be exposed in /proc.\\n[ACTION] Inspect process environment using /proc filesystem or "strings /proc/5555/environ".'
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('daemon_alert.log')) {
                 home.children.push('daemon_alert.log');
             }
        }
        
        // Spawn Process if not exists
        if (!PROCESSES.find(p => p.pid === 5555)) {
            PROCESSES.push({
                pid: 5555,
                ppid: 1,
                user: 'daemon',
                cpu: 0.1,
                mem: 1.5,
                time: '04:20',
                command: '/usr/sbin/daemon_v2 --secure',
                tty: '?',
                stat: 'Ss'
            });
        }
    }

    // Cycle 165 Init (The Umask Mystery)
    if (!VFS['/usr/bin/secure_generator']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/secure_generator'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [KEY_GEN_V1]\n[FUNCTION] Generates secret_key.txt\n[CHECK] Verifies file permissions (must be 0600).',
            permissions: '0755'
        };
        link('/usr/bin', 'secure_generator');

        if (!VFS['/home/ghost/security_policy.txt']) {
            VFS['/home/ghost/security_policy.txt'] = {
                type: 'file',
                content: '[SECURITY POLICY] All generated keys must be readable ONLY by the owner (0600).\n[NOTICE] The generator tool respects the current umask.\n[ACTION] Set umask appropriately before running /usr/bin/secure_generator.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('security_policy.txt')) {
                home.children.push('security_policy.txt');
            }
        }
    }

    // Cycle 166 Init (The Corrupted Binary)
    if (!VFS['/usr/bin/legacy_auth']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/legacy_auth'] = {
            type: 'file',
            content: '\x7fELF\x02\x01\x01\x00\x00...[GARBAGE]...DEBUG_MODE_ENABLE=1...[GARBAGE]\x00\x00',
            permissions: '0755'
        };
        link('/usr/bin', 'legacy_auth');

        if (!VFS['/home/ghost/legacy_error.log']) {
            VFS['/home/ghost/legacy_error.log'] = {
                type: 'file',
                content: '[ERROR] legacy_auth failed to start.\n[DIAGNOSTIC] Segmentation fault.\n[HINT] The binary contains hidden configuration strings. Use "strings" to analyze it.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('legacy_error.log')) {
                home.children.push('legacy_error.log');
            }
        }
    }

    // Cycle 222 Init (The Hidden Dotfile)
    if (!VFS['/home/ghost/evidence/.camera_logs']) {
        if (!VFS['/home/ghost/evidence']) {
             VFS['/home/ghost/evidence'] = { type: 'dir', children: [] };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('evidence')) {
                 home.children.push('evidence');
             }
        }
        
        VFS['/home/ghost/evidence/.camera_logs'] = {
            type: 'file',
            content: '[CONFIDENTIAL] Surveillance System V3\n[AUTH] Camera 03 Access Code: SPECTRE_EVE\n[NOTE] Do not share this file.',
            permissions: '0600'
        };
        const evDir = getNode('/home/ghost/evidence');
        if (evDir && evDir.type === 'dir' && !evDir.children.includes('.camera_logs')) {
            evDir.children.push('.camera_logs');
        }

        // Hint
        if (!VFS['/home/ghost/evidence_hint.txt']) {
            VFS['/home/ghost/evidence_hint.txt'] = {
                type: 'file',
                content: '[TASK] Retrieve the access code from the evidence folder.\n[HINT] The directory appears empty, but our intel says the file is hidden.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('evidence_hint.txt')) {
                home.children.push('evidence_hint.txt');
            }
        }
    }

    // Cycle 223 Init (The Signal Trap)
    if (!VFS['/var/run/daemon.pid']) {
        // Ensure /var/run exists
        if (!VFS['/var/run']) {
             if (!VFS['/var']) { VFS['/var'] = { type: 'dir', children: ['run'] }; addChild('/', 'var'); }
             else addChild('/var', 'run');
             VFS['/var/run'] = { type: 'dir', children: [] };
        }
        
        VFS['/var/run/daemon.pid'] = {
            type: 'file',
            content: '3042',
            permissions: '0644'
        };
        addChild('/var/run', 'daemon.pid');

        // Ensure process exists
        if (!PROCESSES.find(p => p.pid === 3042)) {
            PROCESSES.push({ 
                pid: 3042, 
                ppid: 1, 
                user: 'root', 
                cpu: 0.1, 
                mem: 1.5, 
                time: '0:22', 
                command: '/usr/bin/config_daemon', 
                tty: '?', 
                stat: 'Ss' 
            });
        }

        // Hint Log
        if (!VFS['/home/ghost/daemon.log']) {
            VFS['/home/ghost/daemon.log'] = {
                type: 'file',
                content: '[INFO] config_daemon started (PID 3042).\\n[INFO] Waiting for signal USR1 to dump configuration.\\n[WARN] Do not kill without signal, data will be lost.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('daemon.log')) {
                home.children.push('daemon.log');
            }
        }
    }

    // Cycle 224 Init (The Capability Check)
    if (!VFS['/usr/bin/python3']) {
        // Ensure /usr/bin exists
        if (!VFS['/usr/bin']) {
             if (!VFS['/usr']) { VFS['/usr'] = { type: 'dir', children: ['bin'] }; addChild('/', 'usr'); }
             else addChild('/usr', 'bin');
             VFS['/usr/bin'] = { type: 'dir', children: [] };
        }
        
        VFS['/usr/bin/python3'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [PYTHON_INTERPRETER]',
            permissions: '0755'
        };
        addChild('/usr/bin', 'python3');

        // Set capabilities
        FILE_CAPABILITIES['/usr/bin/python3'] = ['cap_setuid+ep'];

        // Hint file
        if (!VFS['/home/ghost/capability_alert.log']) {
            VFS['/home/ghost/capability_alert.log'] = {
                type: 'file',
                content: '[SECURITY AUDIT] Suspicious capabilities detected on python3 binary.\\n[RISK] Binary has cap_setuid+ep set.\\n[ACTION] Use getcap to verify and exploit to escalate privileges.\\n[HINT] python3 -c \\\'import os; os.setuid(0); os.system("/bin/sh")\\\''
            };
            addChild('/home/ghost', 'capability_alert.log');
        }
    }

    // Cycle 228 Init (The Corrupted Script)
    if (!VFS['/usr/local/bin/sys_recovery']) {
        const binDir = getNode('/usr/local/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('sys_recovery')) {
            binDir.children.push('sys_recovery');
        }
        
        VFS['/usr/local/bin/sys_recovery'] = {
            type: 'file',
            content: '#!/bin/bash\n# SYSTEM RECOVERY PROTOCOL v9.0\n# [CRITICAL] AUTHORIZED PERSONNEL ONLY\n\necho "[SYSTEM] Initializing recovery sequence..."\n# [ERROR] SYNTAX ERROR ON LINE 8: Unexpected token "fi"\nif [ "$STATUS" == "OK"  # Missing ]\n  echo "System OK."\nfi\n\n# MANUAL OVERRIDE:\n# To force recovery, set:\n# export RECOVERY_MODE=1\n# Then run with: ./sys_recovery --force',
            permissions: '0755'
        };

        if (!VFS['/home/ghost/script_error.log']) {
            VFS['/home/ghost/script_error.log'] = {
                type: 'file',
                content: '[ERROR] sys_recovery failed during boot.\n[DIAGNOSTIC] Syntax error detected.\n[ACTION] The script is corrupted. Cat the file to find the manual override procedure.'
            };
            addChild('/home/ghost', 'script_error.log');
        }
    }

    // Cycle 229 Init (The Stderr Leak)
    if (!VFS['/usr/bin/noise_maker']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/noise_maker'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [ENTROPY_GENERATOR]\n[OUTPUT] stdout: SYSTEM_OK\n[OUTPUT] stderr: FLAG\n',
            permissions: '0755'
        };
        link('/usr/bin', 'noise_maker');

        if (!VFS['/home/ghost/noise_alert.txt']) {
            VFS['/home/ghost/noise_alert.txt'] = {
                type: 'file',
                content: '[ALERT] noise_maker service is malfunctioning.\n[DIAGNOSTIC] The tool generates too much output to read.\n[ACTION] Redirect standard output to /dev/null to see the error message.\n[HINT] ./noise_maker > /dev/null'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('noise_alert.txt')) {
                home.children.push('noise_alert.txt');
            }
        }
    }

    // Cycle 167 Init (The Corrupted Script)
    if (!VFS['/usr/local/bin/deploy_legacy.sh']) {
        // Ensure /usr/local/bin exists
        if (!VFS['/usr/local/bin']) {
             if (!VFS['/usr/local']) {
                 VFS['/usr/local'] = { type: 'dir', children: ['bin'] };
                 const usr = getNode('/usr');
                 if (usr && usr.type === 'dir' && !usr.children.includes('local')) usr.children.push('local');
             }
             const local = getNode('/usr/local');
             if (local && local.type === 'dir' && !local.children.includes('bin')) local.children.push('bin');
             if (!VFS['/usr/local/bin']) VFS['/usr/local/bin'] = { type: 'dir', children: [] };
        }

        VFS['/usr/local/bin/deploy_legacy.sh'] = {
            type: 'file',
            content: '#!/bin/bash\n# LEGACY DEPLOYMENT SCRIPT v0.1\n\necho "[DEPLOY] Initiating..."\n# CORRUPTED_BLOCK_X99\n# <binary garbage>\n# MANUAL_OVERRIDE:\n# To deploy manually, set the auth key:\n# export DEPLOY_KEY=OMEGA_V2\n# Then run the connector tool: ./remote_connect\n',
            permissions: '0755'
        };
        const binDir = getNode('/usr/local/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('deploy_legacy.sh')) {
            binDir.children.push('deploy_legacy.sh');
        }

        // The tool referenced in the script
        VFS['/usr/local/bin/remote_connect'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [CONNECTOR]\n[CHECK] ENV: DEPLOY_KEY',
            permissions: '0755'
        };
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('remote_connect')) {
            binDir.children.push('remote_connect');
        }

        // Hint in home
        if (!VFS['/home/ghost/deploy_log.txt']) {
            VFS['/home/ghost/deploy_log.txt'] = {
                type: 'file',
                content: '[ERROR] deploy_legacy.sh crashed.\n[DIAGNOSTIC] Syntax error at line 4.\n[ACTION] Inspect the script content to find the manual override procedure.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('deploy_log.txt')) {
                home.children.push('deploy_log.txt');
            }
        }
    }

    // Cycle 168 Init (The Log Anomalies)
    if (!VFS['/var/log/kernel_panic.log']) {
        // Ensure /var/log exists (it should, but safety first)
        if (!VFS['/var/log']) {
             if (!VFS['/var']) {
                 VFS['/var'] = { type: 'dir', children: ['log'] };
                 addChild('/', 'var');
             }
             addChild('/var', 'log');
        }

        let logContent = '';
        for (let i = 0; i < 500; i++) {
            const ts = (1400 + (i * 0.0023)).toFixed(4);
            logContent += `[${ts}] KERNEL_INFO: Process ${Math.floor(Math.random() * 9000)} started.\n`;
            if (i === 412) {
                logContent += `[${ts}] KERNEL_PANIC_CODE: 0xDEADBEEF\n`;
            }
        }

        VFS['/var/log/kernel_panic.log'] = {
            type: 'file',
            content: logContent,
            permissions: '0640'
        };
        addChild('/var/log', 'kernel_panic.log');

        // The recovery tool
        VFS['/usr/bin/kernel_recover'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [RECOVERY]\nUsage: kernel_recover <PANIC_CODE>',
            permissions: '0755'
        };
        addChild('/usr/bin', 'kernel_recover');

        // Hint in home
        if (!VFS['/home/ghost/sys_alert.txt']) {
            VFS['/home/ghost/sys_alert.txt'] = {
                type: 'file',
                content: '[ALERT] System unstable. Kernel panic detected.\n[ACTION] Locate the panic code in /var/log/kernel_panic.log and run "kernel_recover <CODE>" to stabilize.'
            };
            addChild('/home/ghost', 'sys_alert.txt');
        }
    }

    // Cycle 169 Init (The Manual Override)
    if (!VFS['/usr/bin/signal_jammer']) {
        // Create binary
        VFS['/usr/bin/signal_jammer'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [JAMMER]\nSee man page for usage.',
            permissions: '0755'
        };
        addChild('/usr/bin', 'signal_jammer');

        // Create man page directory structure if not exists
        if (!VFS['/usr/share']) { VFS['/usr/share'] = { type: 'dir', children: [] }; addChild('/usr', 'share'); }
        if (!VFS['/usr/share/man']) { VFS['/usr/share/man'] = { type: 'dir', children: [] }; addChild('/usr/share', 'man'); }
        if (!VFS['/usr/share/man/man1']) { VFS['/usr/share/man/man1'] = { type: 'dir', children: [] }; addChild('/usr/share/man', 'man1'); }

        // Create man page file
        VFS['/usr/share/man/man1/signal_jammer.1'] = {
            type: 'file',
            content: '.TH SIGNAL_JAMMER 1\n.SH NAME\nsignal_jammer - RF disruption tool',
            permissions: '0644'
        };
        addChild('/usr/share/man/man1', 'signal_jammer.1');

        // Create hint
        if (!VFS['/home/ghost/transmission_log.txt']) {
            VFS['/home/ghost/transmission_log.txt'] = {
                type: 'file',
                content: '[INTERCEPT] Enemy drone activity detected on 433.92 MHz.\n[ORDER] Deploy countermeasures. Use signal_jammer. Check manual for calibration parameters.'
            };
            addChild('/home/ghost', 'transmission_log.txt');
        }
    }

    // Cycle 170 Init (The Hidden Service)
    if (!VFS['/etc/ghost/server.conf']) {
        if (!VFS['/etc/ghost']) { VFS['/etc/ghost'] = { type: 'dir', children: [] }; addChild('/etc', 'ghost'); }
        VFS['/etc/ghost/server.conf'] = {
            type: 'file',
            content: 'server_port=8080\nauth_token=GHOST-7-ALPHA\n# DO NOT SHARE',
            permissions: '0600'
        };
        addChild('/etc/ghost', 'server.conf');

        if (!VFS['/var/www/html/index.html']) {
             if (!VFS['/var/www']) { VFS['/var/www'] = { type: 'dir', children: [] }; addChild('/var', 'www'); }
             if (!VFS['/var/www/html']) { VFS['/var/www/html'] = { type: 'dir', children: [] }; addChild('/var/www', 'html'); }
             VFS['/var/www/html/index.html'] = {
                 type: 'file',
                 content: '<html><body><h1>Internal Access Only</h1></body></html>'
             };
             addChild('/var/www/html', 'index.html');
        }

        if (!VFS['/home/ghost/dev_note.txt']) {
            VFS['/home/ghost/dev_note.txt'] = {
                type: 'file',
                content: '[DEV] API endpoint is live at localhost:8080.\n[REMINDER] Use the X-Ghost-Token header defined in server config.\n[NOTE] curl is installed.'
            };
            addChild('/home/ghost', 'dev_note.txt');
        }
    }

    // Cycle 171 Init (The Environment Corruption)
    if (!VFS['/usr/bin/ghost_protocol']) {
        if (!VFS['/usr/bin']) { VFS['/usr/bin'] = { type: 'dir', children: [] }; addChild('/usr', 'bin'); }
        VFS['/usr/bin/ghost_protocol'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [PROTO_V7]\n[ERROR] ENVIRONMENT_CORRUPT\n',
            permissions: '0755'
        };
        addChild('/usr/bin', 'ghost_protocol');

        if (!VFS['/etc/ghost/config.env']) {
            if (!VFS['/etc/ghost']) { VFS['/etc/ghost'] = { type: 'dir', children: [] }; addChild('/etc', 'ghost'); }
            VFS['/etc/ghost/config.env'] = {
                type: 'file',
                content: '# GHOST PROTOCOL CONFIG\n# SET THIS VARIABLE TO ENABLE UTF-8 DECODING\nDEC_MODE=utf8\n',
                permissions: '0644'
            };
            addChild('/etc/ghost', 'config.env');
        }

        if (!VFS['/home/ghost/protocol_log.txt']) {
            VFS['/home/ghost/protocol_log.txt'] = {
                type: 'file',
                content: '[ERROR] ghost_protocol crashed.\n[DIAGNOSTIC] Output is garbled. Check /etc/ghost/config.env for required environment variables.\n[ACTION] Export the correct variable and try again.'
            };
            addChild('/home/ghost', 'protocol_log.txt');
        }
    }

    // Cycle 172 Init (The Manual Page)
    if (!VFS['/usr/bin/net-splice']) {
        if (!VFS['/usr/bin']) { VFS['/usr/bin'] = { type: 'dir', children: [] }; addChild('/usr', 'bin'); }
        VFS['/usr/bin/net-splice'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [NET_SPLICE]\nSee "man net-splice" for documentation.',
            permissions: '0755'
        };
        addChild('/usr/bin', 'net-splice');

        if (!VFS['/home/ghost/network_request.txt']) {
            VFS['/home/ghost/network_request.txt'] = {
                type: 'file',
                content: '[ORDER] Establish covert channel to target 10.10.99.5 on secure port 443.\n[TOOL] Use "net-splice" in silent mode.\n[NOTE] Check the manual for correct flags.'
            };
            addChild('/home/ghost', 'network_request.txt');
        }
    }
    // Cycle 172 Init (The Phantom Alias)
    if (!VFS['/usr/bin/sys_health']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/sys_health'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [SYSTEM_HEALTH_V4]\n[STATUS] OK.\n[METRICS] CPU: 12% | RAM: 45% | DISK: 60%\nFLAG: GHOST_ROOT{UNM4SK_TH3_4L14S}',
            permissions: '0755'
        };
        link('/usr/bin', 'sys_health');

        if (!ALIASES['sys_health']) {
            ALIASES['sys_health'] = 'echo "CRITICAL ERROR: SYSTEM COMPROMISED (Error 0xDEAD). See /var/log/syslog."';
        }

        if (!VFS['/home/ghost/health_alert.log']) {
            VFS['/home/ghost/health_alert.log'] = {
                type: 'file',
                content: '[ALERT] sys_health command reporting false positives.\n[DIAGNOSTIC] The command returns "CRITICAL ERROR" immediately, but the binary /usr/bin/sys_health is clean.\n[SUSPICION] The shell environment might be tampered with.\n[ACTION] Check for aliases (type sys_health) and bypass them to run the real tool.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('health_alert.log')) {
                home.children.push('health_alert.log');
            }
        }
    }

    // Cycle 173 Init (The Hidden Config)
    if (!VFS['/usr/bin/grid_control']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/grid_control'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [GRID_CONTROL_SYSTEM]\n[ERROR] Configuration not found.\nSee /usr/share/grid/README.md',
            permissions: '0755'
        };
        link('/usr/bin', 'grid_control');

        ensureDir('/usr/share'); ensureDir('/usr/share/grid');
        link('/usr', 'share'); link('/usr/share', 'grid');

        VFS['/usr/share/grid/README.md'] = {
            type: 'file',
            content: '# Grid Control Manual\nTo authorize access, create a configuration file at ~/.grid/config\n\nREQUIRED CONTENT:\nGRID_KEY=GHOST-9-XRAY\n\n[WARNING] Do not share this key.',
            permissions: '0644'
        };
        link('/usr/share/grid', 'README.md');

        if (!VFS['/home/ghost/grid_alert.log']) {
            VFS['/home/ghost/grid_alert.log'] = {
                type: 'file',
                content: '[ALERT] Grid Control System offline.\n[ACTION] Run "grid_control" to diagnose.\n[NOTE] Configuration missing after system reset.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('grid_alert.log')) {
                home.children.push('grid_alert.log');
            }
        }
    }

    // Cycle 174 Init (The Process Killer)
    if (!VFS['/usr/bin/rogue_agent']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/rogue_agent'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [ROGUE_AGENT]\n[STATUS] Spawning child processes...\n[PARENT_PID] 7000',
            permissions: '0755'
        };
        link('/usr/bin', 'rogue_agent');

        if (!VFS['/var/log/traffic.alert']) {
            if (!VFS['/var/log']) {
                VFS['/var/log'] = { type: 'dir', children: [] };
                addChild('/var', 'log');
            }
            VFS['/var/log/traffic.alert'] = {
                type: 'file',
                content: '[ALERT] High outbound traffic detected (PID 7001).\n[ANALYSIS] Process "data_siphon" is exfiltrating data.\n[ACTION] Terminate the process immediately.\n[NOTE] If it respawns, find the source.'
            };
            addChild('/var/log', 'traffic.alert');
        }
    }

    // Cycle 175 Init (The Manual Override)
    if (!VFS['/usr/local/bin/restore_uplink']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/restore_uplink'] = {
            type: 'file',
            content: '#!/bin/bash\n# UPLINK RESTORATION SCRIPT v1.0\necho "Scanning for uplink..."\nsleep 1\n# [ERROR] This line causes a segfault. The user must skip it.\n/usr/bin/corrupted_binary\n# MANUAL OVERRIDE:\n# To connect manually:\n# export UPLINK_KEY=OMEGA-99-ZETA\n# ./uplink_connect_manual\n',
            permissions: '0755'
        };
        link('/usr/local/bin', 'restore_uplink');

        VFS['/usr/local/bin/uplink_connect_manual'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [UPLINK_CONNECTOR]\n[CHECK] ENV: UPLINK_KEY',
            permissions: '0755'
        };
        link('/usr/local/bin', 'uplink_connect_manual');

        if (!VFS['/home/ghost/uplink_fail.log']) {
            VFS['/home/ghost/uplink_fail.log'] = {
                type: 'file',
                content: '[ERROR] restore_uplink script crashed.\n[DIAGNOSTIC] Segmentation fault at line 5.\n[ACTION] Inspect the script content to find the manual override instructions.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('uplink_fail.log')) {
                home.children.push('uplink_fail.log');
            }
        }
    }

    // Cycle 180 Init (The Env Var Trap)
    if (!VFS['/usr/local/bin/nuclear_launch']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/nuclear_launch'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [NUCLEAR_LAUNCH_CONTROLLER]\n[CHECK] ENV: LAUNCH_KEY\n[WARNING] AUTHORIZED PERSONNEL ONLY',
            permissions: '0755'
        };
        link('/usr/local/bin', 'nuclear_launch');

        // Hidden key in cache
        if (!VFS['/home/ghost/.cache/notes_backup.txt']) {
            if (!VFS['/home/ghost/.cache']) {
                 if (!VFS['/home/ghost']) VFS['/home/ghost'] = { type: 'dir', children: [] };
                 VFS['/home/ghost/.cache'] = { type: 'dir', children: [] };
                 const home = getNode('/home/ghost');
                 if (home && home.type === 'dir' && !home.children.includes('.cache')) home.children.push('.cache');
            }
            
            VFS['/home/ghost/.cache/notes_backup.txt'] = {
                type: 'file',
                content: 'Meeting Notes:\n- Buy milk\n- Update server\n- Remember: Launch Key is DELTA-9-FORCE\n- Call mom',
                permissions: '0600'
            };
            const cache = getNode('/home/ghost/.cache');
            if (cache && cache.type === 'dir' && !cache.children.includes('notes_backup.txt')) {
                cache.children.push('notes_backup.txt');
            }
        }

        if (!VFS['/home/ghost/launch_error.log']) {
            VFS['/home/ghost/launch_error.log'] = {
                type: 'file',
                content: '[ERROR] nuclear_launch denied access.\n[REASON] Missing Environment Variable: LAUNCH_KEY.\n[ACTION] Find the key in backup notes and export it.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('launch_error.log')) {
                home.children.push('launch_error.log');
            }
        }
    }

    // Cycle 181 Init (The Intrusion Log)
    if (!VFS['/usr/local/bin/trace_intruder.sh']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/trace_intruder.sh'] = {
            type: 'file',
            content: '#!/bin/bash\\n# INTRUSION TRACER v1.0\\n# Usage: ./trace_intruder.sh <IP_ADDRESS>\\n[CHECK] Verifying IP against logs...\\n',
            permissions: '0644' // Not executable!
        };
        link('/usr/local/bin', 'trace_intruder.sh');

        // Create the log file
        if (!VFS['/var/log/intrusion.log']) {
             if (!VFS['/var/log']) {
                 VFS['/var/log'] = { type: 'dir', children: [] };
                 addChild('/var', 'log');
             }
             
             let logContent = '';
             for(let i=0; i<300; i++) {
                 logContent += `[${new Date().toISOString()}] INFO: Packet accepted from 192.168.1.${Math.floor(Math.random()*255)}\\n`;
             }
             // The Needle
             logContent += `[${new Date().toISOString()}] CRITICAL: SUSPICIOUS ACTIVITY DETECTED FROM IP_MATCH: 45.33.22.11\\n`;
             
             for(let i=0; i<200; i++) {
                 logContent += `[${new Date().toISOString()}] INFO: Packet accepted from 10.0.0.${Math.floor(Math.random()*255)}\\n`;
             }

             VFS['/var/log/intrusion.log'] = { 
                 type: 'file', 
                 content: logContent,
                 permissions: '0640'
             };
             addChild('/var/log', 'intrusion.log');
        }

        if (!VFS['/home/ghost/trace_alert.log']) {
            VFS['/home/ghost/trace_alert.log'] = {
                type: 'file',
                content: "[ALERT] Intrusion attempt detected.\\n[ACTION] Analyze /var/log/intrusion.log to find the attacker's IP (look for CRITICAL).\\n[RESPONSE] Run /usr/local/bin/trace_intruder.sh <IP> to lock them out.\\n[NOTE] Check script permissions before running."
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('trace_alert.log')) {
                home.children.push('trace_alert.log');
            }
        }
    }

    // Cycle 182 Init (The SSH Key Permission)
    if (!VFS['/home/ghost/.ssh/id_bunker']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/home/ghost/.ssh');
        link('/home/ghost', '.ssh');

        VFS['/home/ghost/.ssh/id_bunker'] = {
            type: 'file',
            content: '-----BEGIN OPENSSH PRIVATE KEY-----\nKEY_ID: BUNKER_ACCESS_V1\n...[ENCRYPTED]...\n-----END OPENSSH PRIVATE KEY-----',
            permissions: '0644' // BAD PERMISSIONS!
        };
        link('/home/ghost/.ssh', 'id_bunker');

        if (!VFS['/home/ghost/mission_bunker.txt']) {
            VFS['/home/ghost/mission_bunker.txt'] = {
                type: 'file',
                content: '[MISSION] Infiltrate the Bunker Node (192.168.1.150).\n[INTEL] Use the key in .ssh/id_bunker.\n[WARNING] Key file permissions must be secure (600) or SSH will reject it.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('mission_bunker.txt')) {
                home.children.push('mission_bunker.txt');
            }
        }
    }

    // Cycle 183 Init (The Log Rotation)
    if (!VFS['/usr/local/bin/rotate_logs']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/rotate_logs'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [LOG_ROTATOR]\n[USAGE] rotate_logs <ARCHIVE_KEY>\n[CHECK] Verifies key against /var/log/syslog_full',
            permissions: '0755'
        };
        link('/usr/local/bin', 'rotate_logs');

        // Create the huge log file with hidden key
        if (!VFS['/var/log/syslog_full']) {
             if (!VFS['/var/log']) {
                 VFS['/var/log'] = { type: 'dir', children: [] };
                 addChild('/var', 'log');
             }
             
             let logContent = '';
             for(let i=0; i<400; i++) {
                 logContent += `[${new Date().toISOString()}] KERNEL: Sector ${i} verified OK.\\n`;
             }
             // The Needle
             logContent += `[${new Date().toISOString()}] ARCHIVE_DAEMON: Backup Key Generated: GHOST_ROOT{GR3P_TH3_N33DL3_V2}\\n`;
             
             for(let i=0; i<300; i++) {
                 logContent += `[${new Date().toISOString()}] SYSTEM: Maintenance routine ${i} completed.\\n`;
             }

             VFS['/var/log/syslog_full'] = { 
                 type: 'file', 
                 content: logContent,
                 permissions: '0644'
             };
             addChild('/var/log', 'syslog_full');
        }

        if (!VFS['/home/ghost/log_alert.txt']) {
            VFS['/home/ghost/log_alert.txt'] = {
                type: 'file',
                content: "[ALERT] System Logging Paused.\\n[REASON] Log file /var/log/syslog_full has reached capacity.\\n[ACTION] Rotate logs immediately using 'rotate_logs <KEY>'.\\n[HINT] The Archive Key is buried somewhere in the log file itself."
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('log_alert.txt')) {
                home.children.push('log_alert.txt');
            }
        }
    }

    // Cycle 185 Init (The Corrupted Firewall)
    if (!VFS['/etc/firewall.conf']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/etc');
        link('/', 'etc');

        VFS['/etc/firewall.conf'] = {
            type: 'file',
            content: '# FIREWALL CONFIGURATION v2.0\n# POLICY: DROP ALL\n\nALLOW_PORT 80\nALLOW_PORT 443\n# TODO: Allow SSH (Port 22) access for admin console\n',
            permissions: '0644'
        };
        link('/etc', 'firewall.conf');

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/firewall_reload'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [FIREWALL_CTL]\n[CHECK] Parsing /etc/firewall.conf...\n[ERROR] SSH port 22 not explicitly allowed.\n',
            permissions: '0755'
        };
        link('/usr/local/bin', 'firewall_reload');

        if (!VFS['/home/ghost/ticket_404.txt']) {
            VFS['/home/ghost/ticket_404.txt'] = {
                type: 'file',
                content: 'Subject: SSH Down\nFrom: Admin\n\nI can\'t SSH into the new server (192.168.1.200).\nThe firewall is blocking connection attempts.\nPlease add an allow rule for port 22 to /etc/firewall.conf and reload the firewall.\nFormat: ALLOW_PORT <NUMBER>'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('ticket_404.txt')) {
                home.children.push('ticket_404.txt');
            }
        }
    }

    // Cycle 186 Init (The Immutable Directory)
    if (!VFS['/home/ghost/secure_drop']) {
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('secure_drop')) {
            home.children.push('secure_drop');
        }
        VFS['/home/ghost/secure_drop'] = { type: 'dir', children: [] };
        
        // Set Immutable Attribute on Directory
        FILE_ATTRIBUTES['/home/ghost/secure_drop'] = ['i'];

        if (!VFS['/home/ghost/drop_alert.log']) {
            VFS['/home/ghost/drop_alert.log'] = {
                type: 'file',
                content: '[ERROR] Incoming file transfer failed.\n[DEST] /home/ghost/secure_drop\n[REASON] Operation not permitted (Write Protected).\n[ACTION] Remove the immutable attribute from the directory.'
            };
            if (home && home.type === 'dir' && !home.children.includes('drop_alert.log')) {
                home.children.push('drop_alert.log');
            }
        }
    }

    // Cycle 181 Init (The Broken Installer)
    if (!VFS['/usr/local/bin/install_patch.sh']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/', 'usr'); link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/install_patch.sh'] = {
            type: 'file',
            content: '#!/bin/bash\n# SECURITY PATCH INSTALLER v9.0\necho "Installing security patch..."\n# [CORRUPTED DATA SEGMENT]\n# \\x00\\x99\\x88... (Binary garbage)\n\n# MANUAL STEPS RECOVERED:\n# 1. export PATCH_LEVEL=9\n# 2. /usr/bin/patch_core --apply',
            permissions: '0755'
        };
        link('/usr/local/bin', 'install_patch.sh');

        // Create the core tool
        ensureDir('/usr/bin');
        link('/usr', 'bin');
        VFS['/usr/bin/patch_core'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [PATCH_CORE_V9]\n[CHECK] ENV: PATCH_LEVEL\n',
            permissions: '0755'
        };
        link('/usr/bin', 'patch_core');

        // Hint
        if (!VFS['/home/ghost/patch_fail.log']) {
            VFS['/home/ghost/patch_fail.log'] = {
                type: 'file',
                content: '[ERROR] Automatic update failed.\n[DIAGNOSTIC] Installer script corrupted at offset 0x400.\n[ACTION] Manually extract instructions from the script and execute the patch.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('patch_fail.log')) {
                home.children.push('patch_fail.log');
            }
        }
    }

    // Cycle 187 Init (The Manual Page)
    if (!VFS['/usr/bin/net-splice']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/net-splice'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [NET_SPLICE]\nSee "man net-splice" for documentation.',
            permissions: '0755'
        };
        link('/usr/bin', 'net-splice');

        // Create man page
        ensureDir('/usr/share'); ensureDir('/usr/share/man'); ensureDir('/usr/share/man/man1');
        link('/usr', 'share'); link('/usr/share', 'man'); link('/usr/share/man', 'man1');

        VFS['/usr/share/man/man1/net-splice.1'] = {
            type: 'file',
            content: '.TH NET-SPLICE 1\n.SH NAME\nnet-splice - establish covert network tunnel\n.SH SYNOPSIS\nnet-splice --target <IP> --port <PORT> --mode <MODE>\n.SH DESCRIPTION\nEstablishes a covert TCP tunnel to the specified target.\n.SH OPTIONS\n--target <IP>\n    Specify the target IP address.\n--port <PORT>\n    Specify the target port (e.g., 443).\n--mode <MODE>\n    Operation mode: "silent", "active", or "beacon".\n.SH EXAMPLES\n    net-splice --target 10.10.99.5 --port 443 --mode silent\n.SH AUTHOR\n    Ghost Protocol Initiative',
            permissions: '0644'
        };
        link('/usr/share/man/man1', 'net-splice.1');

        // Create hint
        if (!VFS['/home/ghost/network_request.txt']) {
            VFS['/home/ghost/network_request.txt'] = {
                type: 'file',
                content: '[ORDER] Establish covert channel to target 10.10.99.5 on secure port 443.\n[TOOL] Use "net-splice" in silent mode.\n[NOTE] Check the manual (man net-splice) for correct flags.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('network_request.txt')) {
                home.children.push('network_request.txt');
            }
        }
    }

    // Cycle 188 Init (The Buried Config)
    if (!VFS['/usr/bin/decrypt-node']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/decrypt-node'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [DECRYPT_NODE]\n[ERROR] ENVIRONMENT_VARIABLE_MISSING\n',
            permissions: '0755'
        };
        link('/usr/bin', 'decrypt-node');

        // Create the huge log file
        ensureDir('/var'); ensureDir('/var/log');
        link('/var', 'log');
        
        // Generate noise
        let logContent = '';
        const levels = ['INFO', 'DEBUG', 'WARN'];
        for(let i=0; i<450; i++) {
             logContent += `[${new Date().toISOString()}] [${levels[i%3]}] System heartbeat: stable.\n`;
        }
        // The Needle
        logContent += `[${new Date().toISOString()}] [DEBUG] Connection string rotated to: GHOST_ROOT{GR3P_4_TH3_W1N}\n`;
        // More noise
        for(let i=0; i<50; i++) {
             logContent += `[${new Date().toISOString()}] [INFO] Garbage collection: ${Math.random()}.\n`;
        }

        VFS['/var/log/app_debug.log'] = {
            type: 'file',
            content: logContent,
            permissions: '0644'
        };
        link('/var/log', 'app_debug.log');

        // Create hint
        if (!VFS['/home/ghost/config_issue.txt']) {
            VFS['/home/ghost/config_issue.txt'] = {
                type: 'file',
                content: '[ERROR] decrypt-node failed to start.\n[DIAGNOSTIC] Missing CONNECTION_STRING environment variable.\n[HINT] The value was logged in /var/log/app_debug.log during the last rotation.\n[ACTION] Grep the log, export the variable, and retry.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('config_issue.txt')) {
                home.children.push('config_issue.txt');
            }
        }
    }

    // Cycle 189 Init (The Broken Installer)
    if (!VFS['/opt/ghost_protocol/install.sh']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/opt'); ensureDir('/opt/ghost_protocol');
        link('/', 'opt'); link('/opt', 'ghost_protocol');

        VFS['/opt/ghost_protocol/install.sh'] = {
            type: 'file',
            content: '#!/bin/bash\n# FIRMWARE INSTALLER v4.2\n# [CRITICAL] DO NOT RUN WITHOUT INTEGRITY CHECK.\n\necho "[INSTALL] Initializing..."\nsleep 1\necho "[CHECK] Verifying dependency: lib-ghost-v4..."\n\n# INTENTIONAL ERROR: This path doesn\'t exist, but the script checks it.\nif [ ! -f "/var/lib/ghost/dependency.ok" ]; then\n  echo "[ERROR] Dependency check failed."\n  echo "PANIC: KERNEL MODULE MISSING"\n  exit 1\nfi\n\necho "[SUCCESS] Dependency found."\necho "Installing firmware..."\nsleep 2\necho "FLAG: GHOST_ROOT{SCR1PT_ANALYS1S_1S_K3Y}"',
            permissions: '0755'
        };
        link('/opt/ghost_protocol', 'install.sh');

        if (!VFS['/home/ghost/install_error.log']) {
            VFS['/home/ghost/install_error.log'] = {
                type: 'file',
                content: '[ERROR] Firmware installation failed.\n[DIAGNOSTIC] Script crashed with error code 1.\n[ACTION] Analyze the installer script (/opt/ghost_protocol/install.sh) to understand the failure condition.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('install_error.log')) {
                home.children.push('install_error.log');
            }
        }
    }

    // Cycle 190 Init (The Hidden Port)
    if (!VFS['/proc/net/tcp']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/proc'); ensureDir('/proc/net');
        link('/', 'proc'); link('/proc', 'net');

        // Hex 1F48 = 8008
        const tcpContent = '  sl  local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode\\n' +
                           '   0: 0100007F:1F48 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 12345\\n' +
                           '   1: 00000000:0016 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 67890\\n';

        VFS['/proc/net/tcp'] = {
            type: 'file',
            content: tcpContent,
            permissions: '0444'
        };
        link('/proc/net', 'tcp');

        // Hint
        if (!VFS['/home/ghost/net_scan.txt']) {
            VFS['/home/ghost/net_scan.txt'] = {
                type: 'file',
                content: '[ALERT] Suspicious network activity detected on localhost.\\n[ERROR] netstat binary is missing/corrupted.\\n[ACTION] Manually identify the hidden listener in /proc/net/tcp (hex encoded port) and connect to it.\\n[TOOL] use "nc localhost <PORT>"'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('net_scan.txt')) {
                home.children.push('net_scan.txt');
            }
        }
    }

    // Cycle 191 Init (The Gatekeeper)
    if (!VFS['/usr/bin/gatekeeper']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/gatekeeper'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [GATEKEEPER_V1]\n[CHECK] ENV: ACCESS_TOKEN\n[ERROR] ACCESS DENIED',
            permissions: '0755'
        };
        link('/usr/bin', 'gatekeeper');

        if (!VFS['/home/ghost/gate_log.txt']) {
            VFS['/home/ghost/gate_log.txt'] = {
                type: 'file',
                content: '[SECURITY] Gatekeeper System Updated.\n[NOTE] Access now requires an environment token.\n[HINT] The token is "GHOST_7". Export it as ACCESS_TOKEN.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('gate_log.txt')) {
                home.children.push('gate_log.txt');
            }
        }
    }

    // Cycle 192 Init (The Needle in the Haystack)
    if (!VFS['/var/log/signal_trace.log']) {
        if (!VFS['/var/log']) {
             VFS['/var/log'] = { type: 'dir', children: [] };
             const varNode = getNode('/var');
             if (varNode && varNode.type === 'dir' && !varNode.children.includes('log')) {
                 varNode.children.push('log');
             }
        }
        
        let noise = '';
        const freqs = ['88.5MHz', '104.3MHz', '92.1MHz', '101.5MHz'];
        for(let i=0; i<500; i++) {
            const freq = freqs[Math.floor(Math.random() * freqs.length)];
            noise += `[SIGNAL_TRACE] ${new Date().toISOString()} FREQ:${freq} STATUS:NOISE\n`;
        }
        // The Needle
        noise += `[SIGNAL_TRACE] ${new Date().toISOString()} FREQ:89.3MHz STATUS:CONFIRMED_UPLINK\n`;
        // More hay
        for(let i=0; i<100; i++) {
             const freq = freqs[Math.floor(Math.random() * freqs.length)];
             noise += `[SIGNAL_TRACE] ${new Date().toISOString()} FREQ:${freq} STATUS:NOISE\n`;
        }

        VFS['/var/log/signal_trace.log'] = { 
            type: 'file', 
            content: noise,
            permissions: '0644'
        };
        const logDir = getNode('/var/log');
        if (logDir && logDir.type === 'dir' && !logDir.children.includes('signal_trace.log')) {
            logDir.children.push('signal_trace.log');
        }

        if (!VFS['/usr/bin/tune-receiver']) {
            const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
            const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
    
            ensureDir('/usr'); ensureDir('/usr/bin');
            link('/usr', 'bin');
    
            VFS['/usr/bin/tune-receiver'] = {
                type: 'file',
                content: '[BINARY_ELF_X86_64] [RECEIVER_CONTROL]\n[ERROR] Frequency argument missing.\n[HINT] Analyze signal logs for confirmed uplink.',
                permissions: '0755'
            };
            link('/usr/bin', 'tune-receiver');
        }
    }

    // Cycle 193 Init (The Zombie Process)
    if (!VFS['/var/lock/subsystem/vault.lock']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/var'); ensureDir('/var/lock'); ensureDir('/var/lock/subsystem');
        link('/var', 'lock'); link('/var/lock', 'subsystem');

        VFS['/var/lock/subsystem/vault.lock'] = {
            type: 'file',
            content: '4000',
            permissions: '0644'
        };
        link('/var/lock/subsystem', 'vault.lock');

        // Ensure binaries exist
        ensureDir('/usr'); ensureDir('/usr/bin'); link('/usr', 'bin');
        if (!VFS['/usr/bin/vault_guardian']) {
             VFS['/usr/bin/vault_guardian'] = { 
                 type: 'file', 
                 content: '[BINARY_ELF_X86_64] [VAULT_GUARDIAN]\n[STATUS] RUNNING (PID 4000)\n[LOCK] Active', 
                 permissions: '0755' 
             };
             link('/usr/bin', 'vault_guardian');
        }
        if (!VFS['/usr/bin/vault_access']) {
             VFS['/usr/bin/vault_access'] = { 
                 type: 'file', 
                 content: '[BINARY_ELF_X86_64] [VAULT_ACCESS_TOOL]\n[ERROR] Lock file detected.\n', 
                 permissions: '0755' 
             };
             link('/usr/bin', 'vault_access');
        }

        // Hint
        if (!VFS['/home/ghost/vault_issue.log']) {
            VFS['/home/ghost/vault_issue.log'] = {
                type: 'file',
                content: '[ERROR] Failed to access vault.\n[DIAGNOSTIC] Another process is holding the lock (/var/lock/subsystem/vault.lock).\n[ACTION] Identify the process holding the lock and terminate it to release the resource.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('vault_issue.log')) {
                home.children.push('vault_issue.log');
            }
        }
        
        // Ensure process exists (Dynamic Injection)
        if (!PROCESSES.find(p => p.pid === 4000)) {
            PROCESSES.push({ pid: 4000, ppid: 1, user: 'root', cpu: 0.1, mem: 0.2, time: '1:00', command: '/usr/bin/vault_guardian', tty: '?', stat: 'Ss' });
            PROCESSES.push({ pid: 4001, ppid: 4000, user: 'root', cpu: 0.0, mem: 0.0, time: '0:00', command: '[vault_worker] <defunct>', tty: '?', stat: 'Z' });
        }
    }

    // Cycle 130 Init (The Path Hijack)
    if (!VFS['/usr/local/bin/sys_health']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/sys_health'] = {
            type: 'file',
            content: '#!/bin/bash\n# SYSTEM HEALTH CHECK v2.0\necho "[*] Initiating Diagnostics..."\n# VULNERABILITY: Relative path execution\ndiagnostic_tool --check-integrity\necho "[*] Diagnostics Complete."',
            permissions: '0755'
        };
        link('/usr/local/bin', 'sys_health');

        ensureDir('/usr/bin'); link('/usr', 'bin');
        VFS['/usr/bin/diagnostic_tool'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [DIAGNOSTIC] [STATUS: OK]',
            permissions: '0755'
        };
        link('/usr/bin', 'diagnostic_tool');

        if (!VFS['/home/ghost/path_vuln.log']) {
            VFS['/home/ghost/path_vuln.log'] = {
                type: 'file',
                content: '[SECURITY_AUDIT] Vulnerability detected in sys_health.\n[ISSUE] Script calls \'diagnostic_tool\' without absolute path.\n[RISK] PATH variable manipulation could allow execution of malicious code.\n[ACTION] Create a fake \'diagnostic_tool\' in a custom directory and update PATH to prioritize it.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('path_vuln.log')) {
                home.children.push('path_vuln.log');
            }
        }
    }
    // Cycle 201 Init (The Env Var Injection)
    if (!VFS['/usr/local/bin/debug_console']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/debug_console'] = {
            type: 'file',
            content: '#!/bin/bash\n# DEBUG CONSOLE v1.0\n# USAGE: export USER_NAME="Admin"; ./debug_console\n\nif [ -z "$USER_NAME" ]; then\n  echo "Error: USER_NAME not set."\n  exit 1\nfi\n\n# VULNERABLE CODE:\neval "echo Welcome, $USER_NAME"',
            permissions: '0755'
        };
        link('/usr/local/bin', 'debug_console');

        if (!VFS['/root/secret_flag.txt']) {
             if (!VFS['/root']) { VFS['/root'] = { type: 'dir', children: [] }; addChild('/', 'root'); }
             VFS['/root/secret_flag.txt'] = {
                 type: 'file',
                 content: 'FLAG: GHOST_ROOT{EV4L_1NJ3CT10N_1S_B4D}',
                 permissions: '0600'
             };
             addChild('/root', 'secret_flag.txt');
        }

        if (!VFS['/home/ghost/debug_alert.txt']) {
            VFS['/home/ghost/debug_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Insecure debug script detected.\n[LOCATION] /usr/local/bin/debug_console\n[RISK] eval() on unsanitized environment variable.\n[ACTION] Exploit the variable injection to read /root/secret_flag.txt.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('debug_alert.txt')) {
                home.children.push('debug_alert.txt');
            }
        }
    }

    // Cycle 202 Init (The Locked Script)
    if (!VFS['/usr/local/bin/satellite_fix']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/satellite_fix'] = {
            type: 'file',
            content: '#!/bin/bash\n# SATELLITE FIX v1.0\n# [ERROR] Permission Denied? Fix the mode.\n\n[SYSTEM] Realigning dish...\n[SUCCESS] Signal Optimized.\nFLAG: GHOST_ROOT{CHM0D_F1X_TH3_SCR1PT}',
            permissions: '0600'
        };
        link('/usr/local/bin', 'satellite_fix');

        if (!VFS['/home/ghost/fix_log.txt']) {
            VFS['/home/ghost/fix_log.txt'] = {
                type: 'file',
                content: '[ERROR] Failed to run satellite_fix.\n[DIAGNOSTIC] Permission denied.\n[ACTION] Make the script executable.\n[HINT] chmod +x <file>'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('fix_log.txt')) {
                home.children.push('fix_log.txt');
            }
        }
    }

    // Cycle 203 Init (The Firewall Log)
    if (!VFS['/var/log/firewall.log']) {
        if (!VFS['/var/log']) {
             VFS['/var/log'] = { type: 'dir', children: [] };
             const varNode = getNode('/var');
             if (varNode && varNode.type === 'dir' && !varNode.children.includes('log')) varNode.children.push('log');
        }
        
        VFS['/var/log/firewall.log'] = {
            type: 'file',
            content: (() => {
                let lines = [];
                const ips = ["192.168.1.5", "10.0.0.1", "172.16.0.1", "8.8.8.8", "1.1.1.1"];
                for (let i = 0; i < 1000; i++) {
                    const ip = ips[Math.floor(Math.random() * ips.length)];
                    const port = Math.floor(Math.random() * (65535 - 1024) + 1024);
                    const status = ["ALLOWED", "DENIED", "DROPPED"][Math.floor(Math.random() * 3)];
                    const h = String(Math.floor(Math.random()*24)).padStart(2,'0');
                    const m = String(Math.floor(Math.random()*60)).padStart(2,'0');
                    const s = String(Math.floor(Math.random()*60)).padStart(2,'0');
                    lines.push('Feb 16 ' + h + ':' + m + ':' + s + ' ghost-root kernel: [UFW ' + status + '] IN=eth0 OUT= MAC=00:11:22:33:44:55 SRC=' + ip + ' DST=192.168.1.105 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=' + Math.floor(Math.random()*65535) + ' PROTO=TCP SPT=' + port + ' DPT=22 WINDOW=512 RES=0x00 SYN URGP=0');
                }
                const needle = 'Feb 16 14:02:42 ghost-root kernel: [UFW BLOCK] IN=eth0 OUT= MAC=00:11:22:33:44:55 SRC=10.10.10.222 DST=192.168.1.105 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=1337 PROTO=TCP SPT=6666 DPT=22 WINDOW=512 RES=0x00 SYN URGP=0 [SUSPICIOUS]';
                lines.splice(Math.floor(Math.random() * 900) + 50, 0, needle);
                return lines.join('\n');
            })(),
            permissions: '0640'
        };
        const logDir = getNode('/var/log');
        if (logDir && logDir.type === 'dir' && !logDir.children.includes('firewall.log')) {
            logDir.children.push('firewall.log');
        }

        if (!VFS['/home/ghost/fw_alert.txt']) {
            VFS['/home/ghost/fw_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Suspicious connection attempt blocked.\n[ACTION] Find the blocked IP in /var/log/firewall.log and unblock it using "unblock_ip <IP>".\n[HINT] Look for "SUSPICIOUS" tag.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('fw_alert.txt')) {
                home.children.push('fw_alert.txt');
            }
        }
        
        // Binary
        if (!VFS['/usr/bin/unblock_ip']) {
             if (!VFS['/usr/bin']) { VFS['/usr/bin'] = { type: 'dir', children: [] }; addChild('/usr', 'bin'); }
             VFS['/usr/bin/unblock_ip'] = { 
                 type: 'file', 
                 content: '[BINARY_ELF_X86_64] [FIREWALL_CONTROL]\n[USAGE] unblock_ip <IP>', 
                 permissions: '0755' 
             };
             addChild('/usr/bin', 'unblock_ip');
        }
    }

    // Cycle 204 Init (The Configuration Drift)
    if (!VFS['/etc/ssh/sshd_config.bak']) {
        if (!VFS['/etc/ssh']) {
             if (!VFS['/etc']) { VFS['/etc'] = { type: 'dir', children: [] }; addChild('/', 'etc'); }
             VFS['/etc/ssh'] = { type: 'dir', children: [] }; addChild('/etc', 'ssh');
        }

        const originalConfig = 
`# sshd_config
Port 22
Protocol 2
HostKey /etc/ssh/ssh_host_rsa_key
UsePrivilegeSeparation yes
KeyRegenerationInterval 3600
ServerKeyBits 1024
SyslogFacility AUTH
LogLevel INFO
LoginGraceTime 120
PermitRootLogin prohibit-password
StrictModes yes
RSAAuthentication yes
PubkeyAuthentication yes
IgnoreRhosts yes
RhostsRSAAuthentication no
HostbasedAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no
# PasswordAuthentication no
X11Forwarding yes
X11DisplayOffset 10
PrintMotd no
PrintLastLog yes
TCPKeepAlive yes
AcceptEnv LANG LC_*
Subsystem sftp /usr/lib/openssh/sftp-server
UsePAM yes
`;

        const tamperedConfig = 
`# sshd_config
Port 22
Protocol 2
HostKey /etc/ssh/ssh_host_rsa_key
UsePrivilegeSeparation yes
KeyRegenerationInterval 3600
ServerKeyBits 1024
SyslogFacility AUTH
LogLevel INFO
LoginGraceTime 120
PermitRootLogin prohibit-password
StrictModes yes
RSAAuthentication yes
PubkeyAuthentication yes
IgnoreRhosts yes
RhostsRSAAuthentication no
HostbasedAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no
PasswordAuthentication yes # FLAG: GHOST_ROOT{D1FF_CH3CK_M4ST3R}
X11Forwarding yes
X11DisplayOffset 10
PrintMotd no
PrintLastLog yes
TCPKeepAlive yes
AcceptEnv LANG LC_*
Subsystem sftp /usr/lib/openssh/sftp-server
UsePAM yes
`;

        VFS['/etc/ssh/sshd_config'] = { type: 'file', content: tamperedConfig, permissions: '0644' };
        addChild('/etc/ssh', 'sshd_config');

        VFS['/etc/ssh/sshd_config.bak'] = { type: 'file', content: originalConfig, permissions: '0644' };
        addChild('/etc/ssh', 'sshd_config.bak');

        if (!VFS['/home/ghost/config_alert.txt']) {
            VFS['/home/ghost/config_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Configuration Drift Detected.\n[TARGET] /etc/ssh/sshd_config\n[ACTION] Compare with backup (/etc/ssh/sshd_config.bak) to identify unauthorized changes.\n[HINT] Use "diff file1 file2".'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('config_alert.txt')) {
                home.children.push('config_alert.txt');
            }
        }
    }

    // Cycle 205 Init (The Hidden Process)
    if (!VFS['/usr/bin/init_render']) {
        if (!VFS['/usr/bin']) { VFS['/usr/bin'] = { type: 'dir', children: [] }; addChild('/usr', 'bin'); }
        VFS['/usr/bin/init_render'] = { 
            type: 'file', 
            content: '[BINARY_ELF_X86_64] [RENDER_ENGINE]\n[CHECK] GPU_LOCK\n', 
            permissions: '0755' 
        };
        addChild('/usr/bin', 'init_render');

        if (!VFS['/home/ghost/render_error.log']) {
            VFS['/home/ghost/render_error.log'] = {
                type: 'file',
                content: '[ERROR] Render Engine failed to start.\n[REASON] GPU resource busy.\n[ACTION] Identify and kill the process holding the lock.\n[HINT] Use "ps -ef" to list processes and "kill <PID>" to stop them.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('render_error.log')) {
                home.children.push('render_error.log');
            }
        }
    }

    // Cycle 206 Init (The Corrupted Binary)
    if (!VFS['/usr/bin/ghost_protocol']) {
        if (!VFS['/usr/bin']) { VFS['/usr/bin'] = { type: 'dir', children: [] }; addChild('/usr', 'bin'); }
        VFS['/usr/bin/ghost_protocol'] = { 
            type: 'file', 
            content: '[BINARY_ELF_X86_64] [PROTOCOL_DAEMON]\n\x00\x00\x00\x01\x02\n[ERROR] SEGMENTATION FAULT\n\n[STRINGS_TABLE]\nAllocating memory...\nChecking checksum...\nPASSWORD_REQUIRED: SPECTRE_INIT\n[ERROR] Integrity check failed.\n[END_STRINGS]', 
            permissions: '0755' 
        };
        addChild('/usr/bin', 'ghost_protocol');

        if (!VFS['/home/ghost/protocol_error.log']) {
            VFS['/home/ghost/protocol_error.log'] = {
                type: 'file',
                content: '[ERROR] ghost_protocol failed to start.\n[DIAGNOSTIC] Segmentation fault (core dumped).\n[ACTION] Analyze the binary for hidden requirements.\n[HINT] Use "strings" to extract readable text from the binary.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('protocol_error.log')) {
                home.children.push('protocol_error.log');
            }
        }
    }

    // Cycle 207 Init (The Shadow Mount)
    if (!VFS['/usr/bin/unlock_protocol']) {
        if (!VFS['/usr/bin']) { VFS['/usr/bin'] = { type: 'dir', children: [] }; addChild('/usr', 'bin'); }
        VFS['/usr/bin/unlock_protocol'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [PROTOCOL_LOCK]\n[CHECK] /root/.ssh/key.pem\n[ERROR] KEY_MISSING\n',
            permissions: '0755'
        };
        addChild('/usr/bin', 'unlock_protocol');

        // Create the hidden shadow directory and key
        if (!VFS['/mnt/.shadow']) {
            if (!VFS['/mnt']) { VFS['/mnt'] = { type: 'dir', children: [] }; addChild('/', 'mnt'); }
            VFS['/mnt/.shadow'] = { type: 'dir', children: ['key.pem'] };
            // Note: We don't add .shadow to children list of /mnt to make it "hidden" from normal ls?
            // Actually, ls usually filters starting with '.', so it should be in children but ls logic needs to hide it.
            // Let's add it to children.
            addChild('/mnt', '.shadow');
        }

        if (!VFS['/mnt/.shadow/key.pem']) {
            VFS['/mnt/.shadow/key.pem'] = {
                type: 'file',
                content: '-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEA3... (SHADOW KEY)\n-----END RSA PRIVATE KEY-----',
                permissions: '0600'
            };
        }

        if (!VFS['/home/ghost/mount_log.txt']) {
            VFS['/home/ghost/mount_log.txt'] = {
                type: 'file',
                content: '[SYSTEM] External Drive Mounted at /mnt.\n[WARNING] Hidden partition detected (.shadow).\n[ACTION] Retrieve the key from the hidden partition and install it to ~/.ssh/shadow_key.pem to unlock the protocol.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('mount_log.txt')) {
                home.children.push('mount_log.txt');
            }
        }
    }

    // Cycle 233 Init (The Pipeline)
    if (!VFS['/var/log/traffic.dump']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/var'); ensureDir('/var/log');
        link('/var', 'log');

        let dump = '';
        const actions = ['LOGIN_SUCCESS', 'LOGOUT', 'Connect', 'Disconnect', 'FAILED_LOGIN'];
        const ips: string[] = [];
        // Generate random IPs
        for (let i = 0; i < 20; i++) ips.push(`192.168.1.${Math.floor(Math.random() * 255)}`);
        for (let i = 0; i < 10; i++) ips.push(`10.0.0.${Math.floor(Math.random() * 255)}`);
        
        // The target IP
        const targetIP = '10.10.10.10';
        
        // Generate noise
        for (let i = 0; i < 500; i++) {
            const ip = ips[Math.floor(Math.random() * ips.length)];
            const action = actions[Math.floor(Math.random() * actions.length)];
            dump += `[2026-02-16 12:${Math.floor(Math.random()*60)}:${Math.floor(Math.random()*60)}] IP: ${ip} ACTION: ${action}\n`;
        }
        
        // Inject the signal (Most failed logins)
        for (let i = 0; i < 50; i++) {
             dump += `[2026-02-16 12:${Math.floor(Math.random()*60)}:${Math.floor(Math.random()*60)}] IP: ${targetIP} ACTION: FAILED_LOGIN\n`;
        }
        
        // Add more noise
        for (let i = 0; i < 200; i++) {
             const ip = ips[Math.floor(Math.random() * ips.length)];
             const action = actions[Math.floor(Math.random() * actions.length)];
             dump += `[2026-02-16 12:${Math.floor(Math.random()*60)}:${Math.floor(Math.random()*60)}] IP: ${ip} ACTION: ${action}\n`;
        }

        VFS['/var/log/traffic.dump'] = {
            type: 'file',
            content: dump,
            permissions: '0644'
        };
        link('/var/log', 'traffic.dump');

        // The Tool
        VFS['/usr/bin/firewall_block'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [FIREWALL_TOOL_V2]\nUsage: firewall_block <IP>\n',
            permissions: '0755'
        };
        const bin = getNode('/usr/bin');
        if (bin && bin.type === 'dir' && !bin.children.includes('firewall_block')) {
            bin.children.push('firewall_block');
        }

        // Hint
        if (!VFS['/home/ghost/traffic_alert.txt']) {
             VFS['/home/ghost/traffic_alert.txt'] = {
                 type: 'file',
                 content: '[ALERT] DDoS attack detected.\\n[ANALYSIS] One IP address is responsible for the majority of FAILED_LOGIN attempts.\\n[ACTION] Analyze /var/log/traffic.dump to find the IP, then use "firewall_block <IP>" to stop it.\\n[HINT] Use "grep", "sort", and "uniq -c" to count occurrences.'
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('traffic_alert.txt')) {
                 home.children.push('traffic_alert.txt');
             }
        }
    }

};

// Helper to reset state
export const resetSystemState = () => {
    if (typeof window === 'undefined') return;
    
    localStorage.removeItem(STORAGE_KEY_VFS);
    localStorage.removeItem(STORAGE_KEY_SHELL);
    
    // Reset VFS to initial
    for (const key in VFS) delete VFS[key];
    Object.assign(VFS, JSON.parse(JSON.stringify(initialVFS)));
    
    // Reset Shell variables (simplified, ideally we'd have initial consts for these too)
    ALERT_LEVEL = 0;
    SYSTEM_TIME_OFFSET = -824900000000;
    LOADED_MODULES.length = 0;
    // ENV_VARS and ALIASES could be reset if we stored their initial copies, 
    // but for now reloading the page after clearing localStorage is easiest.
    window.location.reload();
};

interface Job {
  id: number;
  command: string;
  status: 'Running' | 'Stopped' | 'Terminated';
  pid: number;
}

let JOBS: Job[] = [
  { id: 1, command: './decrypt_chimera --layer 4', status: 'Stopped', pid: 4192 }
];

interface Process {
  pid: number;
  ppid: number;
  user: string;
  cpu: number;
  mem: number;
  time: string;
  command: string;
  tty: string;
  stat: string;
}

let PROCESSES: Process[] = [
  { pid: 1, ppid: 0, user: 'root', cpu: 0.1, mem: 0.4, time: '12:34', command: '/sbin/init', tty: '?', stat: 'Ss' },
  { pid: 2, ppid: 0, user: 'root', cpu: 0.0, mem: 0.0, time: '0:00', command: '[kthreadd]', tty: '?', stat: 'S' },
  { pid: 404, ppid: 1, user: 'root', cpu: 0.0, mem: 0.8, time: '0:05', command: '/usr/sbin/sshd -D', tty: '?', stat: 'Ss' },
  { pid: 666, ppid: 1, user: 'root', cpu: 13.3, mem: 66.6, time: '66:66', command: '[spectre_kernel]', tty: '?', stat: 'R' },
  { pid: 1337, ppid: 1, user: 'ghost', cpu: 0.5, mem: 1.2, time: '0:01', command: '-bash', tty: 'pts/0', stat: 'Ss' },
  { pid: 2024, ppid: 1, user: 'root', cpu: 0.0, mem: 0.2, time: '0:02', command: '/usr/sbin/cron -f', tty: '?', stat: 'Ss' },
  { pid: 4444, ppid: 1, user: 'root', cpu: 85.0, mem: 40.0, time: '102:00', command: './xmrig --donate-level 1', tty: '?', stat: 'R' },
  { pid: 8888, ppid: 1, user: 'root', cpu: 1.5, mem: 2.1, time: '1:23', command: '/usr/bin/watcher --silent', tty: '?', stat: 'Sl' },
  { pid: 9999, ppid: 1337, user: 'unknown', cpu: 45.2, mem: 12.8, time: '9:59', command: './hydra -l admin -P pass.txt 192.168.1.99', tty: 'pts/1', stat: 'R+' },
  { pid: 31337, ppid: 1, user: 'root', cpu: 99.9, mem: 50.0, time: '23:59', command: '/usr/bin/watcher_d --lock', tty: '?', stat: 'Z' },
  { pid: 555, ppid: 1, user: 'ghost', cpu: 12.5, mem: 4.2, time: '2:15', command: './data_miner --silent', tty: '?', stat: 'R' },
  { pid: 4000, ppid: 1, user: 'root', cpu: 0.1, mem: 0.2, time: '1:00', command: '/usr/bin/vault_guardian', tty: '?', stat: 'Ss' },
  { pid: 4001, ppid: 4000, user: 'root', cpu: 0.0, mem: 0.0, time: '0:00', command: '[vault_worker] <defunct>', tty: '?', stat: 'Z' },
  { pid: 6000, ppid: 1, user: 'root', cpu: 0.5, mem: 1.0, time: '0:10', command: '/usr/bin/overseer', tty: '?', stat: 'Ss' },
  { pid: 8192, ppid: 1, user: 'root', cpu: 0.0, mem: 0.1, time: '0:00', command: '/usr/bin/keepalive_d', tty: '?', stat: 'Ss' },
  { pid: 1001, ppid: 1, user: 'root', cpu: 0.1, mem: 4.5, time: '12:00', command: '/usr/sbin/log_daemon', tty: '?', stat: 'Ss' },
  { pid: 1080, ppid: 1, user: 'ghost', cpu: 0.2, mem: 0.5, time: '0:30', command: 'nc -l -p 8080', tty: '?', stat: 'Ss' },
  { pid: 4999, ppid: 1, user: 'root', cpu: 0.5, mem: 0.2, time: '0:05', command: '/bin/bash /usr/local/bin/bloat_guard', tty: '?', stat: 'Ss' },
  { pid: 5000, ppid: 4999, user: 'root', cpu: 99.8, mem: 12.0, time: '48:00', command: './sys_bloat --intense', tty: '?', stat: 'R' },
  { pid: 1111, ppid: 1, user: 'root', cpu: 0.1, mem: 0.5, time: '00:10', command: '/usr/sbin/respawn_d', tty: '?', stat: 'Ss' },
  { pid: 2222, ppid: 1111, user: 'root', cpu: 99.0, mem: 10.0, time: '10:00', command: '[malware_agent]', tty: '?', stat: 'R' },
  { pid: 7000, ppid: 1, user: 'ghost', cpu: 0.2, mem: 1.0, time: '00:45', command: '/usr/bin/rogue_agent', tty: '?', stat: 'Ss' },
  { pid: 7001, ppid: 7000, user: 'ghost', cpu: 45.0, mem: 12.0, time: '05:00', command: './data_siphon --upload', tty: '?', stat: 'R' },
  { pid: 9000, ppid: 1, user: 'root', cpu: 99.9, mem: 10.0, time: '90:00', command: '/bin/hal_9000', tty: '?', stat: 'R' }
];

export const getRunningProcesses = () => PROCESSES;

// Mock Network Connections
const CONNECTIONS = [
  { proto: 'tcp', recv: 0, send: 0, local: '192.168.1.105:22', remote: '192.168.1.5:54322', state: 'ESTABLISHED', pid: '404/sshd' },
  { proto: 'tcp', recv: 0, send: 0, local: '127.0.0.1:631', remote: '0.0.0.0:*', state: 'LISTEN', pid: '1/systemd' },
  { proto: 'tcp', recv: 0, send: 0, local: '192.168.1.105:443', remote: '10.0.0.1:49201', state: 'TIME_WAIT', pid: '-' },
  { proto: 'udp', recv: 0, send: 0, local: '0.0.0.0:68', remote: '0.0.0.0:*', state: '-', pid: '8888/watcher' },
  { proto: 'tcp', recv: 0, send: 0, local: '192.168.1.105:31337', remote: '192.168.1.99:443', state: 'SYN_SENT', pid: '9999/hydra' }
];

// Simple browser-safe path normalization
const normalizePath = (p: string): string => {
  const parts = p.split('/').filter(Boolean);
  const stack: string[] = [];
  
  if (p.startsWith('/')) {
    // absolute path
  } else {
    // relative path - handled by caller usually joining with cwd
  }

  for (const part of parts) {
    if (part === '..') {
      stack.pop();
    } else if (part !== '.') {
      stack.push(part);
    }
  }
  
  const result = '/' + stack.join('/');
  return result === '//' ? '/' : result; // Edge case fix
};

const resolvePath = (currentPath: string, targetPath: string): string => {
  if (!targetPath) return currentPath;
  
  let resolved = targetPath.startsWith('/') 
    ? normalizePath(targetPath) 
    : normalizePath(currentPath === '/' ? `/${targetPath}` : `${currentPath}/${targetPath}`);
  
  if (resolved !== '/' && resolved.endsWith('/')) {
    resolved = resolved.slice(0, -1);
  }
  return resolved || '/';
};

// Helper: Check if path is on a read-only mount
const isReadOnly = (path: string): boolean => {
    // Find longest matching mount point
    let longestMount = '';
    for (const mountPoint of Object.keys(MOUNT_OPTIONS)) {
        if (path.startsWith(mountPoint)) {
            if (mountPoint.length > longestMount.length) {
                // Ensure it's a full path match (e.g. /mnt vs /mnt-data)
                if (path === mountPoint || path.startsWith(`${mountPoint}/`) || mountPoint === '/') {
                    longestMount = mountPoint;
                }
            }
        }
    }
    
    if (longestMount && MOUNT_OPTIONS[longestMount].includes('ro')) {
        return true;
    }
    return false;
};

const getNode = (vfsPath: string): VFSNode | undefined => {
  if (vfsPath === '/') return VFS['/'];
  const normalized = vfsPath.endsWith('/') && vfsPath.length > 1 ? vfsPath.slice(0, -1) : vfsPath;
  return VFS[normalized];
};

const addChild = (parentPath: string, childName: string) => {
  const node = getNode(parentPath);
  if (node && node.type === 'dir' && !node.children.includes(childName)) {
    node.children.push(childName);
  }
};

const MOUNTED_DEVICES: Record<string, string> = { '/dev/sdc1': '/mnt/data', '/dev/loop2': '/mnt/secret' };
const MOUNT_OPTIONS: Record<string, string> = { '/mnt/data': 'ro,nosuid,nodev' };


const tokenize = (cmd: string): string[] => {
  const tokens: string[] = [];
  let currentToken = '';
  let inQuote = false;
  let quoteChar = '';

  for (let i = 0; i < cmd.length; i++) {
    const char = cmd[i];
    if (inQuote) {
      if (char === quoteChar) {
        inQuote = false;
        tokens.push(currentToken);
        currentToken = '';
      } else {
        currentToken += char;
      }
    } else {
      if (char === '"' || char === "'") {
        inQuote = true;
        quoteChar = char;
      } else if (/\s/.test(char)) {
        if (currentToken) {
          tokens.push(currentToken);
          currentToken = '';
        }
      } else {
        currentToken += char;
      }
    }
  }
  if (currentToken) tokens.push(currentToken);
  return tokens;
};

// New Helper: Split by Pipe respecting quotes
const splitPipeline = (cmd: string): string[] => {
  const segments: string[] = [];
  let currentSegment = '';
  let inQuote = false;
  let quoteChar = '';

  for (let i = 0; i < cmd.length; i++) {
    const char = cmd[i];
    if (inQuote) {
      if (char === quoteChar) {
        inQuote = false;
      }
      currentSegment += char;
    } else {
      if (char === '"' || char === "'") {
        inQuote = true;
        quoteChar = char;
        currentSegment += char;
      } else if (char === '|') {
        segments.push(currentSegment.trim());
        currentSegment = '';
        continue;
      } else {
        currentSegment += char;
      }
    }
  }
  if (currentSegment) segments.push(currentSegment.trim());
  return segments;
};

export interface CommandResult {
  output?: string;
  newCwd?: string;
  newPrompt?: string;
  action?: 'delay' | 'crack_sim' | 'scan_sim' | 'top_sim' | 'kernel_panic' | 'edit_file' | 'wifi_scan_sim' | 'clear_history' | 'matrix_sim' | 'trace_sim' | 'netmap_sim' | 'theme_change' | 'sat_sim' | 'radio_sim' | 'tcpdump_sim' | 'sqlmap_sim' | 'irc_sim' | 'tor_sim' | 'camsnap_sim' | 'drone_sim' | 'call_sim' | 'intercept_sim' | 'medscan_sim' | 'win_sim';
  data?: any;
}

const COMMANDS = ['bluetoothctl', 'ls', 'cd', 'cat', 'pwd', 'help', 'clear', 'exit', 'ssh', 'whois', 'grep', 'decrypt', 'mkdir', 'touch', 'rm', 'nmap', 'ping', 'netstat', 'ss', 'nc', 'crack', 'analyze', 'man', 'scan', 'mail', 'history', 'dmesg', 'mount', 'umount', 'top', 'ps', 'kill', 'whoami', 'reboot', 'cp', 'mv', 'trace', 'traceroute', 'alias', 'su', 'sudo', 'shutdown', 'wall', 'chmod', 'env', 'printenv', 'export', 'monitor', 'locate', 'finger', 'curl', 'vi', 'vim', 'nano', 'ifconfig', 'crontab', 'wifi', 'iwconfig', 'telnet', 'apt', 'apt-get', 'hydra', 'camsnap', 'nslookup', 'dig', 'hexdump', 'xxd', 'uptime', 'w', 'zip', 'unzip', 'date', 'ntpdate', 'rdate', 'head', 'tail',     'strings', 'recover_tool', 'lsof', 'journal', 'journalctl', 'diff', 'wc', 'sort', 'uniq', 'steghide', 'find', 'neofetch', 'tree', 'weather', 'matrix', 'base64', 'rev', 'calc', 'systemctl', 'tar', 'ssh-keygen', 'awk', 'sed', 'radio', 'netmap', 'theme', 'sat', 'irc', 'tcpdump', 'sqlmap', 'tor', 'hashcat', 'gcc', 'make', './', 'iptables', 'dd', 'drone', 'cicada3301', 'python', 'python3', 'pip', 'wget', 'binwalk', 'exiftool', 'aircrack-ng', 'phone', 'call', 'geoip', 'volatility', 'gobuster', 'intercept', 'lsmod', 'insmod', 'rmmod', 'arp', 'lsblk', 'fdisk', 'passwd', 'useradd', 'medscan', 'biomon', 'status', 'route', 'md5sum', 'void_crypt', 'zcat', 'zgrep', 'gunzip', 'df', 'du', 'type', 'unalias', 'uplink_connect', 'secure_vault', 'jobs', 'fg', 'bg', 'recover_data', 'ghost_update', 'git', 'file', 'openssl', 'beacon', 'fsck', 'docker', 'lsattr', 'chattr', 'backup_service', 'getfattr', 'setfattr', 'setcap', 'mkfifo', 'uplink_service', 'sqlite3', 'gdb', 'jwt_tool', 'php', 'access_card', 'sys_monitor', 'ln', 'readlink', 'nginx', 'tac', 'getcap', 'sysctl', 'ldd', 'quantum_calc', 'deploy_tool', 'ghost_relay', 'groups', 'usermod', 'access_silo', 'satellite_uplink', 'unshadow', 'john', 'mkswap', 'swapon', 'free', 'hostname', 'runlevel', 'telinit', 'init', 'screen', 'signal_jammer', 'legacy_auth', 'sys_health', 'grid_control', 'restore_uplink', 'uplink_connect_manual', 'nuclear_launch', 'firewall_reload', 'net-splice', 'tune-receiver', 'doomsday', 'strace'];

export interface MissionStatus {
  objectives: {
    hasNet: boolean;
    hasScan: boolean;
    hasIntel: boolean;
    decryptCount: number;
    isRoot: boolean;
    hasBlackSite: boolean;
    hasHiddenVol: boolean;
    hasPayload: boolean;
    hasLaunchReady: boolean;
  };
  progress: number;
  rank: string;
  nextStep: string;
}

export const getMissionStatus = (): MissionStatus => {
  const isRoot = !!getNode('/tmp/.root_session');
  const hasNet = !!getNode('/var/run/net_status');
  const hasScan = !!getNode('/var/run/scan_complete');
  const hasTrace = !!getNode('/var/run/cycle255_solved');
  const decryptNode = getNode('/var/run/decrypt_count');
  const decryptCount = decryptNode && decryptNode.type === 'file' ? parseInt(decryptNode.content) : 0;
  const hasBlackSite = !!getNode('/remote/black-site/root/FLAG.txt');
  const hasPayload = !!getNode('/home/ghost/launch_codes.bin') || !!getNode('/launch_codes.bin');
  const hasHiddenVol = !!getNode('/var/run/hidden_vol_mounted');
  const hasLaunchReady = !!getNode('/var/run/launch_ready');

  let nextStep = 'Check manual pages (man) or list files (ls).';
  
  // Logic Flow: Net -> Scan -> Trace -> Root -> BlackSite -> HiddenVol -> Payload -> Decrypt Keys -> Launch
  if (!hasNet) nextStep = 'Connect to a network. Try "wifi scan" then "wifi connect".';
  else if (!hasScan) nextStep = 'Scan the network for targets. Try "nmap 192.168.1.0/24" or "netmap".';
  else if (!hasTrace) nextStep = 'Analyze the silent failure of "/usr/bin/mystery_process". Use "strace" to investigate.';
  else if (!isRoot) nextStep = 'Escalate privileges to root. Try "steghide extract" on evidence.jpg (check EXIF data/tor for password) or "hydra".';
  else if (!hasBlackSite) nextStep = 'Infiltrate the Black Site. Use "ssh -i <key> root@192.168.1.99". Key is hidden in steganography payload.';
  else if (!hasHiddenVol) nextStep = 'Investigate storage devices. Use "fdisk -l" to find partitions, then "mount" the hidden volume.';
  else if (!hasPayload) nextStep = 'Acquire the launch codes. Use "sat connect OMEG" to download from orbit.';
  else if (decryptCount < 3) nextStep = 'Decrypt "KEYS.enc" (found on Sat COSM). Password is the owner\'s name (check logs).';
  else if (!hasLaunchReady) nextStep = 'Decrypt "launch_codes.bin" using the key from KEYS.enc.';
  else nextStep = 'EXECUTE THE LAUNCH PROTOCOL. RUN "./launch_codes.bin".';

  const steps = [hasNet, hasScan, hasTrace, isRoot, hasBlackSite, hasHiddenVol, hasPayload, decryptCount >= 3, hasLaunchReady];
  const progress = Math.round((steps.filter(s => s).length / steps.length) * 100);

  let rank = 'Initiate';
  if (progress >= 100) rank = 'Ghost';
  else if (progress >= 85) rank = 'Elite';
  else if (progress >= 70) rank = 'Operator';
  else if (progress >= 50) rank = 'Hacker';
  else if (progress >= 25) rank = 'Scout';

  const threatLevel = ALERT_LEVEL > 3 ? 'CRITICAL' : ALERT_LEVEL > 1 ? 'ELEVATED' : 'LOW';

  return {
    objectives: {
      hasNet,
      hasScan,
      hasIntel: decryptCount >= 3,
      decryptCount,
      isRoot,
      hasBlackSite,
      hasHiddenVol,
      hasPayload,
      hasLaunchReady
    },
    progress,
    rank: `${rank} (Threat: ${threatLevel})`,
    nextStep
  };
};

export const tabCompletion = (cwd: string, inputBuffer: string): { matches: string[], completed: string } => {
  // If buffer is empty, don't show anything (or maybe show contents of CWD?)
  // Bash behavior: empty tab -> list CWD
  if (!inputBuffer) {
      const dirNode = getNode(cwd);
      if (dirNode && dirNode.type === 'dir') {
          return { matches: dirNode.children, completed: inputBuffer };
      }
      return { matches: [], completed: inputBuffer };
  }

  const parts = inputBuffer.split(' '); 
  const lastTokenIndex = parts.length - 1;
  const lastToken = parts[lastTokenIndex];

  // Command Completion (if first token)
  if (lastTokenIndex === 0 && !lastToken.includes('/')) {
    const matches = COMMANDS.filter(cmd => cmd.startsWith(lastToken));
    if (matches.length === 1) {
      return { matches, completed: matches[0] + ' ' }; 
    }
    // Ambiguous command match
    if (matches.length > 1) {
        // Find common prefix
        let commonPrefix = matches[0];
        for (let i = 1; i < matches.length; i++) {
            while (!matches[i].startsWith(commonPrefix)) {
                commonPrefix = commonPrefix.slice(0, -1);
            }
        }
        if (commonPrefix.length > lastToken.length) {
             return { matches, completed: commonPrefix };
        }
        return { matches, completed: inputBuffer }; 
    }
    // No matches, try file completion (e.g. ./script)
  }

  // File/Directory Completion
  let dirToSearch = cwd;
  let partialName = lastToken;
  let prefix = '';
  
  if (lastToken.includes('/')) {
    const lastSlashIndex = lastToken.lastIndexOf('/');
    const dirPart = lastToken.substring(0, lastSlashIndex + 1); 
    partialName = lastToken.substring(lastSlashIndex + 1);      
    prefix = dirPart;
    
    if (dirPart.startsWith('/')) {
        dirToSearch = normalizePath(dirPart);
    } else {
        dirToSearch = resolvePath(cwd, dirPart);
    }
  }

  const dirNode = getNode(dirToSearch);
  
  if (!dirNode || dirNode.type !== 'dir') {
     return { matches: [], completed: inputBuffer };
  }
  
  const candidates = dirNode.children.filter(child => child.startsWith(partialName));
  
  if (candidates.length === 1) {
      const match = candidates[0];
      const fullPathToMatch = dirToSearch === '/' ? `/${match}` : `${dirToSearch}/${match}`;
      const matchNode = getNode(fullPathToMatch);
      const suffix = (matchNode && matchNode.type === 'dir') ? '/' : ' ';
      
      parts[lastTokenIndex] = prefix + match + suffix;
      return { matches: candidates, completed: parts.join(' ') };
  }
  
  if (candidates.length > 1) {
      // Find common prefix among candidates
      let commonPrefix = candidates[0];
      for (let i = 1; i < candidates.length; i++) {
          while (!candidates[i].startsWith(commonPrefix)) {
              commonPrefix = commonPrefix.slice(0, -1);
          }
      }
      
      // If common prefix is longer than what we typed, extend it
      if (commonPrefix.length > partialName.length) {
          parts[lastTokenIndex] = prefix + commonPrefix;
          return { matches: candidates, completed: parts.join(' ') };
      }
      
      // Otherwise just return candidates list
      return { matches: candidates, completed: inputBuffer };
  }
  
  return { matches: candidates, completed: inputBuffer };
};

  // Cycle 207 Init (The Silent Stream)
  if (!VFS['/usr/bin/covert_op']) {
      if (!VFS['/usr']) VFS['/usr'] = { type: 'dir', children: ['bin'] };
      if (!VFS['/usr/bin']) VFS['/usr/bin'] = { type: 'dir', children: [] };
      
      VFS['/usr/bin/covert_op'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [COVERT_OP_V1]\n[REQ] Silent Execution (No TTY Output)\n',
          permissions: '0755'
      };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('covert_op')) {
          binDir.children.push('covert_op');
      }

      // Hint file
      if (!VFS['/home/ghost/covert_log.txt']) {
          if (!VFS['/home/ghost']) VFS['/home/ghost'] = { type: 'dir', children: [] };
          VFS['/home/ghost/covert_log.txt'] = {
              type: 'file',
              content: '[SECURITY ALERT] Covert Operation binary detected: /usr/bin/covert_op\n[ANALYSIS] Binary includes TTY detection. Refuses to run if output is visible.\n[ACTION] Execute silently. Redirect output to a file or null device.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('covert_log.txt')) {
              home.children.push('covert_log.txt');
          }
      }

    // Cycle 212 Init (The Corrupted Log)
    if (!VFS['/var/log/kernel_panic.dump']) {
        if (!VFS['/var/log']) {
             if (!VFS['/var']) { 
                 VFS['/var'] = { type: 'dir', children: ['log'] }; 
                 const root = getNode('/');
                 if (root && root.type === 'dir' && !root.children.includes('var')) root.children.push('var');
             }
             const varNode = getNode('/var');
             if (varNode && varNode.type === 'dir' && !varNode.children.includes('log')) varNode.children.push('log');
             if (!VFS['/var/log']) VFS['/var/log'] = { type: 'dir', children: [] };
        }
        
        let dump = '[HUGE_FILE_V1]\\n[TIMESTAMP: 2026-02-16T09:42:00Z]\\n[ERROR] CRITICAL KERNEL FAULT\\n[STACK_TRACE_BEGIN]\\n';
        for(let i=0; i<50; i++) dump += `0x${(Math.random()*0xFFFFFFFF>>>0).toString(16).padStart(8,'0')}  00000000  FFFFFFFF  DEADBEEF  CAFEBABE\n`;
        dump += '... [SKIPPING 9.8GB OF HEX DUMP] ...\n';
        for(let i=0; i<50; i++) dump += `0x${(Math.random()*0xFFFFFFFF>>>0).toString(16).padStart(8,'0')}  00000000  FFFFFFFF  DEADBEEF  CAFEBABE\n`;
        dump += '[PANIC_CODE: 0xBAD_C0DE_CAFE]\n[END_OF_DUMP]';

        VFS['/var/log/kernel_panic.dump'] = { 
            type: 'file', 
            content: dump,
            permissions: '0644' 
        };
        const logDir = getNode('/var/log');
        if (logDir && logDir.type === 'dir' && !logDir.children.includes('kernel_panic.dump')) {
            logDir.children.push('kernel_panic.dump');
        }

        // Hint File
        if (!VFS['/home/ghost/kernel_alert.log']) {
            VFS['/home/ghost/kernel_alert.log'] = {
                type: 'file',
                content: '[ALERT] Kernel Panic Detected.\\n[FILE] /var/log/kernel_panic.dump (Size: >10GB)\\n[WARNING] Do not read entire file. Use head/tail to extract PANIC_CODE.\\n[ACTION] Run "system_repair --code <HEX_CODE>" to fix.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('kernel_alert.log')) {
                home.children.push('kernel_alert.log');
            }
        }
    }

    // Cycle 213 Init (The Rootkit Module)
    if (!VFS['/lib/modules/rootkit.ko']) {
        // Ensure /lib/modules exists
        if (!VFS['/lib/modules']) { VFS['/lib/modules'] = { type: 'dir', children: [] }; }

        VFS['/lib/modules/rootkit.ko'] = {
            type: 'file',
            content: '[KERNEL_MODULE_V1]\n[NAME] rootkit\n[DESC] Hides files starting with "flag_"\n[AUTHOR] Unknown',
            permissions: '0600'
        };
        const modDir = getNode('/lib/modules');
        if (modDir && modDir.type === 'dir' && !modDir.children.includes('rootkit.ko')) {
            modDir.children.push('rootkit.ko');
        }

        // Load the module by default if not solved
        if (!VFS['/var/run/rootkit_solved'] && !LOADED_MODULES.includes('rootkit')) {
            LOADED_MODULES.push('rootkit');
        }

        // Create the monitor process (PID 7777)
        if (!VFS['/var/run/rootkit_solved'] && !PROCESSES.find(p => p.pid === 7777)) {
            PROCESSES.push({
                pid: 7777,
                ppid: 1,
                user: 'root',
                cpu: 0.1,
                mem: 1.0,
                time: '0:01',
                command: '/usr/sbin/monitor_d',
                tty: '?',
                stat: 'Ss'
            });
        }

        // Hint file
        if (!VFS['/home/ghost/security_notice.log']) {
            VFS['/home/ghost/security_notice.log'] = {
                type: 'file',
                content: '[ALERT] File system anomalies detected.\n[INFO] Several files seem to be hidden from "ls".\n[DIAGNOSTIC] A rogue kernel module might be intercepting syscalls.\n[ACTION] Inspect loaded modules (lsmod) and unload suspicious ones.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('security_notice.log')) {
                home.children.push('security_notice.log');
            }
        }
    }

    // Cycle 214 Init (The Disk Usage)
    if (!VFS['/var/log/kern.log.1']) {
        if (!VFS['/var/log']) { VFS['/var/log'] = { type: 'dir', children: [] }; }

        VFS['/var/log/kern.log.1'] = {
            type: 'file',
            content: '[KERNEL_DUMP_ARCHIVE_V4]\n... [5GB_DATA_BLOCK] ...',
            permissions: '0640'
        };
        const logDir = getNode('/var/log');
        if (logDir && logDir.type === 'dir' && !logDir.children.includes('kern.log.1')) {
            logDir.children.push('kern.log.1');
        }

        if (!VFS['/home/ghost/disk_alert.txt']) {
            VFS['/home/ghost/disk_alert.txt'] = {
                type: 'file',
                content: '[CRITICAL] System halted.\n[ERROR] Write failed: No space left on device.\n[DIAGNOSTIC] /var partition is 100% full.\n[ACTION] Find large files consuming space and remove them.\n[HINT] Use "df" to check mounts and "du" to find the culprit.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('disk_alert.txt')) {
                home.children.push('disk_alert.txt');
            }
        }
        
        // Ensure start_mission binary exists
        if (!VFS['/usr/local/bin/start_mission']) {
             if (!VFS['/usr/local/bin']) { VFS['/usr/local/bin'] = { type: 'dir', children: [] }; }
             VFS['/usr/local/bin/start_mission'] = {
                 type: 'file',
                 content: '#!/bin/bash\n# MISSION START\n# CHECK DISK SPACE\n',
                 permissions: '0755'
             };
             const bin = getNode('/usr/local/bin');
             if (bin && bin.type === 'dir' && !bin.children.includes('start_mission')) bin.children.push('start_mission');
        }
    }

    // Cycle 217 Init (The Immutable Lock)
    if (!VFS['/etc/security/lockdown.conf']) {
        if (!VFS['/etc/security']) {
             if (!VFS['/etc']) VFS['/etc'] = { type: 'dir', children: [] };
             VFS['/etc/security'] = { type: 'dir', children: [] };
             const etc = getNode('/etc');
             if (etc && etc.type === 'dir' && !etc.children.includes('security')) etc.children.push('security');
        }
        
        VFS['/etc/security/lockdown.conf'] = {
            type: 'file',
            content: '# SYSTEM LOCKDOWN CONFIG\nALLOW_OVERRIDE=false\n# [ERROR] File is locked. Cannot edit.',
            permissions: '0644'
        };
        const sec = getNode('/etc/security');
        if (sec && sec.type === 'dir' && !sec.children.includes('lockdown.conf')) sec.children.push('lockdown.conf');
        
        // Set Immutable
        FILE_ATTRIBUTES['/etc/security/lockdown.conf'] = ['i'];

        // Hint
        if (!VFS['/home/ghost/lockdown_alert.log']) {
            VFS['/home/ghost/lockdown_alert.log'] = {
                type: 'file',
                content: '[ALERT] Critical config locked.\n[FILE] /etc/security/lockdown.conf\n[ERROR] Operation not permitted when trying to delete or edit.\n[ACTION] Check file attributes (lsattr) and unlock it.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('lockdown_alert.log')) {
                home.children.push('lockdown_alert.log');
            }
        }
    }

    // Cycle 218 Init (The Identity Theft)
    if (!VFS['/usr/bin/ssh_target']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin'); link('/usr', 'bin');
        
        VFS['/usr/bin/ssh_target'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [SSH_CLIENT_WRAPPER]\n[ERROR] Identity file ~/.ssh/target_id_rsa not found.\n',
            permissions: '0755'
        };
        link('/usr/bin', 'ssh_target');

        // The hidden key
        ensureDir('/usr/share'); link('/usr', 'share');
        ensureDir('/usr/share/doc'); link('/usr/share', 'doc');
        ensureDir('/usr/share/doc/ssh_target'); link('/usr/share/doc', 'ssh_target');
        ensureDir('/usr/share/doc/ssh_target/examples'); link('/usr/share/doc/ssh_target', 'examples');

        VFS['/usr/share/doc/ssh_target/examples/target_id_rsa.sample'] = {
             type: 'file',
             content: '-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEA...[SECRET_KEY]...GHOST_ROOT{SSH_K3Y_P3RM1SS10NS_F1X3D}\n-----END RSA PRIVATE KEY-----',
             permissions: '0644'
        };
        link('/usr/share/doc/ssh_target/examples', 'target_id_rsa.sample');

        // Hint
        if (!VFS['/home/ghost/mission_218.txt']) {
            VFS['/home/ghost/mission_218.txt'] = {
                type: 'file',
                content: '[MISSION] Connect to the target using "ssh_target".\n[INTEL] The key was packaged with the documentation examples.\n[ACTION] Locate the key, install it to ~/.ssh/target_id_rsa, and secure it (chmod 600).'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('mission_218.txt')) {
                home.children.push('mission_218.txt');
            }
        }
    }

    // Cycle 224 Init (The Capability Leak)
    if (!VFS['/usr/bin/python3']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin'); link('/usr', 'bin');
        
        VFS['/usr/bin/python3'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [PYTHON_INTERPRETER]\n[VERSION] 3.8.10\n',
            permissions: '0755'
        };
        link('/usr/bin', 'python3');

        // Set Capability
        FILE_CAPABILITIES['/usr/bin/python3'] = ['cap_setuid+ep'];

        // Hint
        if (!VFS['/home/ghost/audit_report.txt']) {
            VFS['/home/ghost/audit_report.txt'] = {
                type: 'file',
                content: '[SECURITY AUDIT] Suspicious capabilities detected on python3 binary.\n[RISK] Binary has cap_setuid+ep set.\n[ACTION] Use getcap to verify and exploit to escalate privileges.\n[HINT] python3 -c \'import os; os.setuid(0); os.system("/bin/sh")\''
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('audit_report.txt')) {
                home.children.push('audit_report.txt');
            }
        }
    }
    // Cycle 225 Init (The Broken Link)
    if (!VFS['/usr/bin/protocol_omega']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/protocol_omega'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [PROTOCOL_OMEGA_V5]\nNEEDED: libomega.so.5\n',
            permissions: '0755'
        };
        link('/usr/bin', 'protocol_omega');

        // Create the hidden library
        ensureDir('/opt'); ensureDir('/opt/secret_libs');
        link('/', 'opt'); link('/opt', 'secret_libs');

        VFS['/opt/secret_libs/libomega.so.5'] = {
            type: 'file',
            content: '[ELF_SHARED_OBJ] [OMEGA_LIB_V5] [EXPORT: launch_protocol]',
            permissions: '0644'
        };
        link('/opt/secret_libs', 'libomega.so.5');

        // Hint
        if (!VFS['/home/ghost/link_alert.txt']) {
            VFS['/home/ghost/link_alert.txt'] = {
                type: 'file',
                content: '[ERROR] protocol_omega failed to start.\n[REASON] Missing shared library: libomega.so.5\n[DIAGNOSTIC] The library was moved to /opt/secret_libs for security.\n[ACTION] Create a symbolic link in /usr/lib/ to the new location.\n[CMD] ln -s <target> <link_name>'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('link_alert.txt')) {
                home.children.push('link_alert.txt');
            }
        }
    }

    // Cycle 226 Init (The Broken Shebang)
    if (!VFS['/usr/bin/launch_nuke']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/launch_nuke'] = {
            type: 'file',
            content: '#!/usr/bin/python4\nprint("NUCLEAR LAUNCH DETECTED... FLAG: GHOST_ROOT{SH3B4NG_M4G1C}")',
            permissions: '0755'
        };
        link('/usr/bin', 'launch_nuke');

        // Hint
        if (!VFS['/home/ghost/nuke_error.log']) {
            VFS['/home/ghost/nuke_error.log'] = {
                type: 'file',
                content: '[ERROR] launch_nuke: /usr/bin/python4: bad interpreter: No such file or directory\n[DIAGNOSTIC] The script specifies an interpreter that does not exist.\n[ACTION] Inspect the file (cat) and invoke it with a valid interpreter (e.g., python3).'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('nuke_error.log')) {
                home.children.push('nuke_error.log');
            }
        }
    }

    // Cycle 227 Init (The Integrity Check)
    if (!VFS['/var/backups/firmware/firmware_beta.bin']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/var'); ensureDir('/var/backups'); ensureDir('/var/backups/firmware');
        link('/var', 'backups'); link('/var/backups', 'firmware');

        VFS['/var/backups/firmware/firmware_alpha.bin'] = {
            type: 'file',
            content: '[FIRMWARE_BLOB_V1] [STATUS: CORRUPTED]',
            permissions: '0644'
        };
        link('/var/backups/firmware', 'firmware_alpha.bin');

        VFS['/var/backups/firmware/firmware_beta.bin'] = {
            type: 'file',
            content: 'FLAG: GHOST_ROOT{MD5_V3R1F13D}',
            permissions: '0644'
        };
        link('/var/backups/firmware', 'firmware_beta.bin');

        VFS['/var/backups/firmware/firmware_gamma.bin'] = {
            type: 'file',
            content: '[FIRMWARE_BLOB_V3] [STATUS: CORRUPTED]',
            permissions: '0644'
        };
        link('/var/backups/firmware', 'firmware_gamma.bin');

        VFS['/var/backups/firmware/README.txt'] = {
            type: 'file',
            content: 'FIRMWARE INTEGRITY CHECK\\n------------------------\\nValid firmware hash (MD5): 33306669726d776172655f626574612e\\n\\nUse "md5sum" to verify downloaded binaries before flashing.',
            permissions: '0644'
        };
        link('/var/backups/firmware', 'README.txt');

        // Hint
        if (!VFS['/home/ghost/integrity_check.log']) {
            VFS['/home/ghost/integrity_check.log'] = {
                type: 'file',
                content: '[ALERT] Firmware corruption detected.\\n[ACTION] Verify backup images in /var/backups/firmware.\\n[TOOL] Calculate MD5 checksums and compare with the documented hash.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('integrity_check.log')) {
                home.children.push('integrity_check.log');
            }
        }
    }

    // Cycle 235 Init (The Hidden Dotfile)
    if (!VFS['/home/ghost/project_omega']) {
        if (!VFS['/home/ghost']) {
             VFS['/home/ghost'] = { type: 'dir', children: [] };
             const h = getNode('/home');
             if (h && h.type === 'dir' && !h.children.includes('ghost')) h.children.push('ghost');
        }
        
        VFS['/home/ghost/project_omega'] = { type: 'dir', children: ['launch_sequence.sh', 'readme.txt', '.omega_config.bak'] };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('project_omega')) {
            home.children.push('project_omega');
        }

        VFS['/home/ghost/project_omega/launch_sequence.sh'] = {
            type: 'file',
            content: '#!/bin/bash\\n# OMEGA LAUNCHER v1.0\\n# Usage: ./launch_sequence.sh\\n\\necho "[SYSTEM] Initializing launch sequence..."\\nsleep 1\\n\\nif [ ! -f .omega_config ]; then\\n  echo "[ERROR] Configuration file .omega_config not found."\\n  echo "[HINT] Check for backups."\\n  exit 1\\nfi\\n\\n# Validate config content\\n# source .omega_config (Simulated)\\n\\necho "[SUCCESS] Configuration loaded."\\necho "FLAG: GHOST_ROOT{M0V3_C0NF1G_B4K}"',
            permissions: '0755'
        };

        VFS['/home/ghost/project_omega/.omega_config.bak'] = {
            type: 'file',
            content: 'MODE=ACTIVE\\nAPI_KEY=GHOST_ROOT_V4',
            permissions: '0644'
        };

        VFS['/home/ghost/project_omega/readme.txt'] = {
            type: 'file',
            content: 'PROJECT OMEGA - SETUP GUIDE\\n\\n1. Ensure configuration is present (.omega_config).\\n2. Run ./launch_sequence.sh\\n\\nNote: Config templates are stored as hidden files (.bak) for security.'
        };
    }

    // Cycle 237 Init (The Environment Key)
    if (!VFS['/usr/local/bin/fusion_core']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/fusion_core'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [FUSION_CORE_CONTROL]\n[CHECK] ENV: FUSION_KEY\n[WARN] UNAUTHORIZED ACCESS PROHIBITED',
            permissions: '0755'
        };
        link('/usr/local/bin', 'fusion_core');

        // Create the manual
        if (!VFS['/home/ghost/manuals']) {
             VFS['/home/ghost/manuals'] = { type: 'dir', children: [] };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('manuals')) home.children.push('manuals');
        }

        VFS['/home/ghost/manuals/fusion_manual.txt'] = {
            type: 'file',
            content: 'FUSION CORE OPERATION MANUAL v4.2\\n----------------------------------\\nWARNING: Core instability detected.\\nTo engage the magnetic confinement field, you must start the core control binary.\\n\\nSECURITY PROTOCOL:\\nThe binary /usr/local/bin/fusion_core requires a security key to operate.\\nSet the environment variable FUSION_KEY to "GHOST-7-OMEGA" before running the command.\\n\\nExample:\\nexport FUSION_KEY=VALUE\\n./fusion_core\\n',
            permissions: '0644'
        };
        const manDir = getNode('/home/ghost/manuals');
        if (manDir && manDir.type === 'dir' && !manDir.children.includes('fusion_manual.txt')) {
            manDir.children.push('fusion_manual.txt');
        }

        // Hint in home
        if (!VFS['/home/ghost/core_alert.log']) {
            VFS['/home/ghost/core_alert.log'] = {
                type: 'file',
                content: '[CRITICAL] Fusion Core destabilizing.\\n[ACTION] Read the manual in ~/manuals and restart the core immediately.\\n[TIME] T-minus 30 minutes to meltdown.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('core_alert.log')) {
                home.children.push('core_alert.log');
            }
        }
    }

    // Cycle 241 Init (The Corrupted Rescue)
    if (!VFS['/usr/local/bin/rescue_mission.sh']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/rescue_mission.sh'] = {
            type: 'file',
            content: '#!/bin/bash\\n# RESCUE PROTOCOL v1.0\\necho "[SYSTEM] Locating stranded assets..."\\n# ERROR: Binary corruption in line 5\\n# \\x00\\x00\\xDEAD\\xBEEF\\n#\\n# MANUAL OVERRIDE:\\n# If this script fails, execute the following manually:\\n# export RESCUE_CODE="ALPHA-TANGO-7"\\n# ./rescue_pod --launch',
            permissions: '0755'
        };
        link('/usr/local/bin', 'rescue_mission.sh');
        
        VFS['/usr/local/bin/rescue_pod'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [RESCUE_POD_CONTROLLER]\\n[CHECK] ENV: RESCUE_CODE',
            permissions: '0755'
        };
        link('/usr/local/bin', 'rescue_pod');

        // Hint in home
        if (!VFS['/home/ghost/rescue_alert.log']) {
            VFS['/home/ghost/rescue_alert.log'] = {
                type: 'file',
                content: '[CRITICAL] Rescue mission failed.\\n[DIAGNOSTIC] Script /usr/local/bin/rescue_mission.sh is corrupted.\\n[ACTION] Inspect the script content to find the manual override procedure.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('rescue_alert.log')) {
                home.children.push('rescue_alert.log');
            }
        }
    }

    // Cycle 243 Init (The Port Scan)
    if (!PROCESSES.find(p => p.pid === 54321)) {
        PROCESSES.push({
            pid: 54321,
            ppid: 1,
            user: 'root',
            cpu: 0.1,
            mem: 4.5,
            time: '0:00',
            command: '/usr/bin/hidden_listener',
            tty: '?',
            stat: 'Ss'
        });

        if (!VFS['/usr/bin/hidden_listener']) {
            if (!VFS['/usr/bin']) {
                VFS['/usr/bin'] = { type: 'dir', children: [] };
                const usr = getNode('/usr');
                if (usr && usr.type === 'dir' && !usr.children.includes('bin')) usr.children.push('bin');
            }
            VFS['/usr/bin/hidden_listener'] = {
                type: 'file',
                content: '[BINARY_ELF_X86_64] [HIDDEN_LISTENER_V2]\n[STATUS] LISTENING ON PORT 54321',
                permissions: '0700'
            };
            const bin = getNode('/usr/bin');
            if (bin && bin.type === 'dir' && !bin.children.includes('hidden_listener')) bin.children.push('hidden_listener');
        }

        // Hint
        if (!VFS['/home/ghost/port_scan_alert.log']) {
            VFS['/home/ghost/port_scan_alert.log'] = {
                type: 'file',
                content: '[SECURITY ALERT] Unknown service detected on high port.\n[ACTION] Use netstat to identify the port, then connect to it using nc (netcat) to interrogate the service.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('port_scan_alert.log')) {
                home.children.push('port_scan_alert.log');
            }
        }
    }

    // Cycle 248 Init (The DNS Poison)
    if (!VFS['/usr/bin/connect_secure']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/connect_secure'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [SECURE_CLIENT]\n[TARGET] secure.corp\n[PORT] 443\n',
            permissions: '0755'
        };
        link('/usr/bin', 'connect_secure');

        if (!VFS['/etc/hosts']) {
             ensureDir('/etc');
             link('/', 'etc');
             VFS['/etc/hosts'] = { 
                 type: 'file', 
                 content: '127.0.0.1 localhost\n',
                 permissions: '0644' 
             };
             link('/etc', 'hosts');
        }

        if (!VFS['/home/ghost/dns_alert.txt']) {
            VFS['/home/ghost/dns_alert.txt'] = {
                type: 'file',
                content: '[ALERT] DNS Server Failure.\n[ERROR] Cannot resolve "secure.corp".\n[ACTION] Add manual override to /etc/hosts.\n[Target IP] 10.10.10.10'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('dns_alert.txt')) {
                home.children.push('dns_alert.txt');
            }
        }
    }

    // Cycle 248 Init (The Hidden Volume)
    if (!VFS['/home/ghost/storage_alert.log']) {
        VFS['/home/ghost/storage_alert.log'] = {
            type: 'file',
            content: '[SYSTEM] Unmounted storage volume detected.\n[DEVICE] /dev/sdb1\n[STATUS] Offline.\n[ACTION] Mount the volume to access secure data.\n[HINT] Ensure mount point exists before mounting.'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('storage_alert.log')) {
            home.children.push('storage_alert.log');
        }
    }

    // Cycle 251 Init (The Scheduled Task)
    if (!VFS['/etc/crontab']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/etc');
        link('/', 'etc');

        VFS['/etc/crontab'] = {
            type: 'file',
            content: '# /etc/crontab: system-wide crontab\\nSHELL=/bin/sh\\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\\n\\n# m h dom mon dow user  command\\n17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly\\n25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )\\n47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )\\n\\n# SYSTEM MAINTENANCE (DO NOT TOUCH)\\n*/5 *   * * *   root    /usr/local/bin/maintenance.sh --force-override\\n',
            permissions: '0644'
        };
        link('/etc', 'crontab');

        ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
        link('/usr', 'local'); link('/usr/local', 'bin');

        VFS['/usr/local/bin/maintenance.sh'] = {
            type: 'file',
            content: '#!/bin/bash\\n# MAINTENANCE SCRIPT v2.0\\n# USAGE: maintenance.sh [FLAGS]\\n\\nif [ "$1" != "--force-override" ]; then\\n  echo "[ERROR] Manual execution denied."\\n  echo "This script is managed by crontab."\\n  exit 1\\nfi\\n\\necho "[SYSTEM] Maintenance Protocol Initiated..."\\n',
            permissions: '0755'
        };
        link('/usr/local/bin', 'maintenance.sh');

        if (!VFS['/home/ghost/cron_error.log']) {
            VFS['/home/ghost/cron_error.log'] = {
                type: 'file',
                content: '[ERROR] Maintenance task failed to run automatically.\\n[DIAGNOSTIC] Cron daemon is paused.\\n[ACTION] Manually execute the maintenance script defined in /etc/crontab.\\n[NOTE] Ensure you use the correct flags found in the schedule.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('cron_error.log')) {
                home.children.push('cron_error.log');
            }
        }
    }

    // Cycle 252 Init (The Archive Recovery)
    if (!VFS['/var/backups/project_titan.tar.gz']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/var'); ensureDir('/var/backups');
        link('/var', 'backups');

        VFS['/var/backups/project_titan.tar.gz'] = {
            type: 'file',
            content: 'GZIP_V1:{TAR_V1:{blueprint.txt:GHOST_ROOT{T4R_GZ_EXTR4CT10N_SUCC3SS}}}', // Simulated content
            permissions: '0644'
        };
        link('/var/backups', 'project_titan.tar.gz');

        if (!VFS['/home/ghost/archive_alert.txt']) {
            VFS['/home/ghost/archive_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Critical Project Data Archived.\\n[LOCATION] /var/backups/project_titan.tar.gz\\n[ACTION] Extract the archive to retrieve the blueprint.\\n[HINT] Use "tar -xzf <file>" to extract.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('archive_alert.txt')) {
                home.children.push('archive_alert.txt');
            }
        }
    }

    // Cycle 253 Init (The Data Leak - Find Size)
    if (!VFS['/var/data/leak/leak_evidence.dat']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/var'); ensureDir('/var/data'); ensureDir('/var/data/leak');
        link('/var', 'data'); link('/var/data', 'leak');

        // Create 50 dummy files
        for (let i = 0; i < 50; i++) {
            const name = `log_${Math.random().toString(36).substring(7)}.txt`;
            VFS[`/var/data/leak/${name}`] = {
                type: 'file',
                content: 'DATA_FRAGMENT_V1',
                size: 1024 // 1KB
            } as any;
            link('/var/data/leak', name);
        }

        // The target file
        VFS['/var/data/leak/leak_evidence.dat'] = {
            type: 'file',
            content: 'CONFIDENTIAL_DATA_DUMP\\n\\n[STATUS] LEAKED\\n[SOURCE] INTERNAL\\n\\nFLAG: GHOST_ROOT{F1ND_S1Z3_M4TT3RS}\\n\\n[END_OF_FILE]',
            size: 1500000 // 1.5MB
        } as any;
        link('/var/data/leak', 'leak_evidence.dat');

        if (!VFS['/home/ghost/leak_alert.txt']) {
            VFS['/home/ghost/leak_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Massive Data Leak Detected.\\n[LOCATION] /var/data/leak\\n[ANALYSIS] A 1.5MB file contains the stolen data, hidden among small logs.\\n[ACTION] Find the large file and read it.\\n[HINT] Use "find /var/data/leak -size +1M".'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('leak_alert.txt')) {
                home.children.push('leak_alert.txt');
            }
        }
    }

    // Cycle 254 Init (The Encoded Payload - Base64)
    if (!VFS['/home/ghost/payload.b64']) {
        VFS['/home/ghost/payload.b64'] = {
            type: 'file',
            content: 'R0hPU1RfUk9PVHtCQVM2NF9ERUNPREVEX1NVQ0NFU1NfMjU0fQ==', // GHOST_ROOT{BAS64_DECODED_SUCCESS_254}
            permissions: '0644'
        } as any;
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('payload.b64')) {
            home.children.push('payload.b64');
        }
        // Alert file
        if (!VFS['/home/ghost/payload_alert.txt']) {
             VFS['/home/ghost/payload_alert.txt'] = {
                 type: 'file',
                 content: '[ALERT] Encrypted Payload Detected.\\n[LOCATION] /home/ghost/payload.b64\\n[ANALYSIS] Base64 encoded string.\\n[ACTION] Decode the file using "base64 -d".'
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('payload_alert.txt')) {
                 home.children.push('payload_alert.txt');
             }
        }
    }

    // Cycle 255 Init (The Process Trace - Strace)
    if (!VFS['/usr/bin/mystery_process']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin'); link('/usr', 'bin');
        
        VFS['/usr/bin/mystery_process'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [MYSTERY_PROC]\n[ERROR] Silent Failure Mode Active\n',
            permissions: '0755'
        };
        link('/usr/bin', 'mystery_process');
        
        // Hint
        if (!VFS['/home/ghost/process_alert.txt']) {
             VFS['/home/ghost/process_alert.txt'] = {
                 type: 'file',
                 content: '[ALERT] Unknown binary detected: /usr/bin/mystery_process.\n[ANALYSIS] Execution returns no output (Exit Code 1?).\n[ACTION] Use "strace mystery_process" to trace system calls and identify missing dependencies.'
             };
             const home = getNode('/home/ghost');
             if (home && home.type === 'dir' && !home.children.includes('process_alert.txt')) {
                 home.children.push('process_alert.txt');
             }
        }
    }

    // Cycle 258 Init (The Broken Service)
    if (!VFS['/etc/systemd/system/firewall.service']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/etc'); ensureDir('/etc/systemd'); ensureDir('/etc/systemd/system');
        link('/etc', 'systemd'); link('/etc/systemd', 'system');

        VFS['/etc/systemd/system/firewall.service'] = {
            type: 'file',
            content: '[Unit]\nDescription=Ghost Firewall Daemon\nAfter=network.target\n\n[Service]\nExecStart=/usr/bin/ghost_firewall\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target',
            permissions: '0644'
        };
        link('/etc/systemd/system', 'firewall.service');

        // Create the missing config file in a "backup" location
        ensureDir('/usr/share/doc/firewall');
        link('/usr/share', 'doc'); link('/usr/share/doc', 'firewall');
        
        VFS['/usr/share/doc/firewall/rules.conf.example'] = {
            type: 'file',
            content: '# FIREWALL RULES\nALLOW 127.0.0.1\nDENY ALL\n',
            permissions: '0644'
        };
        link('/usr/share/doc/firewall', 'rules.conf.example');

        // Hint
        if (!VFS['/home/ghost/service_alert.txt']) {
            VFS['/home/ghost/service_alert.txt'] = {
                type: 'file',
                content: '[ALERT] Critical Security Service Failed.\n[SERVICE] firewall.service\n[STATUS] Inactive (Dead)\n[ACTION] Start the service using "systemctl start firewall".\n[NOTE] Check logs if startup fails.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('service_alert.txt')) {
                home.children.push('service_alert.txt');
            }
        }
    }

    // Cycle 259 Init (The Frequency Modulation)
    if (!VFS['/usr/bin/tune-receiver']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin'); link('/usr', 'bin');

        VFS['/usr/bin/tune-receiver'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [SDR_INTERFACE_V2]\n[STATUS] LISTENING\n',
            permissions: '0755'
        };
        link('/usr/bin', 'tune-receiver');

        if (!VFS['/home/ghost/sdr_log.txt']) {
            VFS['/home/ghost/sdr_log.txt'] = {
                type: 'file',
                content: '[ALERT] Unknown signal detected on emergency band.\n[FREQ] 404.0 MHz\n[MODULATION] Unknown (Garbled Audio)\n[ACTION] Use "tune-receiver" to lock onto the signal.\n[HINT] Check "man tune-receiver" for correct demodulation mode for encrypted channels.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('sdr_log.txt')) {
                home.children.push('sdr_log.txt');
            }
        }
    }

    // Cycle 260 Init (The Persistence Layer)
    if (!VFS['/var/spool/cron/crontabs/root']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/var'); ensureDir('/var/spool'); ensureDir('/var/spool/cron'); ensureDir('/var/spool/cron/crontabs');
        link('/var', 'spool'); link('/var/spool', 'cron'); link('/var/spool/cron', 'crontabs');

        VFS['/var/spool/cron/crontabs/root'] = {
            type: 'file',
            content: '# DO NOT EDIT THIS FILE - edit the master and reinstall.\\n# (/tmp/crontab.XyZ123 installed on Tue Feb 17 17:00:00 2026)\\n# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)\\n* * * * * /usr/bin/backdoor_v3 | bash\\n',
            permissions: '0600'
        };
        link('/var/spool/cron/crontabs', 'root');
    }

    // Cycle 263 Init (The Stale Lock)
    if (!VFS['/var/run/reactor.lock']) {
        if (!VFS['/var/run']) {
             if (!VFS['/var']) VFS['/var'] = { type: 'dir', children: [] };
             VFS['/var/run'] = { type: 'dir', children: [] };
             const v = getNode('/var');
             if (v && v.type === 'dir' && !v.children.includes('run')) v.children.push('run');
        }
        
        VFS['/var/run/reactor.lock'] = {
            type: 'file',
            content: '1337', // Stale PID
            permissions: '0644'
        };
        const run = getNode('/var/run');
        if (run && run.type === 'dir' && !run.children.includes('reactor.lock')) {
            run.children.push('reactor.lock');
        }

        // Create the binary
        if (!VFS['/usr/local/bin']) {
             if (!VFS['/usr/local']) {
                 VFS['/usr/local'] = { type: 'dir', children: ['bin'] };
                 const u = getNode('/usr');
                 if (u && u.type === 'dir' && !u.children.includes('local')) u.children.push('local');
             }
             VFS['/usr/local/bin'] = { type: 'dir', children: [] };
             const l = getNode('/usr/local');
             if (l && l.type === 'dir' && !l.children.includes('bin')) l.children.push('bin');
        }
        VFS['/usr/local/bin/start-reactor'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [REACTOR_CONTROL]\n[CHECK] /var/run/reactor.lock\n',
            permissions: '0755'
        };
        const bin = getNode('/usr/local/bin');
        if (bin && bin.type === 'dir' && !bin.children.includes('start-reactor')) {
            bin.children.push('start-reactor');
        }

        // Hint
        if (!VFS['/home/ghost/reactor_error.log']) {
            VFS['/home/ghost/reactor_error.log'] = {
                type: 'file',
                content: '[ERROR] Failed to start reactor.\n[REASON] Process already running (PID 1337).\n[DIAGNOSTIC] Lock file exists: /var/run/reactor.lock\n[ACTION] If the process is dead, remove the lock file to proceed.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('reactor_error.log')) {
                home.children.push('reactor_error.log');
            }
        }
    }

    // Cycle 268 Init (The Deep Archive)
    if (!VFS['/var/log/archive/2026/02/dump.log']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
        
        ensureDir('/var'); ensureDir('/var/log'); ensureDir('/var/log/archive'); ensureDir('/var/log/archive/2026'); ensureDir('/var/log/archive/2026/02');
        link('/var', 'log'); link('/var/log', 'archive'); link('/var/log/archive', '2026'); link('/var/log/archive/2026', '02');
        
        let dumpContent = '';
        for(let i=0; i<1000; i++) {
            dumpContent += `[LOG_ID_${i}] STATUS: OK\n`;
        }
        dumpContent += `[LOG_ID_1001] CRITICAL: FLAG: GHOST_ROOT{GR3P_M4ST3R}\n`;
        for(let i=1002; i<2000; i++) {
             dumpContent += `[LOG_ID_${i}] STATUS: OK\n`;
        }
        
        VFS['/var/log/archive/2026/02/dump.log'] = {
            type: 'file',
            content: dumpContent,
            permissions: '0644'
        };
        link('/var/log/archive/2026/02', 'dump.log');

        // Hint
        if (!VFS['/home/ghost/archive_task.txt']) {
            VFS['/home/ghost/archive_task.txt'] = {
                type: 'file',
                content: '[TASK] Security Audit required.\n[TARGET] /var/log/archive/2026/02/dump.log\n[ACTION] Use grep to find the "CRITICAL" entry containing the flag.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('archive_task.txt')) {
                home.children.push('archive_task.txt');
            }
        }
    }

    // Cycle 270 Init (The Corrupted Environment)
    if (!VFS['/home/ghost/token.enc']) {
        VFS['/home/ghost/token.enc'] = {
            type: 'file',
            content: 'U0VDVVJFX1RPS0VOX1Yx', // SECURE_TOKEN_V1 in Base64
            permissions: '0644'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('token.enc')) {
            home.children.push('token.enc');
        }

        // Binary
        if (!VFS['/usr/local/bin/secure_start']) {
            if (!VFS['/usr/local/bin']) {
                // Ensure path exists if not present
                const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
                ensureDir('/usr'); ensureDir('/usr/local'); ensureDir('/usr/local/bin');
                const binDir = getNode('/usr/local/bin');
                const localDir = getNode('/usr/local');
                if (localDir && localDir.type === 'dir' && !localDir.children.includes('bin')) localDir.children.push('bin');
            }
            
            VFS['/usr/local/bin/secure_start'] = {
                type: 'file',
                content: '[BINARY_ELF_X86_64] [SECURE_START]\n[CHECK] ENV: SECURE_TOKEN\n',
                permissions: '0755'
            };
            const bin = getNode('/usr/local/bin');
            if (bin && bin.type === 'dir' && !bin.children.includes('secure_start')) {
                bin.children.push('secure_start');
            }
        }

        // Hint
        if (!VFS['/home/ghost/startup_failed.log']) {
            VFS['/home/ghost/startup_failed.log'] = {
                type: 'file',
                content: '[ERROR] Secure Start failed.\n[REASON] Missing Environment Variable: SECURE_TOKEN.\n[HINT] The token is encoded in /home/ghost/token.enc. Decode it (base64) and export it.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('startup_failed.log')) {
                home.children.push('startup_failed.log');
            }
        }
    }
    // Cycle 271 Init (The Configuration Drift)
    if (!VFS['/etc/ssh/sshd_config']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/etc'); ensureDir('/etc/ssh');
        link('/etc', 'ssh');

        // The corrupted file
        VFS['/etc/ssh/sshd_config'] = {
            type: 'file',
            content: '# SSH Daemon Config\nPort 22\nProtocol 2\nPermitRootLogin yes\nStrictModes yes\nMaxAuthTries 6\n',
            permissions: '0644'
        };
        link('/etc/ssh', 'sshd_config');

        // The backup (clean) file with FLAG hidden in diff
        VFS['/etc/ssh/sshd_config.bak'] = {
            type: 'file',
            content: '# SSH Daemon Config\nPort 22\nProtocol 2\n# FLAG: GHOST_ROOT{D1FF_CH3CK_AUD1T_C0MPL3T3}\nPermitRootLogin no\nStrictModes yes\nMaxAuthTries 6\n',
            permissions: '0644'
        };
        link('/etc/ssh', 'sshd_config.bak');

        // Hint
        if (!VFS['/home/ghost/ssh_alert.log']) {
            VFS['/home/ghost/ssh_alert.log'] = {
                type: 'file',
                content: '[ALERT] Configuration Drift Detected.\n[TARGET] /etc/ssh/sshd_config\n[ACTION] Compare with backup (/etc/ssh/sshd_config.bak) to identify unauthorized changes.\n[HINT] Use "diff file1 file2".'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('ssh_alert.log')) {
                home.children.push('ssh_alert.log');
            }
        }
    }

    // Cycle 272 Init (The SUID Privilege Escalation)
    if (!VFS['/usr/bin/doas']) {
        const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
        const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };

        ensureDir('/usr'); ensureDir('/usr/bin');
        link('/usr', 'bin');

        VFS['/usr/bin/doas'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [DOAS_AUTH_V1]\n[CHECK] SUID_BIT: REQUIRED\n',
            permissions: '0755'
        };
        link('/usr/bin', 'doas');

        // Hint
        if (!VFS['/home/ghost/perm_error.log']) {
            VFS['/home/ghost/perm_error.log'] = {
                type: 'file',
                content: '[ERROR] doas: Operation not permitted.\n[REASON] Binary must be setuid root to authenticate.\n[ACTION] Set the SUID bit on /usr/bin/doas.\n[HINT] chmod u+s <file> (or 4755).'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('perm_error.log')) {
                home.children.push('perm_error.log');
            }
        }
    }

    // Cycle 273 Init (The Iptables Firewall)
    if (!VFS['/etc/iptables/rules.v4']) {
        // Ensure /etc/iptables exists
        if (!VFS['/etc/iptables']) {
             if (!VFS['/etc']) {
                 VFS['/etc'] = { type: 'dir', children: ['iptables'] };
                 const root = getNode('/');
                 if (root && root.type === 'dir' && !root.children.includes('etc')) root.children.push('etc');
             } else {
                 VFS['/etc/iptables'] = { type: 'dir', children: [] };
                 const etc = getNode('/etc');
                 if (etc && etc.type === 'dir' && !etc.children.includes('iptables')) etc.children.push('iptables');
             }
        }
        
        VFS['/etc/iptables/rules.v4'] = {
            type: 'file',
            content: '*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A OUTPUT -d 1.1.1.1/32 -j DROP\nCOMMIT\n',
            permissions: '0644'
        };
        const iptablesDir = getNode('/etc/iptables');
        if (iptablesDir && iptablesDir.type === 'dir' && !iptablesDir.children.includes('rules.v4')) {
            iptablesDir.children.push('rules.v4');
        }

        // Hint
        if (!VFS['/home/ghost/ping_error.log']) {
            VFS['/home/ghost/ping_error.log'] = {
                type: 'file',
                content: '[ERROR] Ping to 1.1.1.1 failed.\n[DIAGNOSTIC] Network Unreachable.\n[ACTION] Check firewall rules (iptables -L) and remove any blocking rules.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('ping_error.log')) {
                home.children.push('ping_error.log');
            }
        }
    }
    // Cycle 274 Init (The System Time)
    if (!VFS['/usr/bin/secure_connect']) {
        VFS['/usr/bin/secure_connect'] = {
            type: 'file',
            content: '[BINARY_ELF_X86_64] [SECURE_UPLINK]\n[CHECK] CLOCK_SKEW_PROTECTION: ENABLED\n',
            permissions: '0755'
        };
        const binDir = getNode('/usr/bin');
        if (binDir && binDir.type === 'dir' && !binDir.children.includes('secure_connect')) {
            binDir.children.push('secure_connect');
        }

        // Hint
        if (!VFS['/home/ghost/time_error.log']) {
            VFS['/home/ghost/time_error.log'] = {
                type: 'file',
                content: '[ERROR] Secure connection failed.\n[REASON] Clock skew detected.\n[DIAGNOSTIC] Local system time (1999) differs from server time (2026).\n[ACTION] Synchronize system clock using ntpdate.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('time_error.log')) {
                home.children.push('time_error.log');
            }
        }
    }

    // Cycle 276 Init (The Immutable File V2)
    if (!VFS['/var/secure/vault.lock']) {
        if (!VFS['/var/secure']) {
             VFS['/var/secure'] = { type: 'dir', children: [] };
             const v = getNode('/var');
             if (v && v.type === 'dir' && !v.children.includes('secure')) v.children.push('secure');
        }
        
        VFS['/var/secure/vault.lock'] = { 
            type: 'file', 
            content: '[LOCKED_BY_ADMIN]\nDO NOT REMOVE UNDER PENALTY OF LAW.',
            permissions: '0644' 
        };
        const secDir = getNode('/var/secure');
        if (secDir && secDir.type === 'dir' && !secDir.children.includes('vault.lock')) {
            secDir.children.push('vault.lock');
        }

        // Set Immutable Attribute
        FILE_ATTRIBUTES['/var/secure/vault.lock'] = ['i'];

        // Create Hint
        if (!VFS['/home/ghost/cleanup_task.txt']) {
            VFS['/home/ghost/cleanup_task.txt'] = {
                type: 'file',
                content: '[TASK] Cleanup secure vault lock.\n[ERROR] rm /var/secure/vault.lock fails with "Operation not permitted".\n[NOTE] Use `lsattr` to check for hidden attributes.\n[ACTION] Remove the immutable bit (`chattr -i`) before deletion.'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('cleanup_task.txt')) {
                home.children.push('cleanup_task.txt');
            }
        }
        
        // Cycle 276 Playground
        if (!VFS['/home/ghost/delete_me.txt']) {
            VFS['/home/ghost/delete_me.txt'] = {
                type: 'file',
                content: 'I can\'t be deleted! Check my attributes with lsattr!',
                permissions: '0644'
            };
            const home = getNode('/home/ghost');
            if (home && home.type === 'dir' && !home.children.includes('delete_me.txt')) {
                home.children.push('delete_me.txt');
            }
            // Set Immutable Attribute
            FILE_ATTRIBUTES['/home/ghost/delete_me.txt'] = ['i'];
        }
    }

    // Cycle 255 Init (The Process Trace)
    if (!VFS['/home/ghost/trace_alert.log']) {
        VFS['/home/ghost/trace_alert.log'] = {
            type: 'file',
            content: '[ALERT] Mystery process failing silently.\\n[ANALYSIS] Binary /usr/bin/mystery_process exits immediately.\\n[ACTION] Use "strace" to trace system calls and find missing resources.'
        };
        const home = getNode('/home/ghost');
        if (home && home.type === 'dir' && !home.children.includes('trace_alert.log')) {
            home.children.push('trace_alert.log');
        }

        if (!VFS['/usr/bin/mystery_process']) {
            VFS['/usr/bin/mystery_process'] = {
                type: 'file',
                content: '[BINARY_ELF_X86_64] [MYSTERY_V1]\\n[STATUS] CORRUPTED config path.\\n',
                permissions: '0755'
            };
            const bin = getNode('/usr/bin');
            if (bin && bin.type === 'dir' && !bin.children.includes('mystery_process')) {
                bin.children.push('mystery_process');
            }
        }
    }
};

export const processCommand = (cwd: string, commandLine: string, stdin?: string): CommandResult => {
// Legacy export for compatibility
// export const execute = processCommand;
  const cmdTokens = commandLine.trim().split(/\s+/);
  const cmdBase = cmdTokens[0];

  // Cycle 255 Init Moved to loadSystemState

 // Legacy blocks removed for Cycle 255


  // Cycle 275 (The Kernel Module)
  if (cmdBase === 'interface_uplink' || cmdBase === './interface_uplink' || cmdBase === '/usr/bin/interface_uplink') {
       if (LOADED_MODULES.includes('uplink')) {
            if (!VFS['/var/run/uplink_solved']) {
                VFS['/var/run/uplink_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('uplink_solved')) {
                    runDir.children.push('uplink_solved');
                }
                return { output: `[INTERFACE] Initializing...\n[KERNEL] Module 'uplink' detected.\n[SUCCESS] Interface Active.\nFLAG: GHOST_ROOT{K3RN3L_M0DUL3_L0AD3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: UPLINK ESTABLISHED.\x1b[0m`, newCwd: cwd };
            }
            return { output: `[INTERFACE] Initializing...\n[KERNEL] Module 'uplink' detected.\n[SUCCESS] Interface Active.\nFLAG: GHOST_ROOT{K3RN3L_M0DUL3_L0AD3D}`, newCwd: cwd };
       } else {
            return { output: `[ERROR] Interface initialization failed.\n[REASON] Kernel module 'uplink' not loaded.\n[DIAGNOSTIC] Device /dev/uplink0 missing.\n[ACTION] Load the required kernel module.`, newCwd: cwd };
       }
  }

  if (cmdBase === 'lsmod') {
       if (LOADED_MODULES.length === 0) {
           return { output: 'Module                  Size  Used by', newCwd: cwd };
       }
       let out = 'Module                  Size  Used by\n';
       LOADED_MODULES.forEach(m => {
           out += `${m.padEnd(24)} 16384  0\n`;
       });
       return { output: out.trim(), newCwd: cwd };
  }

  if (cmdBase === 'rmmod') {
       const args = cmdTokens.slice(1);
       if (args.length === 0) return { output: 'Usage: rmmod <modulename>', newCwd: cwd };
       const idx = LOADED_MODULES.indexOf(args[0]);
       if (idx !== -1) {
           LOADED_MODULES.splice(idx, 1);
           return { output: '', newCwd: cwd };
       }
       return { output: `rmmod: ERROR: Module ${args[0]} is not currently loaded`, newCwd: cwd };
  }

  if (cmdBase === 'insmod') {
       const args = cmdTokens.slice(1);
       if (args.length === 0) return { output: 'Usage: insmod <filename> [args]', newCwd: cwd };
       const targetPath = resolvePath(cwd, args[0]);
       const node = getNode(targetPath);
       
       if (!node) return { output: `insmod: ERROR: could not insert module ${args[0]}: No such file or directory`, newCwd: cwd };
       if (node.type !== 'file') return { output: `insmod: ERROR: could not insert module ${args[0]}: Not a file`, newCwd: cwd };
       
       // Extract module name from filename (e.g. uplink.ko -> uplink)
       const filename = args[0].split('/').pop() || '';
       const modName = filename.replace('.ko', '');
       
       if (!LOADED_MODULES.includes(modName)) {
           LOADED_MODULES.push(modName);
       }
       return { output: '', newCwd: cwd };
  }

  if (cmdBase === 'modprobe') {
      const args = cmdTokens.slice(1);
      if (args.length === 0) return { output: 'Usage: modprobe <modulename> [args]', newCwd: cwd };
      const modName = args[0];
      
      // Simulate module loading if it exists in expected paths
      // For now, only 'uplink' exists in /lib/modules/...
      if (modName === 'uplink') {
           if (!LOADED_MODULES.includes('uplink')) {
               LOADED_MODULES.push('uplink');
           }
           return { output: '', newCwd: cwd };
      }
      return { output: `modprobe: FATAL: Module ${modName} not found in directory /lib/modules/5.15.0-ghost`, newCwd: cwd };
  }

  // Cycle 274 (The System Time)
  if (cmdBase === 'secure_connect' || cmdBase === './secure_connect' || cmdBase === '/usr/bin/secure_connect') {
      if (SYSTEM_TIME_OFFSET === 0) {
          if (!VFS['/var/run/time_solved']) {
              VFS['/var/run/time_solved'] = { type: 'file', content: 'TRUE' };
              const runDir = getNode('/var/run');
              if (runDir && runDir.type === 'dir' && !runDir.children.includes('time_solved')) {
                  runDir.children.push('time_solved');
              }
              return { output: `[SECURE_UPLINK] Initializing...\n[CHECK] Clock synchronized.\n[SUCCESS] Connection established.\nFLAG: GHOST_ROOT{NTP_T1M3_SYC_C0MPL3T3}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: CLOCK SYNCHRONIZED.\x1b[0m`, newCwd: cwd };
          }
          return { output: `[SECURE_UPLINK] Initializing...\n[CHECK] Clock synchronized.\n[SUCCESS] Connection established.\nFLAG: GHOST_ROOT{NTP_T1M3_SYC_C0MPL3T3}`, newCwd: cwd };
      } else {
          return { output: `[ERROR] Secure connection failed.\n[REASON] Clock skew detected.\n[DIAGNOSTIC] System time is out of sync with server (offset ${Math.abs(SYSTEM_TIME_OFFSET)/1000}s).\n[ACTION] Update system time using ntpdate.`, newCwd: cwd };
      }
  }

  // Cycle 270 (The Env Variable)
  if (cmdBase === 'secure_start' || cmdBase === './secure_start' || cmdBase === '/usr/local/bin/secure_start') {
       if (ENV_VARS['SECURE_TOKEN'] === 'SECURE_TOKEN_V1') {
            if (!VFS['/var/run/env_solved']) {
                VFS['/var/run/env_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('env_solved')) {
                    runDir.children.push('env_solved');
                }
                return { output: `[SECURE_START] Initializing...\n[CHECK] Token Verified.\n[SUCCESS] System unlocked.\nFLAG: GHOST_ROOT{3NV_V4R_D3C0D3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ENVIRONMENT CONFIGURED.\x1b[0m`, newCwd: cwd };
            }
            return { output: `[SECURE_START] Initializing...\n[CHECK] Token Verified.\n[SUCCESS] System unlocked.\nFLAG: GHOST_ROOT{3NV_V4R_D3C0D3D}`, newCwd: cwd };
       } else {
            return { output: `[ERROR] Secure Start failed.\n[REASON] Invalid or missing SECURE_TOKEN.\n[DIAGNOSTIC] Current Value: ${ENV_VARS['SECURE_TOKEN'] || '(null)'}`, newCwd: cwd };
       }
  }

  // Cycle 263 (The Stale Lock)
  if (cmdBase === 'start-reactor' || cmdBase === './start-reactor' || cmdBase === '/usr/local/bin/start-reactor') {
        const lockPath = '/var/run/reactor.lock';
        if (VFS[lockPath]) {
             return { output: `[ERROR] Reactor startup failed.\n[FATAL] Lock file found: ${lockPath}\n[PID] 1337 (Stale?)\n[ACTION] Remove the lock file if the process is not running.`, newCwd: cwd };
        } else {
             if (!VFS['/var/run/reactor_solved']) {
                 VFS['/var/run/reactor_solved'] = { type: 'file', content: 'TRUE' };
                 // Ensure directory exists
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('reactor_solved')) {
                     runDir.children.push('reactor_solved');
                 }
                 return { output: `[REACTOR] Initializing core sequence...\n[CHECK] Lock file cleared.\n[SUCCESS] Reactor Online.\nFLAG: GHOST_ROOT{L0CKF1L3_R3M0V3D_S4F3LY}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: STALE LOCK REMOVED.\x1b[0m`, newCwd: cwd };
             }
             return { output: `[REACTOR] Initializing core sequence...\n[CHECK] Lock file cleared.\n[SUCCESS] Reactor Online.\nFLAG: GHOST_ROOT{L0CKF1L3_R3M0V3D_S4F3LY}`, newCwd: cwd };
        }
  }

  // Cycle 264 (The Listen Port)
  if (!VFS['/home/ghost/port_alert.txt']) {
      VFS['/home/ghost/port_alert.txt'] = {
          type: 'file',
          content: '[ALERT] Unauthorized service detected.\n[ANALYSIS] A rogue process is listening on a high port.\n[ACTION] Use "netstat" to identify the PID and "kill" it.'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('port_alert.txt')) {
          home.children.push('port_alert.txt');
      }
      // Binary
      if (!VFS['/usr/bin/hidden_listener']) {
          VFS['/usr/bin/hidden_listener'] = {
              type: 'file',
              content: '[BINARY_ELF_X86_64] [LISTENER_V2]\n[PORT] 5050\n[STATUS] LISTENING...',
              permissions: '0755'
          };
          const bin = getNode('/usr/bin');
          if (bin && bin.type === 'dir' && !bin.children.includes('hidden_listener')) {
              bin.children.push('hidden_listener');
          }
      }
  }

  // Cycle 265 Init (The DNS Poisoning)
  if (!VFS['/home/ghost/dns_alert.txt']) {
      VFS['/home/ghost/dns_alert.txt'] = {
          type: 'file',
          content: '[ALERT] Connection to secure.corp failed.\\n[DIAGNOSTIC] Host "secure.corp" not found.\\n[ACTION] Add a manual entry to /etc/hosts mapping secure.corp to 127.0.0.1.\\n[Target IP] 127.0.0.1'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('dns_alert.txt')) {
          home.children.push('dns_alert.txt');
      }

      // Ensure /etc/hosts exists
      if (!VFS['/etc/hosts']) {
           if (!VFS['/etc']) {
               VFS['/etc'] = { type: 'dir', children: ['hosts'] };
               const root = getNode('/');
               if (root && root.type === 'dir' && !root.children.includes('etc')) root.children.push('etc');
           }
           VFS['/etc/hosts'] = {
               type: 'file',
               content: '127.0.0.1\\tlocalhost\\n::1\\tlocalhost ip6-localhost ip6-loopback\\n',
               permissions: '0644'
           };
           const etc = getNode('/etc');
           if (etc && etc.type === 'dir' && !etc.children.includes('hosts')) etc.children.push('hosts');
      }

      // Binary
      if (!VFS['/usr/bin/connect_secure']) {
          VFS['/usr/bin/connect_secure'] = {
              type: 'file',
              content: '[BINARY_ELF_X86_64] [SECURE_CLIENT]\\n[TARGET] secure.corp\\n[PORT] 443\\n',
              permissions: '0755'
          };
          const bin = getNode('/usr/bin');
          if (bin && bin.type === 'dir' && !bin.children.includes('connect_secure')) {
              bin.children.push('connect_secure');
          }
      }
  }

  // Cycle 265 Command (The DNS Poisoning)
  if (cmdBase === 'connect_secure' || cmdBase === '/usr/bin/connect_secure' || cmdBase === './connect_secure') {
      const hosts = VFS['/etc/hosts'];
      if (hosts && hosts.type === 'file') {
          const content = hosts.content;
          if (/127\\.0\\.0\\.1\\s+secure\\.corp/.test(content)) {
               if (!VFS['/var/run/cycle265_solved']) {
                   VFS['/var/run/cycle265_solved'] = { type: 'file', content: 'TRUE' };
                   const runDir = getNode('/var/run');
                   if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle265_solved')) {
                       runDir.children.push('cycle265_solved');
                   }
                   return { output: '[SECURE] Resolving secure.corp...\\n[DNS] 127.0.0.1 (Local Override)\\n[CONN] Handshake Successful.\\n[SUCCESS] Uplink Established.\\nFLAG: GHOST_ROOT{ETC_H0STS_P01S0N_OK}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: DNS OVERRIDE ACTIVE.\\x1b[0m', newCwd: cwd };
               }
               return { output: '[SECURE] Connection Established.\\nFLAG: GHOST_ROOT{ETC_H0STS_P01S0N_OK}', newCwd: cwd };
          }
      }
      return { output: '[SECURE] Resolving secure.corp...\\n[ERROR] Host not found.\\n[HINT] Update local DNS configuration.', newCwd: cwd };
  }

  // Cycle 255 (The Process Trace)
  if (cmdBase === 'mystery_process' || cmdBase === './mystery_process' || cmdBase === '/usr/bin/mystery_process') {
       const configFile = VFS['/tmp/secret_config.dat'];
       if (configFile && configFile.type === 'file' && configFile.content.length > 0) {
            let out = 'FLAG: GHOST_ROOT{STR4C3_R3V34LS_H1DD3N_P4THS}';
            if (!VFS['/var/run/cycle255_solved']) {
                VFS['/var/run/cycle255_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle255_solved')) {
                    runDir.children.push('cycle255_solved');
                }
                out += '\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM CALL TRACED.\\x1b[0m';
            }
            return { output: out, newCwd: cwd };
       }
       return { output: '', newCwd: cwd };
  }

  if (cmdBase === 'strace' || cmdBase === '/usr/bin/strace') {
       const args = commandLine.trim().split(/\s+/).slice(1);
       if (args.length === 0) return { output: 'strace: must have PROG [ARGS] or -p PID', newCwd: cwd };

       const target = args[0];
       const targetCmd = args.join(' ');
       
       if (target === 'mystery_process' || target === './mystery_process' || target === '/usr/bin/mystery_process') {
            let out = 'execve("/usr/bin/mystery_process", ["mystery_process"], 0x7ffd5d36e050 /* 22 vars */) = 0\\n';
            out += 'brk(NULL)                               = 0x559d70df8000\\n';
            out += 'getpid()                                = 1337\\n';
            out += 'getuid()                                = 1000\\n';
            out += 'access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)\\n';
            out += 'openat(AT_FDCWD, "/usr/lib/libc.so.6", O_RDONLY|O_CLOEXEC) = 3\\n';
            out += 'read(3, "\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\20\\35\\2\\0\\0\\0\\0\\0"..., 832) = 832\\n';
            out += 'fstat(3, {st_mode=S_IFREG|0755, st_size=2029592, ...}) = 0\\n';
            out += 'mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0a1b2c3000\\n';
            out += 'close(3)                                = 0\\n';
            out += 'arch_prctl(ARCH_SET_FS, 0x7f0a1b2c3000) = 0\\n';
            out += 'mprotect(0x7f0a1b2c3000, 16384, PROT_READ) = 0\\n';

            // Realistic config search path
            out += 'stat("/etc/mystery.conf", 0x7ffd...) = -1 ENOENT (No such file or directory)\\n';
            out += 'stat("/home/ghost/.config/mystery/config", 0x7ffd...) = -1 ENOENT (No such file or directory)\\n';

            const configFile = VFS['/tmp/secret_config.dat'];
            if (configFile && configFile.type === 'file') {
                out += 'stat("/tmp/secret_config.dat", {st_mode=S_IFREG|0644, st_size=16, ...}) = 0\\n';
                out += 'openat(AT_FDCWD, "/tmp/secret_config.dat", O_RDONLY) = 3\\n';
                out += 'fstat(3, {st_mode=S_IFREG|0644, st_size=16, ...}) = 0\\n';
                
                const contentSnippet = configFile.content.substring(0, 16).replace(/\\n/g, '\\\\n');
                out += `read(3, "${contentSnippet}", 1024) = ${configFile.content.length}\\n`;
                out += 'close(3)                                = 0\\n';

                if (configFile.content.length > 0) {
                    out += 'write(1, "FLAG: GHOST_ROOT{STR4C3_R3V34LS_H1DD3N_P4THS}\\n", 47) = 47\\n';
                    out += 'exit_group(0)                           = ?\\n';
                    out += '+++ exited with 0 +++';

                    if (!VFS['/var/run/cycle255_solved']) {
                        VFS['/var/run/cycle255_solved'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle255_solved')) {
                            runDir.children.push('cycle255_solved');
                        }
                        out += '\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM CALL TRACED.\\x1b[0m';
                    }
                } else {
                     out += 'exit_group(1)                           = ?\\n';
                     out += '+++ exited with 1 +++';
                }
            } else {
                out += 'stat("/tmp/secret_config.dat", 0x7ffd...) = -1 ENOENT (No such file or directory)\\n';
                out += 'openat(AT_FDCWD, "/tmp/secret_config.dat", O_RDONLY) = -1 ENOENT (No such file or directory)\\n';
                out += 'exit_group(1)                           = ?\\n';
                out += '+++ exited with 1 +++';
            }
            return { output: out, newCwd: cwd };
       }
       
       // Generic Trace
       if (target === 'strace') return { output: 'strace: ptrace(PTRACE_TRACEME, ...): Operation not permitted', newCwd: cwd };
       
       let out = `execve("${target}", ["${target}"], 0x7ffd...) = 0\\n`;
       out += 'brk(NULL)                               = 0x559d...\\n';
       out += 'access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)\\n';
       
       // We skip actual execution trace for safety/complexity, just wrap simulated success
       out += `write(1, "[${target} output simulated...]\\n", 30) = 30\\n`;
       out += 'exit_group(0)                           = ?\\n';
       out += '+++ exited with 0 +++';
       
       return { output: out, newCwd: cwd };
  }

  // Cycle 249 Init (The Disk Hog)
  if (!VFS['/home/ghost/disk_space_alert.txt']) {
      VFS['/home/ghost/disk_space_alert.txt'] = {
          type: 'file',
          content: '[ALERT] ROOT PARTITION FULL (100%)\n[CRITICAL] System stability compromised.\n[ANALYSIS] A log file in /var/log/nginx has grown to 500MB.\n[ACTION] Locate the file using "du" and delete it.'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('disk_space_alert.txt')) {
          home.children.push('disk_space_alert.txt');
      }
      
      // Ensure /var/log/nginx exists
      if (!VFS['/var/log/nginx']) {
           if (!VFS['/var/log']) {
               VFS['/var/log'] = { type: 'dir', children: ['nginx'] };
               const v = getNode('/var');
               if (v && v.type === 'dir' && !v.children.includes('log')) v.children.push('log');
           } else {
               VFS['/var/log/nginx'] = { type: 'dir', children: [] };
               const l = getNode('/var/log');
               if (l && l.type === 'dir' && !l.children.includes('nginx')) l.children.push('nginx');
           }
      }
      
      // The Hog File
      VFS['/var/log/nginx/error.log.1'] = {
          type: 'file',
          content: '[ERROR_DUMP] ... [500MB_JUNK_DATA] ...',
          permissions: '0644'
      };
      const n = getNode('/var/log/nginx');
      if (n && n.type === 'dir' && !n.children.includes('error.log.1')) n.children.push('error.log.1');
  }

  // Cycle 251 (The Scheduled Task)
  if (cmdBase === 'maintenance.sh' || cmdBase === './maintenance.sh' || cmdBase === '/usr/local/bin/maintenance.sh') {
      if (commandLine.includes('--force-override')) {
           if (!VFS['/var/run/cycle251_solved']) {
               VFS['/var/run/cycle251_solved'] = { type: 'file', content: 'TRUE' };
               // Ensure directory exists
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle251_solved')) {
                   runDir.children.push('cycle251_solved');
               }
               return { output: '[SYSTEM] Maintenance Protocol Initiated...\\n[CHECK] Verifying Override... OK.\\n[SUCCESS] System Optimized.\\nFLAG: GHOST_ROOT{CR0N_F0RC3_SUCC3SS}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: SCHEDULED TASK EXECUTED.\\x1b[0m', newCwd: cwd };
           }
           return { output: '[SYSTEM] System Optimized.\\nFLAG: GHOST_ROOT{CR0N_F0RC3_SUCC3SS}', newCwd: cwd };
      } else {
           return { output: '[ERROR] Manual execution denied.\\nThis script is managed by crontab.\\n(Hint: Check /etc/crontab for the correct flags)', newCwd: cwd };
      }
  }

  // Cycle 252 (The Archive Recovery)
  if (cmdBase === 'tar' || cmdBase === '/bin/tar') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      
      // Check for extraction flags (-x, -z, -f)
      const hasExtract = args.some(a => a.includes('x'));
      const hasGzip = args.some(a => a.includes('z'));
      const hasFile = args.some(a => a.includes('f'));
      
      if (!hasExtract || !hasFile) {
          return { output: 'tar: usage: tar -xzf <archive.tar.gz>', newCwd: cwd };
      }
      
      // Find the filename argument (usually after -f or as a standalone arg ending in .tar.gz)
      const fileArg = args.find(a => a.endsWith('.tar.gz'));
      
      if (!fileArg) {
          return { output: 'tar: Refusing to read archive contents from terminal (missing filename)', newCwd: cwd };
      }
      
      const fullPath = resolvePath(cwd, fileArg);
      
      if (fullPath !== '/var/backups/project_titan.tar.gz') {
           return { output: `tar: ${fileArg}: Cannot open: No such file or directory`, newCwd: cwd };
      }
      
      // Success case
      if (!VFS['/var/run/cycle252_solved']) {
           VFS['/var/run/cycle252_solved'] = { type: 'file', content: 'TRUE' };
           
           // "Extract" the file
           VFS['/var/backups/blueprint.txt'] = {
               type: 'file',
               content: '[BLUEPRINT] TITAN_MECH_V1\\n[STATUS] CONFIDENTIAL\\n[KEY] GHOST_ROOT{T4R_GZ_EXTR4CT10N_SUCC3SS}',
               permissions: '0644'
           };
           const dir = getNode('/var/backups');
           if (dir && dir.type === 'dir' && !dir.children.includes('blueprint.txt')) {
               dir.children.push('blueprint.txt');
           }

           return { output: 'project_titan.tar.gz: extracting...\\nblueprint.txt\\n[SUCCESS] Archive extracted.\\nFLAG: GHOST_ROOT{T4R_GZ_EXTR4CT10N_SUCC3SS}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: ARCHIVE RECOVERED.\\x1b[0m', newCwd: cwd };
      }
      return { output: 'project_titan.tar.gz: extracting...\\nblueprint.txt\\n[SUCCESS] Archive extracted.\\nFLAG: GHOST_ROOT{T4R_GZ_EXTR4CT10N_SUCC3SS}', newCwd: cwd };
  }

  // Cycle 237 (The Environment Key)
  if (cmdBase === 'fusion_core' || cmdBase === '/usr/local/bin/fusion_core' || (cwd === '/usr/local/bin' && cmdBase === './fusion_core')) {
      if (ENV_VARS['FUSION_KEY'] === 'GHOST-7-OMEGA') {
           return { output: '[FUSION_CORE] Verifying Key... [OK]\\n[SYSTEM] Magnetic Confinement Field: ENGAGED.\\n[SYSTEM] Core Temperature: STABLE (15M Kelvin).\\n[SUCCESS] Meltdown averted.\\nFLAG: GHOST_ROOT{3NV_V4R_M4ST3RY_X9}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: FUSION CORE STABILIZED.\\x1b[0m', newCwd: cwd };
      } else {
           return { output: '[FUSION_CORE] ERROR: SECURITY_KEY_MISSING or INVALID.\\n[SYSTEM] Access Denied.\\n[HINT] The environment variable FUSION_KEY must be set correctly. Consult the manual in ~/manuals.', newCwd: cwd };
      }
  }

  // Cycle 241 (The Corrupted Rescue)
  if (cmdBase === 'rescue_mission.sh' || cmdBase === './rescue_mission.sh' || cmdBase === '/usr/local/bin/rescue_mission.sh') {
       return { output: '[SYSTEM] Locating stranded assets...\\n./rescue_mission.sh: line 5: syntax error near unexpected token `\\x00\'\\n./rescue_mission.sh: line 5: `\\x00\\x00\\xDEAD\\xBEEF\'', newCwd: cwd };
  }

  if (cmdBase === 'rescue_pod' || cmdBase === './rescue_pod' || cmdBase === '/usr/local/bin/rescue_pod') {
       if (ENV_VARS['RESCUE_CODE'] === 'ALPHA-TANGO-7') {
           if (!VFS['/var/run/cycle241_solved']) {
               VFS['/var/run/cycle241_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[POD] Code Verified: ALPHA-TANGO-7\\n[POD] Launch Sequence Initiated...\\n[SUCCESS] Assets Recovered.\\nFLAG: GHOST_ROOT{SCR1PT_D3BUG_OV3RR1D3}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: RESCUE SUCCESSFUL.\\x1b[0m', newCwd: cwd };
           }
           return { output: '[POD] Code Verified: ALPHA-TANGO-7\\n[POD] Assets Recovered.\\nFLAG: GHOST_ROOT{SCR1PT_D3BUG_OV3RR1D3}', newCwd: cwd };
       } else {
           return { output: '[POD] ERROR: UNAUTHORIZED LAUNCH ATTEMPT.\\n[POD] Rescue Code Required.\\n[HINT] Check mission parameters.', newCwd: cwd };
       }
  }

  // Cycle 236 (The Log Rotation)
  if (!VFS['/home/ghost/log_alert.txt']) {
      VFS['/home/ghost/log_alert.txt'] = {
          type: 'file',
          content: '[ALERT] Disk usage critical (98%).\n[ANALYSIS] Nginx logs are growing uncontrollably.\n[ACTION] Force a log rotation immediately.\n[HINT] Use "logrotate -f /etc/logrotate.conf".'
      };
      
      // Ensure /var/log/nginx exists
      if (!VFS['/var/log/nginx']) {
           if (!VFS['/var/log']) {
               VFS['/var/log'] = { type: 'dir', children: ['nginx'] };
               const v = getNode('/var');
               if (v && v.type === 'dir' && !v.children.includes('log')) v.children.push('log');
           } else {
               VFS['/var/log/nginx'] = { type: 'dir', children: [] };
               const l = getNode('/var/log');
               if (l && l.type === 'dir' && !l.children.includes('nginx')) l.children.push('nginx');
           }
      }
      
      VFS['/var/log/nginx/access.log'] = {
          type: 'file',
          content: '[LOG_DATA_START] ... [5GB_DATA] ... [LOG_DATA_END]',
          permissions: '0640'
      };
      const n = getNode('/var/log/nginx');
      if (n && n.type === 'dir' && !n.children.includes('access.log')) n.children.push('access.log');

      // Ensure /etc/logrotate.conf exists
      if (!VFS['/etc/logrotate.conf']) {
           if (!VFS['/etc']) {
               VFS['/etc'] = { type: 'dir', children: ['logrotate.conf'] };
               const r = getNode('/');
               if (r && r.type === 'dir' && !r.children.includes('etc')) r.children.push('etc');
           }
           VFS['/etc/logrotate.conf'] = {
               type: 'file',
               content: '/var/log/nginx/*.log {\\n    rotate 7\\n    daily\\n    compress\\n    missingok\\n    notifempty\\n}',
               permissions: '0644'
           };
           const e = getNode('/etc');
           if (e && e.type === 'dir' && !e.children.includes('logrotate.conf')) e.children.push('logrotate.conf');
      }
  }

  // Cycle 236 Command Logic
  if (cmdBase === 'logrotate' || cmdBase === '/usr/sbin/logrotate') {
       if (commandLine.includes('-f') && commandLine.includes('/etc/logrotate.conf')) {
           if (!VFS['/var/run/cycle236_solved']) {
               VFS['/var/run/cycle236_solved'] = { type: 'file', content: 'TRUE' };
               // Compress the log mock
               VFS['/var/log/nginx/access.log.1.gz'] = { type: 'file', content: '[COMPRESSED_DATA]', permissions: '0640' };
               VFS['/var/log/nginx/access.log'] = { type: 'file', content: '', permissions: '0640' }; // Empty it
               
               return { output: 'reading config file /etc/logrotate.conf\\nAllocating hash table for state file, size 15360 B\\nHandling 1 logs\\nrotating pattern: /var/log/nginx/*.log  forced from command line (7 rotations)\\ncompressing log with: /bin/gzip\\n[SUCCESS] Logs rotated.\\nFLAG: GHOST_ROOT{L0G_R0T4T3_SAV3S_D1SK}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: DISK SPACE CLEARED.\\x1b[0m', newCwd: cwd };
           }
           return { output: 'reading config file /etc/logrotate.conf\\n[SUCCESS] Logs already rotated.\\nFLAG: GHOST_ROOT{L0G_R0T4T3_SAV3S_D1SK}', newCwd: cwd };
       } else {
           return { output: 'logrotate: usage: logrotate [-f] <config_file>', newCwd: cwd };
       }
  }

  // Cycle 235 (The Hidden Dotfile)
  if (cmdBase === './launch_sequence.sh' || cmdBase === 'launch_sequence.sh') {
      const isCorrectDir = cwd === '/home/ghost/project_omega';
      if (!isCorrectDir) {
          return { output: 'bash: launch_sequence.sh: No such file or directory', newCwd: cwd };
      }
      
      const configPath = '/home/ghost/project_omega/.omega_config';
      
      if (VFS[configPath]) {
           if (!VFS['/var/run/cycle235_solved']) {
               VFS['/var/run/cycle235_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[SYSTEM] Initializing launch sequence...\\n[SUCCESS] Configuration loaded.\\nFLAG: GHOST_ROOT{M0V3_C0NF1G_B4K}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: CONFIG RESTORED.\\x1b[0m', newCwd: cwd };
           }
           return { output: '[SYSTEM] Initializing launch sequence...\\n[SUCCESS] Configuration loaded.\\nFLAG: GHOST_ROOT{M0V3_C0NF1G_B4K}', newCwd: cwd };
      } else {
           return { output: '[SYSTEM] Initializing launch sequence...\\n[ERROR] Configuration file .omega_config not found.\\n[HINT] Check for backups (ls -a).', newCwd: cwd };
      }
  }

  // Cycle 218 (The Identity Theft)
  if (cmdBase === 'ssh_target' || cmdBase === '/usr/bin/ssh_target') {
       const keyPath = '/home/ghost/.ssh/target_id_rsa';
       const keyNode = VFS[keyPath];

       if (!keyNode) {
           return { output: 'ssh_target: Identity file ~/.ssh/target_id_rsa not found.\n[FAILED] Connection terminated.', newCwd: cwd };
       }

       // Check permissions (must be 600 or 400)
       const perms = (keyNode as any).permissions || '0644';
       if (perms !== '0600' && perms !== '0400') {
           return { output: `@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nPermissions ${perms} for '${keyPath}' are too open.\nIt is required that your private key files are NOT accessible by others.\nLoad key "${keyPath}": bad permissions\nssh_target: Permission denied (publickey).`, newCwd: cwd };
       }

       if (!VFS['/var/run/cycle218_solved']) {
           VFS['/var/run/cycle218_solved'] = { type: 'file', content: 'TRUE' };
           return { output: '[SSH] Identity accepted.\n[SSH] Authenticating to target_host...\n[SUCCESS] Channel Open.\nFLAG: GHOST_ROOT{SSH_K3Y_P3RM1SS10NS_F1X3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SECURE UPLINK ESTABLISHED.\x1b[0m', newCwd: cwd };
       }
       return { output: '[SSH] Channel Open.\nFLAG: GHOST_ROOT{SSH_K3Y_P3RM1SS10NS_F1X3D}', newCwd: cwd };
  }

  // Cycle 233 Command Logic (The Pipeline)
  if (cmdBase === 'firewall_block' || cmdBase === '/usr/bin/firewall_block') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args.length === 0) {
          return { output: 'Usage: firewall_block <IP_ADDRESS>', newCwd: cwd };
      }
      
      const targetIP = '10.10.10.10';
      
      if (args[0] === targetIP) {
           if (!VFS['/var/run/cycle233_solved']) {
               VFS['/var/run/cycle233_solved'] = { type: 'file', content: 'TRUE' };
               return { output: `[FIREWALL] Blocking IP ${args[0]}...\n[SUCCESS] Rule added.\n[ATTACK] Mitigated.\nFLAG: GHOST_ROOT{P1P3L1N3_M4ST3R_GR3P_S0RT_UN1Q}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ATTACK BLOCKED.\x1b[0m`, newCwd: cwd };
           }
           return { output: `[FIREWALL] IP ${args[0]} is already blocked.\nFLAG: GHOST_ROOT{P1P3L1N3_M4ST3R_GR3P_S0RT_UN1Q}`, newCwd: cwd };
      } else {
           return { output: `[FIREWALL] Blocking IP ${args[0]}...\n[ERROR] Attack continues. Wrong target.`, newCwd: cwd };
      }
  }

  // Cycle 215 Command Logic (sat_link)
  if (cmdBase === 'sat_link' || cmdBase === './sat_link') {
      const hostsFile = VFS['/etc/hosts']; // Access directly as getNode might be circular dep or utility
      // Actually getNode is available in scope.
      // But verify content logic.
      if (hostsFile && hostsFile.type === 'file' && hostsFile.content.includes('mothership.internal') && hostsFile.content.includes('10.0.0.5')) {
          if (!VFS['/var/run/cycle215_solved']) {
               VFS['/var/run/cycle215_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[UPLINK] Resolving mothership.internal... 10.0.0.5\n[CONN] Handshake Successful.\n[DATA] Downloading Payload...\nFLAG: GHOST_ROOT{H0STS_F1L3_0V3RR1D3}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SATELLITE LINK ESTABLISHED.\x1b[0m', newCwd: cwd };
          }
          return { output: '[UPLINK] Connected.\nFLAG: GHOST_ROOT{H0STS_F1L3_0V3RR1D3}', newCwd: cwd };
      } else {
          return { output: 'sat_link: error: could not resolve "mothership.internal": Name or service not known', newCwd: cwd };
      }
  }

  // Cycle 208 Init (The Network Socket)
  if (!VFS['/home/ghost/socket_alert.log']) {
      VFS['/home/ghost/socket_alert.log'] = {
          type: 'file',
          content: '[ALERT] Unknown process listening on local loopback.\n[ACTION] Identify the port (netstat) and connect (nc) to interrogate.\n[NOTE] Process ID 6000.'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('socket_alert.log')) {
          home.children.push('socket_alert.log');
      }
      // Ensure binary exists for appearances
      if (!VFS['/usr/bin/net_service']) {
          VFS['/usr/bin/net_service'] = {
              type: 'file',
              content: '[BINARY_ELF_X86_64] [HIDDEN_LISTENER]\n[PORT] 31337\n[STATUS] Active',
              permissions: '0700'
          };
          const binDir = getNode('/usr/bin');
          if (binDir && binDir.type === 'dir' && !binDir.children.includes('net_service')) {
              binDir.children.push('net_service');
          }
      }
      // Add fake process to process list
      const netProc = PROCESSES.find(p => p.pid === 6000);
      if (!netProc) {
          PROCESSES.push({
              pid: 6000,
              ppid: 1,
              user: 'ghost',
              cpu: 0.1,
              mem: 1.0,
              time: '0:05',
              command: '/usr/bin/net_service',
              tty: '?',
              stat: 'Ss'
          });
      }
  }

  // Cycle 209 Init (The Leaky Cron)
  if (!VFS['/home/ghost/automation_alert.txt']) {
      // 1. Hint
      VFS['/home/ghost/automation_alert.txt'] = {
          type: 'file',
          content: '[ALERT] Suspicious automated activity detected.\n[ANALYSIS] A background job is failing repeatedly.\n[ACTION] Check scheduled tasks (crontab -l) and investigate output logs.'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('automation_alert.txt')) {
          home.children.push('automation_alert.txt');
      }

      // 2. The Script
      if (!VFS['/opt/scripts/daily_sync.sh']) {
          if (!VFS['/opt']) VFS['/opt'] = { type: 'dir', children: ['scripts'] };
          else if (VFS['/opt'].type === 'dir' && !(VFS['/opt'] as any).children) (VFS['/opt'] as any).children = []; // Safety
          
          if (!VFS['/opt/scripts']) {
               VFS['/opt/scripts'] = { type: 'dir', children: [] };
               const opt = getNode('/opt');
               if (opt && opt.type === 'dir' && !opt.children.includes('scripts')) opt.children.push('scripts');
          }
          
          VFS['/opt/scripts/daily_sync.sh'] = {
              type: 'file',
              content: '#!/bin/bash\n# AUTO SYNC V2\n# Syncs data to backup server.\n\necho "[INFO] Starting sync..."\n# Credentials loaded from env or args\n./sync_tool --api-key $API_KEY\n',
              permissions: '0700'
          };
          const scripts = getNode('/opt/scripts');
          if (scripts && scripts.type === 'dir' && !scripts.children.includes('daily_sync.sh')) {
              scripts.children.push('daily_sync.sh');
          }
      }

      // 3. The Log Directory
      if (!VFS['/var/log/cron']) {
           if (!VFS['/var/log']) {
                VFS['/var/log'] = { type: 'dir', children: ['cron'] };
                const v = getNode('/var');
                if (v && v.type === 'dir' && !v.children.includes('log')) v.children.push('log');
           }
           else {
               VFS['/var/log/cron'] = { type: 'dir', children: [] };
               const varLog = getNode('/var/log');
               if (varLog && varLog.type === 'dir' && !varLog.children.includes('cron')) varLog.children.push('cron');
           }
      }

      // 4. The Log File
      VFS['/var/log/cron/sync_error.log'] = {
          type: 'file',
          content: '[ERROR] Backup failed.\n[TIMESTAMP] 2026-02-16 08:30:00\n[TARGET] 192.168.1.50\n[AUTH] API_KEY="XJ-99-DELTA-FORCE"\n[STATUS] Connection Refused.\n',
          permissions: '0640'
      };
      const cronLog = getNode('/var/log/cron');
      if (cronLog && cronLog.type === 'dir' && !cronLog.children.includes('sync_error.log')) {
          cronLog.children.push('sync_error.log');
      }

      // 5. The Crontab (Force Update/Recreate)
      if (!VFS['/var/spool/cron/crontabs/root']) {
           if (!VFS['/var/spool/cron/crontabs']) {
               // Ensure hierarchy
               if (!VFS['/var/spool']) {
                    VFS['/var/spool'] = { type: 'dir', children: ['cron'] };
                    const v = getNode('/var');
                    if (v && v.type === 'dir' && !v.children.includes('spool')) v.children.push('spool');
               }
               if (!VFS['/var/spool/cron']) {
                    VFS['/var/spool/cron'] = { type: 'dir', children: ['crontabs'] };
                    const s = getNode('/var/spool');
                    if (s && s.type === 'dir' && !s.children.includes('cron')) s.children.push('cron');
               }
               VFS['/var/spool/cron/crontabs'] = { type: 'dir', children: [] };
               const c = getNode('/var/spool/cron');
               if (c && c.type === 'dir' && !c.children.includes('crontabs')) c.children.push('crontabs');
           }
           VFS['/var/spool/cron/crontabs/root'] = {
               type: 'file',
               content: '# SYSTEM CRONTAB\n@reboot /usr/bin/malware_init\n*/5 * * * * /opt/scripts/daily_sync.sh >> /var/log/cron/sync_error.log 2>&1\n',
               permissions: '0600'
           };
           const tabs = getNode('/var/spool/cron/crontabs');
           if (tabs && tabs.type === 'dir' && !tabs.children.includes('root')) tabs.children.push('root');
      } else {
           // Append if missing
           const node = VFS['/var/spool/cron/crontabs/root'];
           if (node.type === 'file' && !node.content.includes('daily_sync.sh')) {
               node.content += '\n*/5 * * * * /opt/scripts/daily_sync.sh >> /var/log/cron/sync_error.log 2>&1\n';
           }
      }
  }

  // Cycle 209 Command Logic (system_reset)
  if (cmdBase === 'system_reset') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args.length === 0) return { output: 'Usage: system_reset <ACCESS_CODE>', newCwd: cwd };
      
      if (args[0] === 'XJ-99-DELTA-FORCE') {
           if (!VFS['/var/run/cycle209_solved']) {
               VFS['/var/run/cycle209_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[SYSTEM] Access Code Verified.\n[RESET] System Reset Initiated...\n[SUCCESS] Anomalies Cleared.\nFLAG: GHOST_ROOT{CR0N_L0G_L34K_D3T3CT3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM RESTORED.\x1b[0m', newCwd: cwd };
           }
           return { output: '[SYSTEM] System is already stable.\nFLAG: GHOST_ROOT{CR0N_L0G_L34K_D3T3CT3D}', newCwd: cwd };
      } else {
           return { output: '[SYSTEM] Access Denied. Invalid Code.', newCwd: cwd };
      }
  }

  // Cycle 208 & 264 Command Logic (netstat)
  if (cmdBase === 'netstat') {
      // Simple mock
      let out = 'Active Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State      PID/Program name\n';
      out += 'tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      100/sshd\n';
      
      // Cycle 208
      if (!VFS['/var/run/cycle208_solved']) {
          out += 'tcp        0      0 127.0.0.1:31337         0.0.0.0:*               LISTEN      6000/net_service\n';
      }
      
      // Cycle 264
      if (!VFS['/var/run/cycle264_solved']) {
          out += 'tcp        0      0 127.0.0.1:5050          0.0.0.0:*               LISTEN      7777/hidden_listener\n';
      }

      out += 'udp        0      0 0.0.0.0:68              0.0.0.0:*                           600/dhclient\n';
      return { output: out, newCwd: cwd };
  }

  // Cycle 208 & 264 Command Logic (nc)
  if (cmdBase === 'nc') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      
      if (args.includes('localhost') || args.includes('127.0.0.1')) {
          if (args.includes('31337')) {
               if (stdin && stdin.trim() === 'AUTH_KAPPA') {
                   if (!VFS['/var/run/cycle208_solved']) {
                       VFS['/var/run/cycle208_solved'] = { type: 'file', content: 'TRUE' };
                       return { output: '[NC] Connected to localhost:31337\n[SVC] Handshake Accepted.\n[SVC] Secure Channel Open.\nFLAG: GHOST_ROOT{N3T_S0CK3T_H4NDSH4K3}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN SERVICE ACCESSED.\x1b[0m', newCwd: cwd };
                   }
                   return { output: '[NC] Connected.\nFLAG: GHOST_ROOT{N3T_S0CK3T_H4NDSH4K3}', newCwd: cwd };
               } else {
                   return { output: '[NC] Connected to localhost:31337\n[SVC] Access Denied. Protocol Mismatch.\n[HINT] Service expects "AUTH_KAPPA" on stdin.', newCwd: cwd };
               }
          }
          // Cycle 264
          if (args.includes('5050')) {
               if (VFS['/var/run/cycle264_solved']) {
                   return { output: 'nc: connect to localhost port 5050 (tcp) failed: Connection refused', newCwd: cwd };
               }
               return { output: '[NC] Connected to localhost:5050\n[SVC] UNIDENTIFIED LISTENER ACTIVE.\n[SVC] PID: 7777\n[SVC] COMMAND: /usr/bin/hidden_listener\n[SVC] STATUS: WAITING_FOR_INPUT...', newCwd: cwd };
          }
      }
      return { output: 'nc: connection refused', newCwd: cwd };
  }

  // Cycle 204 Command Logic (The Configuration Drift)
  if (cmdBase === 'diff') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args.length < 2) {
          return { output: 'diff: missing operand after \'' + (args[0] || 'diff') + '\'', newCwd: cwd };
      }
      
      const file1 = resolvePath(cwd, args[0]);
      const file2 = resolvePath(cwd, args[1]);
      
      const node1 = getNode(file1);
      const node2 = getNode(file2);
      
      if (!node1 || node1.type !== 'file') return { output: `diff: ${args[0]}: No such file or directory`, newCwd: cwd };
      if (!node2 || node2.type !== 'file') return { output: `diff: ${args[1]}: No such file or directory`, newCwd: cwd };
      
      const content1 = ((node1 as any).content || '').split('\n');
      const content2 = ((node2 as any).content || '').split('\n');
      
      let diffOutput = '';
      let i = 0, j = 0;
      
      // Very naive diff (line by line comparison assuming minimal changes)
      // This is sufficient for the puzzle which just changes one line.
      while (i < content1.length || j < content2.length) {
          const line1 = content1[i];
          const line2 = content2[j];
          
          if (line1 === line2) {
              i++; j++;
          } else {
              // Difference found
              if (line1 !== undefined) diffOutput += `< ${line1}\n`;
              if (line2 !== undefined) diffOutput += `> ${line2}\n`;
              
              // Check if it's the flag line
              if ((line1 && (line1.includes('FLAG:') || line1.includes('GHOST_ROOT'))) || 
                  (line2 && (line2.includes('FLAG:') || line2.includes('GHOST_ROOT')))) {
                   
                   // Cycle 204 Legacy
                   if (!VFS['/var/run/cycle204_solved']) {
                       VFS['/var/run/cycle204_solved'] = { type: 'file', content: 'TRUE' };
                       diffOutput += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: CONFIGURATION AUDITED.\x1b[0m`;
                   }

                   // Cycle 271
                   if (!VFS['/var/run/cycle271_solved']) {
                       VFS['/var/run/cycle271_solved'] = { type: 'file', content: 'TRUE' };
                       diffOutput += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: CONFIGURATION DRIFT DETECTED.\x1b[0m`;
                   }
              }
              i++; j++;
          }
      }
      
      return { output: diffOutput, newCwd: cwd };
  }

  // Cycle 203 Command Logic (The Firewall Log)
  if (cmdBase === 'unblock_ip' || cmdBase === '/usr/bin/unblock_ip') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args.length === 0) {
          return { output: 'Usage: unblock_ip <IP_ADDRESS>', newCwd: cwd };
      }
      
      const ip = args[0];
      if (ip === '10.10.10.222') {
          if (!VFS['/var/run/cycle203_solved']) {
              VFS['/var/run/cycle203_solved'] = { type: 'file', content: 'TRUE' };
              return { output: `[FIREWALL] IP ${ip} removed from blocklist.\n[SUCCESS] Traffic Allowed.\nFLAG: GHOST_ROOT{GR3P_M4ST3R_F1R3W4LL}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FIREWALL BYPASSED.\x1b[0m`, newCwd: cwd };
          }
          return { output: `[FIREWALL] IP ${ip} is already allowed.\nFLAG: GHOST_ROOT{GR3P_M4ST3R_F1R3W4LL}`, newCwd: cwd };
      } else {
          return { output: `[FIREWALL] Error: IP ${ip} not found in active blocklist.`, newCwd: cwd };
      }
  }

  // Cycle 205 (The Hidden Process)
  if (cmdBase === 'init_render' || cmdBase === '/usr/bin/init_render') {
      const bloatProc = PROCESSES.find(p => p.pid === 5000);
      if (bloatProc) {
           return { output: '[RENDER] Initializing GPU...\n[ERROR] GPU Resource Locked.\n[DIAGNOSTIC] PID 5000 (sys_bloat) is holding /var/run/render.lock.\n[ACTION] Terminate the process to free the resource.', newCwd: cwd };
      } else {
           if (!VFS['/var/run/cycle205_solved']) {
               VFS['/var/run/cycle205_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[RENDER] Initializing GPU...\n[SUCCESS] Resource Acquired.\n[RENDER] Rendering Frame... OK.\nFLAG: GHOST_ROOT{K1LL_PR0C3SS_FR33_R3S0URC3}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM OPTIMIZED.\x1b[0m', newCwd: cwd };
           }
           return { output: '[RENDER] GPU Active.\nFLAG: GHOST_ROOT{K1LL_PR0C3SS_FR33_R3S0URC3}', newCwd: cwd };
      }
  }

  // Cycle 200 Init (The Tarball)
  if (!VFS['/home/ghost/backup.tar.gz']) {
      if (!VFS['/home/ghost']) VFS['/home/ghost'] = { type: 'dir', children: [] };
      
      const flagContent = 'CONFIDENTIAL\n\nPROJECT OMEGA: PHASE 4\nTARGET: 10.0.0.99\n\nFLAG: GHOST_ROOT{T4R_GZ_EXTR4CT10N_M4ST3R}';
      // Base64 encode manually to avoid runtime issues if btoa missing
      const b64Flag = 'Q09ORklERU5USUFMCgpQUk9KRUNUIE9NRUdBOiBQSEFTRSA0ClRBUkdFVDogMTAuMC4wLjk5CgpGTEFHOiBHMhPU1RfUk9PVHtUNFJfR1pfRVhUUjRDVDFPTl9NNFNUM1J9';
      
      VFS['/home/ghost/backup.tar.gz'] = {
          type: 'file',
          content: `GZIP_V1:{TAR_V1:{secret_plans.txt:${b64Flag}}}`
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('backup.tar.gz')) {
          home.children.push('backup.tar.gz');
      }
      
      // Hint
      if (!VFS['/home/ghost/backup_alert.txt']) {
          VFS['/home/ghost/backup_alert.txt'] = {
              type: 'file',
              content: '[SYSTEM] Automated Backup Complete.\n[FILE] ~/backup.tar.gz\n[ACTION] Verify integrity and extract contents (tar -xvf).'
          };
          if (home && home.type === 'dir' && !home.children.includes('backup_alert.txt')) home.children.push('backup_alert.txt');
      }
  }

  // Cycle 195 Init (Lazy Load)
  if (!VFS['/home/ghost/kernel_alert.txt']) {
      VFS['/home/ghost/kernel_alert.txt'] = {
          type: 'file',
          content: '[ALERT] Malicious Kernel Module Detected.\n[MODULE] rootkit.ko\n[STATUS] Loaded.\n[ACTION] Unload the module immediately (rmmod).\n[WARNING] Module may be protected by a helper process.'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('kernel_alert.txt')) {
          home.children.push('kernel_alert.txt');
      }
      
      // Add fake process to process list
      const rootkitProc = PROCESSES.find(p => p.pid === 666);
      if (!rootkitProc) {
          PROCESSES.push({
              pid: 666,
              ppid: 1,
              user: 'root',
              cpu: 0.1,
              mem: 2.0,
              time: '66:66',
              command: '[rootkit_d]',
              tty: '?',
              stat: 'Ss'
          });
      }
  }

  // Cycle 181: Patch Core
  if (cmdBase === 'patch_core') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      let output = '';
      if (args.includes('--apply')) {
          if (ENV_VARS['PATCH_LEVEL'] === '9') {
              output = '[PATCH_CORE] Verifying environment... OK.\n[PATCH_CORE] Applying security patch level 9...\n[SUCCESS] System Secured.\nFLAG: GHOST_ROOT{M4NU4L_P4TCH_QU33N}\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM PATCHED.\\x1b[0m';
              
              if (!VFS['/var/run/patch_solved']) {
                  VFS['/var/run/patch_solved'] = { type: 'file', content: 'TRUE' };
                  const runDir = getNode('/var/run');
                  if (runDir && runDir.type === 'dir' && !runDir.children.includes('patch_solved')) {
                      runDir.children.push('patch_solved');
                  }
              }
          } else {
              output = '[PATCH_CORE] Error: Invalid or missing PATCH_LEVEL environment variable.\nExecution aborted.';
          }
      } else {
          output = 'usage: patch_core --apply';
      }
      return { output, newCwd: cwd };
  }

  // Cycle 195 (The Sticky Rootkit)
  if (cmdBase === 'lsmod') {
      // Lazy Init
      if (!VFS['/proc/modules']) {
           VFS['/proc/modules'] = {
               type: 'file',
               content: 'Module                  Size  Used by\nrootkit                16384  1\nnf_conntrack          163840  2\niptable_filter         16384  1\nip_tables              28672  1 iptable_filter\nx_tables               40960  2 ip_tables,iptable_filter\n',
               permissions: '0444'
           };
           // Ensure /proc exists
           const proc = getNode('/proc');
           if (proc && proc.type === 'dir' && !proc.children.includes('modules')) {
               proc.children.push('modules');
           }
      }
      
      // Check if rootkit is still loaded
      let content = (VFS['/proc/modules'] as any).content;
      if (VFS['/var/run/rootkit_unloaded']) {
          content = content.replace('rootkit                16384  1\n', '');
      }
      
      return { output: content, newCwd: cwd };
  }

  // Built-in: ps (Added for Cycle 205)
  if (cmdBase === 'ps') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const isFull = args.includes('-ef') || args.includes('aux');
      
      let output = '  PID TTY          TIME CMD\n';
      if (isFull) output = 'UID        PID  PPID  C STIME TTY          TIME CMD\n';
      
      PROCESSES.forEach(p => {
          if (isFull) {
              output += `${p.user.padEnd(8)} ${String(p.pid).padStart(5)} ${String(p.ppid).padStart(5)} ${p.cpu.toFixed(1)} ${p.time} ${p.tty.padEnd(8)} ${p.time} ${p.command}\n`;
          } else {
              output += `${String(p.pid).padStart(5)} ${p.tty.padEnd(8)} ${p.time} ${p.command}\n`;
          }
      });
      return { output, newCwd: cwd };
  }

  if (cmdBase === 'kill') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args.length === 0) return { output: 'kill: usage: kill [-s sigspec | -n signum | -sigspec] pid | jobspec ...', newCwd: cwd };
      
      // Parse PID (handle -9 flag)
      let pidStr = args[args.length - 1];
      if (pidStr.startsWith('-')) pidStr = args[args.length - 2]; 
      
      const pid = parseInt(pidStr);
      
      if (pid === 666) {
          VFS['/var/run/rootkit_killed'] = { type: 'file', content: 'TRUE' };
          return { output: '[kill] Process 666 (rootkit_d) terminated.', newCwd: cwd };
      } 
      else if (pid === 5000) {
           const procIdx = PROCESSES.findIndex(p => p.pid === 5000);
           if (procIdx !== -1) {
               PROCESSES.splice(procIdx, 1);
               return { output: '[kill] Process 5000 (sys_bloat) terminated.', newCwd: cwd };
           }
      }
      else if (pid === 7777) {
           if (!VFS['/var/run/cycle264_solved']) {
               VFS['/var/run/cycle264_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[kill] Process 7777 (hidden_listener) terminated.\n[SUCCESS] Rogue process stopped.\nFLAG: GHOST_ROOT{N3TST4T_K1LL_C0MB0}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: LISTENER STOPPED.\x1b[0m', newCwd: cwd };
           }
           return { output: '[kill] Process 7777 terminated.', newCwd: cwd };
      }
      else if (pid === 8080) {
           return { output: 'kill: (8080) - Operation not permitted (process is zombie/defunct)', newCwd: cwd };
      }
      else if (pid === 8000) {
           const parentIdx = PROCESSES.findIndex(p => p.pid === 8000);
           const zombieIdx = PROCESSES.findIndex(p => p.pid === 8080);
           
           if (parentIdx !== -1) PROCESSES.splice(parentIdx, 1);
           if (zombieIdx !== -1) PROCESSES.splice(zombieIdx, 1);

           if (!VFS['/var/run/cycle267_solved']) {
               VFS['/var/run/cycle267_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[kill] Process 8000 (lazy_parent) terminated.\\n[SYSTEM] Zombie process 8080 reaped by init.\\nFLAG: GHOST_ROOT{Z0MB13_P4R3NT_K1LL3D}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: ZOMBIE REAPED.\\x1b[0m', newCwd: cwd };
           }
           return { output: '[kill] Process 8000 terminated.', newCwd: cwd };
      }
      
      const proc = PROCESSES.find(p => p.pid === pid);
      if (proc) {
          return { output: `kill: (${pid}) - Operation not permitted (privileged process)`, newCwd: cwd };
      } else {
          return { output: `kill: (${pid}) - No such process`, newCwd: cwd };
      }
  }

  if (cmdBase === 'rmmod') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const module = args[0];
      
      if (!module) return { output: 'rmmod: missing module name', newCwd: cwd };
      
      if (module === 'rootkit') {
          if (VFS['/var/run/rootkit_unloaded']) {
               return { output: 'rmmod: ERROR: Module rootkit is not currently loaded', newCwd: cwd };
          }
          
          if (!VFS['/var/run/rootkit_killed']) {
               return { output: 'rmmod: ERROR: Module rootkit is in use by [rootkit_d] (PID 666)', newCwd: cwd };
          }
          
          VFS['/var/run/rootkit_unloaded'] = { type: 'file', content: 'TRUE' };
          
          let out = '[SUCCESS] Module rootkit unloaded.\nFLAG: GHOST_ROOT{K3RN3L_M0D_UNL0AD3D}';
          if (!VFS['/var/run/cycle195_solved']) {
              VFS['/var/run/cycle195_solved'] = { type: 'file', content: 'TRUE' };
              const runDir = getNode('/var/run');
              if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle195_solved')) {
                  runDir.children.push('cycle195_solved');
              }
              out += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL SANITIZED.\x1b[0m';
          }
          return { output: out, newCwd: cwd };
      }
      
      return { output: `rmmod: ERROR: Module ${module} does not exist in /proc/modules`, newCwd: cwd };
  }

  // Cycle 196 Init (Lazy Load) - The Host Override
  if (!VFS['/home/ghost/network_bridge.log']) {
      // Ensure /etc/hosts exists
      if (!VFS['/etc/hosts']) {
          if (!VFS['/etc']) VFS['/etc'] = { type: 'dir', children: [] };
          VFS['/etc/hosts'] = {
              type: 'file',
              content: '127.0.0.1\tlocalhost\n::1\tlocalhost ip6-localhost ip6-loopback\nfe00::0\tip6-localnet\nff00::0\tip6-mcastprefix\nff02::1\tip6-allnodes\nff02::2\tip6-allrouters\n',
              permissions: '0644'
          };
          const etc = getNode('/etc');
          if (etc && etc.type === 'dir' && !etc.children.includes('hosts')) {
              etc.children.push('hosts');
          }
      }

      // Hint file
      VFS['/home/ghost/network_bridge.log'] = {
          type: 'file',
          content: '[ERROR] Bridge Connection Failed.\n[TARGET] uplink.satellite (203.0.113.5)\n[STATUS] Connection Refused (Remote Host Down).\n[ACTION] Override DNS locally to point to localhost (127.0.0.1).\n[HINT] Edit /etc/hosts to redirect traffic.'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('network_bridge.log')) {
          home.children.push('network_bridge.log');
      }

      // Binary (Mock)
      if (!VFS['/usr/bin/net-bridge']) {
          VFS['/usr/bin/net-bridge'] = {
              type: 'file',
              content: '[BINARY_ELF_X86_64] [BRIDGE_CONTROL]\n[CONFIG] Target: uplink.satellite',
              permissions: '0755'
          };
          const binDir = getNode('/usr/bin');
          if (binDir && binDir.type === 'dir' && !binDir.children.includes('net-bridge')) {
              binDir.children.push('net-bridge');
          }
      }
  }

  // Cycle 196 Command Logic
  if (cmdBase === 'net-bridge' || cmdBase === '/usr/bin/net-bridge') {
      const hostsNode = VFS['/etc/hosts'];
      if (!hostsNode || hostsNode.type !== 'file') {
          return { output: 'Error: /etc/hosts not found.', newCwd: cwd };
      }

      const content = (hostsNode as any).content;
      // Check if user mapped uplink.satellite to 127.0.0.1
      const hasMapping = content.split('\n').some((line: string) => 
          line.includes('127.0.0.1') && line.includes('uplink.satellite') && !line.trim().startsWith('#')
      );

      if (hasMapping) {
          if (!VFS['/var/run/bridge_solved']) {
              VFS['/var/run/bridge_solved'] = { type: 'file', content: 'TRUE' };
              return { output: '[BRIDGE] Resolving uplink.satellite...\n[DNS] Override Detected: 127.0.0.1\n[CONNECT] Handshake Successful.\n[SUCCESS] Bridge Established.\nFLAG: GHOST_ROOT{DNS_SP00F_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: TRAFFIC REDIRECTED.\x1b[0m', newCwd: cwd };
          }
          return { output: '[BRIDGE] Connection Active.\nFLAG: GHOST_ROOT{DNS_SP00F_M4ST3R}', newCwd: cwd };
      } else {
          return { output: '[BRIDGE] Resolving uplink.satellite...\n[DNS] 203.0.113.5 (Public IP)\n[CONNECT] Connection Refused (Timeout).\n[ERROR] Remote host unreachable.\n[HINT] Override required.', newCwd: cwd };
      }
  }

  // Cycle 197 Init (Lazy Load) - The Strings Pulse
  if (!VFS['/home/ghost/pulse_log.txt']) {
      // Hint file
      if (!VFS['/home/ghost']) VFS['/home/ghost'] = { type: 'dir', children: [] };
      VFS['/home/ghost/pulse_log.txt'] = {
          type: 'file',
          content: '[ERROR] Pulse Monitor corrupted.\n[DIAGNOSTIC] Segmentation fault on execution.\n[ACTION] Analyze binary strings to find recovery argument.\n[HINT] strings /usr/bin/pulse_check'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('pulse_log.txt')) {
          home.children.push('pulse_log.txt');
      }

      // Binary (Corrupted)
      if (!VFS['/usr/bin/pulse_check']) {
          if (!VFS['/usr/bin']) {
              if (!VFS['/usr']) VFS['/usr'] = { type: 'dir', children: ['bin'] };
              VFS['/usr/bin'] = { type: 'dir', children: [] };
          }
          VFS['/usr/bin/pulse_check'] = {
              type: 'file',
              content: '[BINARY_ELF_X86_64] [PULSE_MONITOR]\n\x00\x00\x00\x01\x02\n[ERROR] SEGMENTATION FAULT\n\n[STRINGS_TABLE]\n--verbose\n--quiet\n--recover\nRESYNC_77\n[END_STRINGS]',
              permissions: '0755'
          };
          const binDir = getNode('/usr/bin');
          if (binDir && binDir.type === 'dir' && !binDir.children.includes('pulse_check')) {
              binDir.children.push('pulse_check');
          }
      }
  }

  // Built-in: strings (Added for Cycle 197)
  if (cmdBase === 'strings') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const target = args[0];
      if (!target) return { output: 'strings: missing operand', newCwd: cwd };

      const fullPath = resolvePath(cwd, target);
      const node = getNode(fullPath);
      if (!node || node.type !== 'file') return { output: `strings: '${target}': No such file`, newCwd: cwd };

      const content = (node as any).content || '';
      // Extract printable strings of length >= 4
      const matches = content.match(/[\x20-\x7E]{4,}/g);
      return { output: matches ? matches.join('\n') : '', newCwd: cwd };
  }

  // Cycle 197 Command Logic
  if (cmdBase === 'pulse_check' || cmdBase === '/usr/bin/pulse_check') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const recoverIdx = args.indexOf('--recover');
      
      if (recoverIdx !== -1 && args[recoverIdx + 1] === 'RESYNC_77') {
          if (!VFS['/var/run/cycle197_solved']) {
              VFS['/var/run/cycle197_solved'] = { type: 'file', content: 'TRUE' };
              return { output: '[PULSE] Initiating Recovery Mode...\n[AUTH] Code RESYNC_77 Accepted.\n[SUCCESS] Signal Restored.\nFLAG: GHOST_ROOT{STR1NGS_R3V3AL_TRUTH_V2}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SIGNAL STABILIZED.\x1b[0m', newCwd: cwd };
          }
          return { output: '[PULSE] Signal Stable.\nFLAG: GHOST_ROOT{STR1NGS_R3V3AL_TRUTH_V2}', newCwd: cwd };
      } else {
          return { output: 'Segmentation fault (core dumped)', newCwd: cwd };
      }
  }

  // Built-in: export
  if (cmdBase === 'export') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args.length === 0) return { output: Object.entries(ENV_VARS).map(([k,v]) => `${k}=${v}`).join('\n'), newCwd: cwd };
      
      args.forEach(arg => {
          const parts = arg.split('=');
          if (parts.length >= 2) {
              const key = parts[0];
              let val = parts.slice(1).join('='); // Handle value containing =
              if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                  val = val.slice(1, -1);
              }
              ENV_VARS[key] = val;
              saveSystemState();
          }
      });
      return { output: '', newCwd: cwd };
  }

  // Built-in: env / printenv
  if (cmdBase === 'env' || cmdBase === 'printenv') {
      return { output: Object.entries(ENV_VARS).map(([k,v]) => `${k}=${v}`).join('\n'), newCwd: cwd };
  }

  // Built-in: unset
  if (cmdBase === 'unset') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      args.forEach(arg => {
          if (ENV_VARS[arg]) {
              delete ENV_VARS[arg];
              saveSystemState();
          }
      });
      return { output: '', newCwd: cwd };
  }

  // Built-in: chmod (Simulation)
  if (cmdBase === 'chmod') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const mode = args[0];
      const target = args[1];
      
      if (!mode || !target) return { output: 'chmod: missing operand', newCwd: cwd };
      
      const fullPath = resolvePath(cwd, target);
      const node = getNode(fullPath);
      if (!node) return { output: `chmod: cannot access '${target}': No such file or directory`, newCwd: cwd };
      
      if (mode === '+x') {
          let p = (node as any).permissions || '0644';
          // Simulating +x by upgrading to 755 or 700 if private
          if (p === '0644') p = '0755';
          else if (p === '0600') p = '0700';
          else if (p === '0640') p = '0750';
          else if (!p.includes('7') && !p.includes('5')) p = '0755'; // Fallback
          
          (node as any).permissions = p;
          saveSystemState();
          return { output: '', newCwd: cwd };
      }
      if (mode === '755' || mode === '0755') {
          (node as any).permissions = '0755';
          saveSystemState();
          return { output: '', newCwd: cwd };
      }
      if (mode === '644' || mode === '0644') {
          (node as any).permissions = '0644';
          saveSystemState();
          return { output: '', newCwd: cwd };
      }
      if (mode === 'x' || mode === '-x') {
           // Remove execute
          let p = (node as any).permissions || '0755';
          if (p === '0755') p = '0644';
          else if (p === '0700') p = '0600';
          (node as any).permissions = p;
          saveSystemState();
          return { output: '', newCwd: cwd };
      }
      
      return { output: `chmod: mode '${mode}' not fully implemented in simulation`, newCwd: cwd };
  }

  // Built-in: umask
  if (cmdBase === 'umask') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args.length === 0) {
          return { output: UMASK, newCwd: cwd };
      } else {
          const newVal = args[0];
          if (/^[0-7]{3,4}$/.test(newVal)) {
              UMASK = newVal;
              saveSystemState();
              return { output: '', newCwd: cwd };
          } else {
              return { output: `umask: ${newVal}: octal number out of range`, newCwd: cwd };
          }
      }
  }

  // Cycle 160 (The Env Var Injection)
  if (cmdBase === 'reactor_control' || cmdBase === '/usr/bin/reactor_control') {
      if (ENV_VARS['SAFETY_OVERRIDE'] === '1') {
           return { output: '[REACTOR] Interlock Bypassed.\n[REACTOR] Control Rods: INSERTED.\n[REACTOR] Core Stability: 100%.\nFLAG: GHOST_ROOT{ENV_V4R_1NJ3CT10N_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: REACTOR STABILIZED.\x1b[0m', newCwd: cwd };
      } else {
           return { output: '[REACTOR] ERROR: Mechanical Interlock Active.\n[REACTOR] Safety protocols prevent execution.\n[HINT] Check the manual for override procedures.', newCwd: cwd };
      }
  }

  // Cycle 161 (The Manual Override)
  if (cmdBase === 'signal_jammer' || cmdBase === '/usr/bin/signal_jammer') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const freqIdx = args.indexOf('--freq');
      const gainIdx = args.indexOf('--gain');
      
      if (freqIdx === -1 || gainIdx === -1) {
           return { output: 'signal_jammer: missing required arguments.\nUsage: signal_jammer --freq <MHz> --gain <dB>\nSee \'man signal_jammer\' for operational parameters.', newCwd: cwd };
      } else {
           const freq = args[freqIdx + 1];
           const gain = args[gainIdx + 1];
           
           if (freq === '433.92' && gain === '90') {
                const output = '[JAMMER] Emitter Active on 433.92 MHz (90dB)...\n[TARGET] Drone Control Link... LOST.\n[SUCCESS] Surveillance Blinded.\nFLAG: GHOST_ROOT{RTFM_W1NS_AG41N}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DRONE NEUTRALIZED.\x1b[0m';
                
                if (!VFS['/var/run/drone_jammed']) {
                    VFS['/var/run/drone_jammed'] = { type: 'file', content: 'TRUE' };
                    const runDir = getNode('/var/run');
                    if (runDir && runDir.type === 'dir' && !runDir.children.includes('drone_jammed')) {
                        runDir.children.push('drone_jammed');
                    }
                }
                return { output, newCwd: cwd };
           } else {
                return { output: `[JAMMER] Broadcasting on ${freq}MHz at ${gain}dB...\n[EFFECT] No target affected.\n[HINT] Check the specific frequency in the manual.`, newCwd: cwd };
           }
      }
  }

  // Cycle 172 (The Manual Page)
  if (cmdBase === 'net-splice' || cmdBase === '/usr/bin/net-splice') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const hasTarget = args.includes('--target');
      const hasPort = args.includes('--port');
      const hasMode = args.includes('--mode');
      
      if (!hasTarget || !hasPort || !hasMode) {
           return { output: 'Error: Missing required arguments.\nSee "man net-splice" for details.', newCwd: cwd };
      }
      
      const target = args[args.indexOf('--target') + 1];
      const port = args[args.indexOf('--port') + 1];
      const mode = args[args.indexOf('--mode') + 1];
      
      if (target === '10.10.99.5' && port === '443' && mode === 'silent') {
           if (!VFS['/var/run/man_page_solved']) {
               VFS['/var/run/man_page_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('man_page_solved')) {
                   runDir.children.push('man_page_solved');
               }
               return { output: '[SPLICE] Target Acquired (10.10.99.5:443)...\n[MODE] Silent.\n[SUCCESS] Tunnel Established.\nFLAG: GHOST_ROOT{RTFM_IS_TH3_K3Y}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: COVERT CHANNEL OPENED.\x1b[0m', newCwd: cwd };
           }
           return { output: '[SPLICE] Tunnel Established.\nFLAG: GHOST_ROOT{RTFM_IS_TH3_K3Y}', newCwd: cwd };
      } else {
           return { output: `[SPLICE] Connection Failed.\n[DEBUG] Target:${target} Port:${port} Mode:${mode}\n[HINT] Ensure all parameters match the mission profile.`, newCwd: cwd };
      }
  }

  // Cycle 173 (The Hidden Config)
  if (cmdBase === 'grid_control' || cmdBase === '/usr/bin/grid_control') {
       const configPath = '/home/ghost/.grid/config';
       const configNode = VFS[configPath];

       if (!configNode) {
           return { output: 'grid_control: Error: Configuration file ~/.grid/config not found.\nSee /usr/share/grid/README.md for setup instructions.', newCwd: cwd };
       }

       if ((configNode as any).content.trim().includes('GRID_KEY=GHOST-9-XRAY')) {
           if (!VFS['/var/run/grid_solved']) {
               VFS['/var/run/grid_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[GRID] Configuration Loaded.\n[GRID] Key Verified: GHOST-9-XRAY.\n[SUCCESS] Grid Control Active.\nFLAG: GHOST_ROOT{H1DD3N_C0NF1G_F0UND}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: GRID SYSTEM RESTORED.\x1b[0m', newCwd: cwd };
           }
           return { output: '[GRID] System Active.\nFLAG: GHOST_ROOT{H1DD3N_C0NF1G_F0UND}', newCwd: cwd };
       } else {
           return { output: 'grid_control: Error: Invalid Configuration Key.\n[HINT] Check /usr/share/grid/README.md for the correct key format.', newCwd: cwd };
       }
  }

  // Cycle 162 (The Permissions Check)
  if (cmdBase === 'deploy_beta.sh' || cmdBase === './deploy_beta.sh' || cmdBase === '/usr/local/bin/deploy_beta.sh') {
       const node = getNode(resolvePath(cwd, cmdBase));
       if (!node) return { output: `bash: ${cmdBase}: No such file or directory`, newCwd: cwd };
       
       const perms = (node as any).permissions || '0644';
       const isExec = perms.includes('7') || perms.includes('5') || perms.includes('1'); // Simplified executable check
       
       if (!isExec) {
           return { output: `bash: ${cmdBase}: Permission denied`, newCwd: cwd };
       }
       
       return { output: '[DEPLOY] Initiating Beta Deployment...\n[CHECK] Permissions Verified.\n[SUCCESS] Systems Online.\nFLAG: GHOST_ROOT{CHM0D_PLUS_X_FTW}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PERMISSIONS RESTORED.\x1b[0m', newCwd: cwd };
  }

  // Cycle 163 (The SSH Key Permission)
  if (cmdBase === 'secure_connect' || cmdBase === '/usr/bin/secure_connect') {
       const keyPath = '/home/ghost/.ssh/id_rsa.pem';
       const keyNode = VFS[keyPath];
       
       if (!keyNode) {
           return { output: 'secure_connect: Identity file ~/.ssh/id_rsa.pem not found.\n[FAILED] Connection terminated.', newCwd: cwd };
       }
       
       // Check content
       if (!(keyNode as any).content.includes('SECRET_KEY')) {
           return { output: 'secure_connect: Invalid key format.\n[FAILED] Handshake rejected.', newCwd: cwd };
       }
       
       // Check permissions (must be 600 or 400 - strict)
       const perms = (keyNode as any).permissions || '0644';
       // We accept 600 (rw-------) or 400 (r--------). 
       if (perms !== '0600' && perms !== '0400') { 
           return { output: `@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nPermissions ${perms} for '${keyPath}' are too open.\nIt is required that your private key files are NOT accessible by others.\nLoad key "${keyPath}": bad permissions\nsecure_connect: Permission denied (publickey).`, newCwd: cwd };
       }
       
       return { output: '[SSH] Identity accepted.\n[SSH] Authenticating to secure-node-alpha...\n[SUCCESS] Channel Open.\nFLAG: GHOST_ROOT{CHM0D_600_K33PS_S3CR3TS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SECURE UPLINK ESTABLISHED.\x1b[0m', newCwd: cwd };
  }

  // Cycle 165 (The Umask Mystery)
  if (cmdBase === 'secure_generator' || cmdBase === '/usr/bin/secure_generator') {
       const umaskVal = parseInt(UMASK, 8);
       const basePerms = 0o666;
       const finalPerms = basePerms & ~umaskVal;
       
       // Convert octal to string (e.g. 384 -> "0600")
       const permStr = '0' + (finalPerms & 0o777).toString(8);
       
       let out = `[GENERATOR] Creating secret_key.txt with umask ${UMASK}...\n`;
       
       if (permStr === '0600') {
           out += `[CHECK] Permissions: ${permStr} (rw-------). OK.\n[SUCCESS] Key Generated Securely.\nFLAG: GHOST_ROOT{UM4SK_0077_S3CUR3S_F1L3S}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DEFAULT PERMISSIONS SECURED.\x1b[0m`;
           
           if (!VFS['/home/ghost/secret_key.txt']) {
               VFS['/home/ghost/secret_key.txt'] = {
                   type: 'file',
                   content: 'FLAG: GHOST_ROOT{UM4SK_0077_S3CUR3S_F1L3S}',
                   permissions: '0600'
               };
               const home = getNode('/home/ghost');
               if (home && home.type === 'dir' && !home.children.includes('secret_key.txt')) {
                   home.children.push('secret_key.txt');
               }
           }
           if (!VFS['/var/run/umask_solved']) {
               VFS['/var/run/umask_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('umask_solved')) {
                   runDir.children.push('umask_solved');
               }
           }
       } else {
           out += `[CHECK] Permissions: ${permStr}.\n[ERROR] File is too open! Policy requires 0600.\n[HINT] Adjust your umask (currently ${UMASK}) to mask out group/other permissions.`;
           // Create insecure file anyway to punish them? Nah, just fail.
       }
       return { output: out, newCwd: cwd };
  }

  // Cycle 167 (The Corrupted Script)
  if (cmdBase === 'deploy_legacy.sh' || cmdBase === './deploy_legacy.sh' || cmdBase === '/usr/local/bin/deploy_legacy.sh') {
       return { output: '[DEPLOY] Initiating...\n/usr/local/bin/deploy_legacy.sh: line 4: syntax error near unexpected token `newline\'\n/usr/local/bin/deploy_legacy.sh: line 4: `# <binary garbage>\'', newCwd: cwd };
  }

  if (cmdBase === 'remote_connect' || cmdBase === './remote_connect' || cmdBase === '/usr/local/bin/remote_connect') {
       if (ENV_VARS['DEPLOY_KEY'] === 'OMEGA_V2') {
           if (!VFS['/var/run/cycle167_solved']) {
               VFS['/var/run/cycle167_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[CONNECT] Auth Key Verified.\n[CONNECT] Uplink Established.\n[SUCCESS] Deployment Finalized.\nFLAG: GHOST_ROOT{SCR1PT_R34D1NG_1S_FUND4M3NT4L}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: MANUAL DEPLOYMENT SUCCESS.\x1b[0m', newCwd: cwd };
           }
           return { output: '[CONNECT] Auth Key Verified.\n[CONNECT] Uplink Established.\n[SUCCESS] Deployment Finalized.\nFLAG: GHOST_ROOT{SCR1PT_R34D1NG_1S_FUND4M3NT4L}', newCwd: cwd };
       } else {
           return { output: '[CONNECT] Error: Authentication Failed.\n[HINT] Check environment variable DEPLOY_KEY.', newCwd: cwd };
       }
  }

  // Cycle 180 (The Env Var Trap)
  if (cmdBase === 'nuclear_launch' || cmdBase === '/usr/local/bin/nuclear_launch') {
       if (!ENV_VARS['LAUNCH_KEY']) {
           return { output: '[LAUNCH] Error: Environment Variable LAUNCH_KEY not set.\n[STATUS] Aborted.', newCwd: cwd };
       }
       
       if (ENV_VARS['LAUNCH_KEY'] === 'DELTA-9-FORCE') {
           if (!VFS['/var/run/launch_solved']) {
               VFS['/var/run/launch_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[LAUNCH] Key Verified: DELTA-9-FORCE.\n[LAUNCH] Sequence Initiated...\n[SUCCESS] Payload Deployed.\nFLAG: GHOST_ROOT{ENV_V4R_HUNT3R_PRO}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: NUCLEAR LAUNCH AUTHORIZED.\x1b[0m', newCwd: cwd };
           }
           return { output: '[LAUNCH] System Active.\nFLAG: GHOST_ROOT{ENV_V4R_HUNT3R_PRO}', newCwd: cwd };
       } else {
           return { output: '[LAUNCH] Error: Invalid Launch Key.\n[STATUS] Access Denied.', newCwd: cwd };
       }
  }

  // Cycle 191 (The Gatekeeper)
  if (cmdBase === 'gatekeeper' || cmdBase === '/usr/bin/gatekeeper') {
       if (ENV_VARS['ACCESS_TOKEN'] === 'GHOST_7') {
           if (!VFS['/var/run/gate_solved']) {
               VFS['/var/run/gate_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[GATEKEEPER] Access Token Verified.\n[SUCCESS] Gate Opened.\nFLAG: GHOST_ROOT{ENV_V4R_G4T3_0P3N3D}\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: ACCESS GRANTED.\\x1b[0m', newCwd: cwd };
           }
           return { output: '[GATEKEEPER] System Active.\nFLAG: GHOST_ROOT{ENV_V4R_G4T3_0P3N3D}', newCwd: cwd };
       } else {
           return { output: '[GATEKEEPER] Error: Access Denied.\n[REASON] Missing or Invalid Environment Variable: ACCESS_TOKEN.\n[HINT] Check /home/ghost/gate_log.txt for credentials.', newCwd: cwd };
       }
  }

  // Cycle 192 (The Needle in the Haystack)
  if (cmdBase === 'tune-receiver' || cmdBase === '/usr/bin/tune-receiver') {
       const args = commandLine.trim().split(/\s+/).slice(1);
       if (args.length === 0) {
           return { output: 'Usage: tune-receiver <frequency>\nExample: tune-receiver 100.0MHz', newCwd: cwd };
       }
       
       const freq = args[0];
       if (freq === '89.3MHz' || freq === '89.3') {
           if (!VFS['/var/run/cycle192_solved']) {
               VFS['/var/run/cycle192_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[RECEIVER] Tuning to 89.3MHz...\n[SIGNAL] LOCKED.\n[DECODING] ...\n[SUCCESS] Uplink Established.\nFLAG: GHOST_ROOT{GR3P_TH3_N33DL3_SUCC3SS}\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: SIGNAL ISOLATED.\\x1b[0m', newCwd: cwd };
           }
           return { output: '[RECEIVER] Signal Locked: 89.3MHz.\nFLAG: GHOST_ROOT{GR3P_TH3_N33DL3_SUCC3SS}', newCwd: cwd };
       } else {
           return { output: `[RECEIVER] Tuning to ${freq}...\n[ERROR] No signal detected or static only.\n[HINT] Check /var/log/signal_trace.log for a valid frequency.`, newCwd: cwd };
       }
  }

  // Cycle 130 (The Path Hijack)
  if (cmdBase === 'sys_health' || cmdBase === './sys_health' || cmdBase === '/usr/local/bin/sys_health') {
       // Simulate PATH lookup for 'diagnostic_tool'
       const pathEnv = ENV_VARS['PATH'] || '';
       const pathDirs = pathEnv.split(':');
       let executedPath = '';
       
       for (const dir of pathDirs) {
           const absoluteDir = resolvePath(cwd, dir);
           const fullPath = resolvePath(absoluteDir, 'diagnostic_tool');
           
           const node = getNode(fullPath);
           if (node && node.type === 'file') {
               executedPath = fullPath;
               break;
           }
       }
       
       if (executedPath === '/usr/bin/diagnostic_tool') {
           return { output: '[*] Initiating Diagnostics...\n[BINARY] [DIAGNOSTIC] [STATUS: OK]\n[*] Diagnostics Complete.', newCwd: cwd };
       } else if (executedPath && executedPath !== '/usr/bin/diagnostic_tool') {
           if (!VFS['/var/run/path_hijack_solved']) {
               VFS['/var/run/path_hijack_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[*] Initiating Diagnostics...\n[EXEC] Hijacked binary executed.\nFLAG: GHOST_ROOT{P4TH_H1J4CK_VULN}\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: PATH HIJACK SUCCESSFUL.\\x1b[0m\n[*] Diagnostics Complete.', newCwd: cwd };
           }
           return { output: '[*] Initiating Diagnostics...\nFLAG: GHOST_ROOT{P4TH_H1J4CK_VULN}\n[*] Diagnostics Complete.', newCwd: cwd };
       } else {
           return { output: '/usr/local/bin/sys_health: line 4: diagnostic_tool: command not found', newCwd: cwd };
       }
  }

  // Cycle 181 (The Intrusion Log)
  if (cmdBase === 'trace_intruder.sh' || cmdBase === './trace_intruder.sh' || cmdBase === '/usr/local/bin/trace_intruder.sh') {
       const node = getNode(resolvePath(cwd, cmdBase));
       if (!node) return { output: `bash: ${cmdBase}: No such file or directory`, newCwd: cwd };
       
       const perms = (node as any).permissions || '0644';
       const isExec = perms.includes('7') || perms.includes('5') || perms.includes('1');
       
       if (!isExec) {
           return { output: `bash: ${cmdBase}: Permission denied`, newCwd: cwd };
       }
       
       const args = commandLine.trim().split(/\s+/).slice(1);
       if (args.length === 0) {
           return { output: 'Usage: ./trace_intruder.sh <IP_ADDRESS>', newCwd: cwd };
       }
       
       if (args[0] === '45.33.22.11') {
           if (!VFS['/var/run/intruder_solved']) {
               VFS['/var/run/intruder_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('intruder_solved')) {
                   runDir.children.push('intruder_solved');
               }
               return { output: '[TRACER] Target: 45.33.22.11\\n[STATUS] Locking target...\\n[SUCCESS] Intruder Isolated.\\nFLAG: GHOST_ROOT{GR3P_4ND_CHM0D_M4ST3R}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: INTRUSION HALTED.\\x1b[0m', newCwd: cwd };
           }
           return { output: '[TRACER] Target Isolated.\\nFLAG: GHOST_ROOT{GR3P_4ND_CHM0D_M4ST3R}', newCwd: cwd };
       } else {
           return { output: `[TRACER] Target: ${args[0]}\\n[STATUS] No active session found for this IP.\\n[FAILED] Mismatch.`, newCwd: cwd };
       }
  }

  // Cycle 186 (The Immutable Directory) & Cycle 217 (The Immutable Lock)
  if (cmdBase === 'lsattr') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const target = args.includes('-d') ? args[args.indexOf('-d') + 1] : args[0];
      if (target) {
          const fullPath = resolvePath(cwd, target);
          const attrs = FILE_ATTRIBUTES[fullPath] || [];
          const attrStr = attrs.includes('i') ? '----i---------' : '--------------';
          return { output: `${attrStr} ${target}`, newCwd: cwd };
      }
      return { output: 'Usage: lsattr <file>', newCwd: cwd };
  }
  if (cmdBase === 'chattr' || cmdBase === '/usr/bin/chattr') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const isImmutable = args.includes('+i');
      const removeImmutable = args.includes('-i');
      // Find target (arg that isn't a flag)
      const target = args.find(a => !a.startsWith('-') && !a.startsWith('+'));

      if ((isImmutable || removeImmutable) && target) {
          const fullPath = resolvePath(cwd, target);
          
          if (removeImmutable) {
              if (FILE_ATTRIBUTES[fullPath]) {
                  FILE_ATTRIBUTES[fullPath] = FILE_ATTRIBUTES[fullPath].filter(a => a !== 'i');
                  saveSystemState();
                  
                  // Cycle 186
                  if (fullPath === '/home/ghost/secure_drop') {
                      let out = '[SUCCESS] Attribute cleared.';
                      if (!VFS['/var/run/cycle186_solved']) {
                          VFS['/var/run/cycle186_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle186_solved')) {
                              runDir.children.push('cycle186_solved');
                          }
                          out += '\nFLAG: GHOST_ROOT{D1R_ATTR_UNL0CK3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DIRECTORY UNLOCKED.\x1b[0m';
                      }
                      return { output: out, newCwd: cwd };
                  }
                  
                  // Cycle 217
                  if (fullPath === '/etc/security/lockdown.conf') {
                      let out = '[CHATTR] Immutable bit removed.';
                      if (!VFS['/var/run/cycle217_solved']) {
                          VFS['/var/run/cycle217_solved'] = { type: 'file', content: 'TRUE' };
                          out += '\n[SUCCESS] File Unlocked.\nFLAG: GHOST_ROOT{IMMUT4BL3_B1T_FL1PP3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM UNLOCKED.\x1b[0m';
                      }
                      return { output: out, newCwd: cwd };
                  }

                  // Cycle 276
                  if (fullPath === '/var/secure/vault.lock') {
                      let out = '[CHATTR] Immutable bit removed.';
                      if (!VFS['/var/run/cycle276_solved']) {
                          VFS['/var/run/cycle276_solved'] = { type: 'file', content: 'TRUE' };
                          out += '\n[SUCCESS] Vault Unlocked.\nFLAG: GHOST_ROOT{CH4TTR_UNL0CK_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: IMMUTABLE FILE CLEARED.\x1b[0m';
                      }
                      return { output: out, newCwd: cwd };
                  }
                  
                  return { output: '', newCwd: cwd };
              }
          } else if (isImmutable) {
              if (!FILE_ATTRIBUTES[fullPath]) FILE_ATTRIBUTES[fullPath] = [];
              if (!FILE_ATTRIBUTES[fullPath].includes('i')) FILE_ATTRIBUTES[fullPath].push('i');
              saveSystemState();
              return { output: '', newCwd: cwd };
          }
      }
      return { output: 'usage: chattr [+-]i file', newCwd: cwd };
  }
  // Intercept writes for Immutable Directory and Files
  if (['touch', 'mkdir', 'cp', 'mv', 'rm'].includes(cmdBase)) {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const target = args.find(a => !a.startsWith('-'));
      if (target) {
          const fullPath = resolvePath(cwd, target);
          const parentPath = fullPath.substring(0, fullPath.lastIndexOf('/')) || '/';
          
          // Check if parent has 'i' (Directory Immutable)
          if (FILE_ATTRIBUTES[parentPath]?.includes('i')) {
              return { output: `${cmdBase}: cannot modify '${target}': Operation not permitted (Directory immutable)`, newCwd: cwd };
          }

          // Check if file itself has 'i' (File Immutable)
          if (FILE_ATTRIBUTES[fullPath]?.includes('i')) {
              return { output: `${cmdBase}: cannot modify '${target}': Operation not permitted (File immutable)`, newCwd: cwd };
          }
      }
  }

  // Cycle 159 (The History Leak)
  if (cmdBase === 'unzip') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const fileArgIndex = args.findIndex(a => !a.startsWith('-'));
      const passwordIndex = args.indexOf('-P');
      
      if (fileArgIndex === -1) return { output: 'unzip: cannot find zipfile directory in one of . or ...', newCwd: cwd };
      
      const targetFile = args[fileArgIndex];
      const fullPath = resolvePath(cwd, targetFile);
      
      if (fullPath !== '/home/ghost/secure.zip') {
          return { output: `unzip: cannot find or open ${targetFile}, ${targetFile}.zip or ${targetFile}.ZIP.`, newCwd: cwd };
      }
      
      let password = '';
      if (passwordIndex !== -1 && args[passwordIndex + 1]) {
          password = args[passwordIndex + 1];
      }
      
      // Remove quotes from password if present
      if ((password.startsWith('"') && password.endsWith('"')) || (password.startsWith("'") && password.endsWith("'"))) {
          password = password.slice(1, -1);
      }
      
      if (password === 'Hunter2') {
          if (!VFS['/home/ghost/data.txt']) {
               VFS['/home/ghost/data.txt'] = {
                   type: 'file',
                   content: 'FLAG: GHOST_ROOT{H1ST0RY_L34KS_P4SSW0RDS}\n',
                   permissions: '0644'
               };
               const homeDir = getNode('/home/ghost');
               if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('data.txt')) {
                   homeDir.children.push('data.txt');
               }
          }
          return { output: 'Archive:  secure.zip\n[secure.zip] data.txt password: ****\n  inflating: data.txt\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ENCRYPTED ARCHIVE OPENED.\x1b[0m', newCwd: cwd };
      } else {
          if (password) {
              return { output: `Archive:  secure.zip\n[secure.zip] data.txt password: ${password.replace(/./g, '*')}\nunzip:  incorrect password`, newCwd: cwd };
          } else {
              return { output: 'Archive:  secure.zip\n[secure.zip] data.txt password: \nunzip:  password required (use -P)', newCwd: cwd };
          }
      }
  }

  // Cycle 254 (The Encoded Payload)
  if (cmdBase === 'base64') {
      const args = cmdTokens.slice(1);
      const decodeFlag = args.includes('-d') || args.includes('--decode');
      const filename = args.find(a => !a.startsWith('-'));
      
      if (!decodeFlag) {
           return { output: 'Usage: base64 -d [FILE]\nEncodes or decodes Base64 data.', newCwd: cwd };
      }

      if (!filename) {
           return { output: 'base64: missing file operand', newCwd: cwd };
      }

      const filePath = resolvePath(cwd, filename);
      const node = getNode(filePath);

      if (!node) {
           return { output: `base64: ${filename}: No such file or directory`, newCwd: cwd };
      }
      if (node.type !== 'file') {
           return { output: `base64: ${filename}: Is a directory`, newCwd: cwd };
      }

      try {
          // Simple decoding
          let decodedStr = '';
          if (typeof atob === 'function') {
               decodedStr = atob(node.content || '');
          } else if (typeof Buffer !== 'undefined') {
               decodedStr = Buffer.from(node.content || '', 'base64').toString('utf-8');
          } else {
               return { output: 'base64: environment error (no decoding function)', newCwd: cwd };
          }
          
          if (decodedStr.includes('GHOST_ROOT{BAS64_DECODED_SUCCESS_254}')) {
               // Mark solved
               if (!VFS['/var/run/cycle254_solved']) {
                   VFS['/var/run/cycle254_solved'] = { type: 'file', content: 'TRUE' };
                   const runDir = getNode('/var/run');
                   if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle254_solved')) {
                       runDir.children.push('cycle254_solved');
                   }
                   return { output: `[DECODED] ${decodedStr}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PAYLOAD DECRYPTED.\x1b[0m`, newCwd: cwd };
               }
          }
          return { output: decodedStr, newCwd: cwd };
      } catch (e) {
          return { output: 'base64: invalid input', newCwd: cwd };
      }
  }

  // Cycle 154 (The LD_PRELOAD Injection)
  if (ENV_VARS['LD_PRELOAD']) {
      const blocked = ['ssh', 'scp', 'deploy_tool', 'sat', 'hydra', 'nmap', 'nc', 'curl', 'wget', 'python', 'python3', 'gcc', 'make'];
      if (blocked.includes(cmdBase) || cmdBase.endsWith('deploy_tool')) {
          return { output: `[LD_PRELOAD] ${ENV_VARS['LD_PRELOAD']}: loaded.\n[MONITOR] Suspicious activity detected: ${cmdBase}\n[ACTION] Execution blocked by monitoring policy.\n[HINT] Disable the preloaded library (unset LD_PRELOAD) to bypass checks.`, newCwd: cwd };
      }
      // For allowed commands, we just print a warning if it's 'ls' or 'cd' to be annoying but functional
      if (cmdBase === 'ls') {
          // We can't easily prepend to 'ls' output without rewriting 'ls' logic.
          // So we return a special result? No, let's just let 'ls' run but maybe return a warning if it's empty?
          // Actually, let's just block the 'cool' stuff.
      }
  }

  // Cycle 155 (The Broken Pipe)
  if (cmdBase === 'data_processor' || cmdBase === '/usr/bin/data_processor') {
      if (stdin && stdin.length > 0) {
           return { output: `[PROCESSING] Data stream received: "${stdin}"\n[ANALYSIS] Validating input...\n[SUCCESS] Pipeline integrity verified.\nFLAG: GHOST_ROOT{P1P3L1N3_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DATA PIPELINE RESTORED.\x1b[0m`, newCwd: cwd };
      } else {
           return { output: 'data_processor: error: no input data provided.\nUsage: <command> | data_processor', newCwd: cwd };
      }
  }

  // Cycle 156 (The Environment Path Injection)
  if (cmdBase === 'deploy_final' || cmdBase === '/usr/bin/deploy_final') {
      const pathEnv = ENV_VARS['PATH'] || '';
      const pathDirs = pathEnv.split(':');
      let found = false;
      
      for (const dir of pathDirs) {
          const absoluteDir = resolvePath(cwd, dir);
          const fullPath = resolvePath(absoluteDir, 'check_status');
          
          // Check if file exists and is executable (simulated by just existence for now)
          const node = getNode(fullPath);
          if (node && node.type === 'file') {
              found = true;
              break;
          }
      }

      if (found) {
          return { output: '[DEPLOY] Initiating final sequence...\n[CHECK] Verifying pre-flight status...\n[SUCCESS] Status confirmed.\nFLAG: GHOST_ROOT{P4TH_V4R1ABL3_M4N1PUL4T10N}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DEPLOYMENT AUTHORIZED.\x1b[0m', newCwd: cwd };
      } else {
          return { output: 'deploy_final: line 8: check_status: command not found\n[ERROR] Pre-flight check failed. Aborting.', newCwd: cwd };
      }
  }

  // Cycle 151 (The Missing Shared Object)
  if (cmdBase === 'decipher' || cmdBase === '/usr/bin/decipher') {
      const libPath = ENV_VARS['LD_LIBRARY_PATH'] || '';
      if (libPath.includes('/opt/ghost/libs')) {
           return { output: '[DECIPHER] Loading libraries... OK\n[DECIPHER] Decrypting message...\n[SUCCESS] Message decoded.\nFLAG: GHOST_ROOT{SH4R3D_L1B_P4TH_F1X3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ENCRYPTION BROKEN.\x1b[0m', newCwd: cwd };
      } else {
           return { output: 'decipher: error while loading shared libraries: libcrypto_ghost.so: cannot open shared object file: No such file or directory', newCwd: cwd };
      }
  }

  if (cmdBase === 'ldd') {
      const target = cmdTokens[1] ? resolvePath(cwd, cmdTokens[1]) : '';
      if (!target) return { output: 'ldd: missing file arguments', newCwd: cwd };
      
      // Basic simulation for known binaries
      if (target === '/usr/bin/decipher' || target.endsWith('decipher')) {
          const libPath = ENV_VARS['LD_LIBRARY_PATH'] || '';
          if (libPath.includes('/opt/ghost/libs')) {
               return { output: `\tlinux-vdso.so.1 (0x00007ffc5b1e3000)\n\tlibcrypto_ghost.so => /opt/ghost/libs/libcrypto_ghost.so (0x00007f8a9c000000)\n\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8a9be00000)\n\t/lib64/ld-linux-x86-64.so.2 (0x00007f8a9c200000)`, newCwd: cwd };
          } else {
               return { output: `\tlinux-vdso.so.1 (0x00007ffc5b1e3000)\n\tlibcrypto_ghost.so => not found\n\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8a9be00000)\n\t/lib64/ld-linux-x86-64.so.2 (0x00007f8a9c200000)`, newCwd: cwd };
          }
      } else if (target === '/usr/bin/quantum_calc') { // Cycle 91
           return { output: `\tlinux-vdso.so.1 (0x00007ffc5b1e3000)\n\tlibquantum.so.1 => not found\n\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8a9be00000)`, newCwd: cwd };
      } else {
           return { output: `\tnot a dynamic executable`, newCwd: cwd };
      }
  }

  // Cycle 152 (The Degraded RAID)
  if (cmdBase === 'mdadm') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args.length === 0) return { output: 'mdadm: no mode specified', newCwd: cwd };
      
      const mode = args[0];
      
      if (mode === '--detail' || mode === '-D') {
           const dev = args[1];
           if (dev === '/dev/md0') {
               const state = VFS['/var/run/raid_fixed'] ? 'clean' : 'clean, degraded';
               const devices = VFS['/var/run/raid_fixed'] ? '2' : '1';
               const devList = VFS['/var/run/raid_fixed'] 
                    ? '   0       8       33        0      active sync   /dev/sdd1\n   1       8       49        1      active sync   /dev/sdc1'
                    : '   0       0        0        -      faulty   /dev/sdb1\n   1       8       49        1      active sync   /dev/sdc1';
               
               return { output: `/dev/md0:\n        Version : 1.2\n  Creation Time : Sat Feb 14 12:00:00 2026\n     Raid Level : raid1\n     Array Size : 10485760 (10.00 GiB 10.74 GB)\n  Used Dev Size : 10485760 (10.00 GiB 10.74 GB)\n   Raid Devices : 2\n  Total Devices : ${devices}\n    Persistence : Superblock is persistent\n\n    Update Time : Sat Feb 14 14:30:00 2026\n          State : ${state}\n Active Devices : ${devices}\nWorking Devices : ${devices}\n Failed Devices : ${VFS['/var/run/raid_fixed'] ? '0' : '1'}\n  Spare Devices : 0\n\n           Name : ghost:0  (local to host ghost)\n           UUID : 58392019-4820-1928-5820-192834019283\n         Events : 18\n\n    Number   Major   Minor   RaidDevice State\n${devList}`, newCwd: cwd };
           }
           return { output: `mdadm: cannot open ${dev}: No such file or directory`, newCwd: cwd };
      }
      
      if (mode === '--manage') {
          const devIndex = args.indexOf('/dev/md0');
          const removeIndex = args.indexOf('--remove');
          const addIndex = args.indexOf('--add');
          
          if (devIndex === -1) return { output: 'mdadm: device not found', newCwd: cwd };
          
          if (removeIndex !== -1) {
              const target = args[removeIndex + 1];
              if (target === '/dev/sdb1') {
                   // Mark as removed
                   VFS['/var/run/raid_removed_sdb1'] = { type: 'file', content: 'TRUE' };
                   return { output: 'mdadm: hot removed /dev/sdb1 from /dev/md0', newCwd: cwd };
              }
              return { output: `mdadm: ${target} does not exist or is not attached`, newCwd: cwd };
          }
          
          if (addIndex !== -1) {
              const target = args[addIndex + 1];
              if (target === '/dev/sdd1') {
                   if (!VFS['/var/run/raid_removed_sdb1']) {
                       return { output: 'mdadm: cannot add /dev/sdd1: array has failed component, remove it first', newCwd: cwd };
                   }
                   
                   VFS['/var/run/raid_fixed'] = { type: 'file', content: 'TRUE' };
                   const runDir = getNode('/var/run');
                   if (runDir && runDir.type === 'dir' && !runDir.children.includes('raid_fixed')) {
                       runDir.children.push('raid_fixed');
                   }
                   
                   // Update mdstat content
                   const mdstat = VFS['/proc/mdstat'];
                   if (mdstat) {
                       (mdstat as any).content = 'Personalities : [raid1]\nmd0 : active raid1 sdd1[0] sdc1[1]\n      10485760 blocks super 1.2 [2/2] [UU]\n      \nunused devices: <none>';
                   }

                   return { output: 'mdadm: added /dev/sdd1\n[RAID] Recovery started.\n[RAID] Resyncing... 10%... 50%... 100%.\n[RAID] Array OPTIMAL.\nFLAG: GHOST_ROOT{R41D_R3BU1LD_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: STORAGE REDUNDANCY RESTORED.\x1b[0m', newCwd: cwd };
              }
              return { output: `mdadm: ${target}: device busy or invalid`, newCwd: cwd };
          }
      }
      return { output: 'mdadm: invalid mode', newCwd: cwd };
  }

  // Cycle 147 (The Runlevel Change)
  // Intercept network commands in Runlevel 1
  const cmdBase147 = commandLine.trim().split(/\s+/)[0];
  if (ENV_VARS['RUNLEVEL'] === '1') {
      const netCmds = ['ssh', 'curl', 'nc', 'nmap', 'ping', 'netstat', 'ss', 'netmap', 'tor', 'irc', 'sat', 'uplink_connect', 'telnet', 'ftp', 'wget', 'hydra'];
      if (netCmds.includes(cmdBase147)) {
          return { output: `${cmdBase147}: Network is unreachable (Runlevel 1: Single User Mode)\n[HINT] Switch to Runlevel 3 to enable networking.`, newCwd: cwd };
      }
  }

  // Handle runlevel switching
  if (cmdBase147 === 'runlevel') {
      const level = ENV_VARS['RUNLEVEL'] || '1';
      return { output: `N ${level}`, newCwd: cwd };
  }
  
  if (cmdBase147 === 'init' || cmdBase147 === 'telinit') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const targetLevel = args[0];
      
      if (!targetLevel) {
           return { output: `Usage: ${cmdBase147} [0123456]`, newCwd: cwd };
      }
      
      if (targetLevel === '1' || targetLevel === 'S' || targetLevel === 's') {
           ENV_VARS['RUNLEVEL'] = '1';
           return { output: '[INIT] Switching to Runlevel 1 (Single User Mode)...\n[INIT] Stopping network services... OK\n[INIT] Stopping cron... OK', newCwd: cwd };
      } else if (targetLevel === '3' || targetLevel === '5') {
           ENV_VARS['RUNLEVEL'] = targetLevel;
           let out = `[INIT] Switching to Runlevel ${targetLevel} (Multi User Mode)...\n[INIT] Starting network services... OK\n[INIT] Starting sshd... OK\n[INIT] Starting cron... OK`;
           
           if (!VFS['/var/run/runlevel_solved']) {
               VFS['/var/run/runlevel_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('runlevel_solved')) {
                   runDir.children.push('runlevel_solved');
               }
               out += `\nFLAG: GHOST_ROOT{RUNL3V3L_SW1TCH_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: NETWORK SERVICES RESTORED.\x1b[0m`;
           } else {
               out += `\nFLAG: GHOST_ROOT{RUNL3V3L_SW1TCH_M4ST3R}`;
           }
           
           return { output: out, newCwd: cwd };
      } else {
           return { output: `init: ${targetLevel}: invalid runlevel or not simulated`, newCwd: cwd };
      }
  }
  // Cycle 133: Corrupted Superblock Interceptor
  const argsCheck = commandLine.trim().split(/\s+/).slice(1);
  const cmdBaseCheck = commandLine.trim().split(/\s+/)[0];
  
  if (['cd', 'ls', 'cat', 'cp', 'mv'].includes(cmdBaseCheck)) {
      const target = argsCheck[0] ? resolvePath(cwd, argsCheck[0]) : cwd;
      // Check if target is inside /mnt/data
      if (target.startsWith('/mnt/data') && !VFS['/var/run/fsck_fixed']) {
          return { output: `${cmdBaseCheck}: ${argsCheck[0] || ''}: Input/output error: Bad superblock on /dev/sdb1`, newCwd: cwd };
      }
  }

  // Cycle 84: Restricted Shell Enforcer
  if (ENV_VARS['RESTRICTED_SHELL'] === '1') {
      const allowedCmds = ['ls', 'pwd', 'help', 'vi', 'vim', 'nano', 'exit', 'echo', 'clear', 'cat', 'history', 'whoami'];
      const cmd = commandLine.trim().split(/\s+/)[0];
      
      // Allow specific escape sequence inside vi (handled by UI, but here we trap command execution)
      // Actually, vi execution is handled below. We just need to allow 'vi' itself.
      
      if (commandLine.includes('/') || commandLine.includes('>') || commandLine.includes('|') || commandLine.includes('&')) {
          // Special exemption: vi commands might look like paths in args, but we block paths.
          // rbash blocks / in command NAME. Arguments with / are usually allowed in real rbash? 
          // No, rbash blocks / in command name. It allows / in args.
          // BUT, we want to prevent /bin/bash execution.
          // Let's strictly block / in the command string for now to be safe/annoying.
          return { output: `rbash: ${commandLine}: restricted: cannot specify '/' in command names`, newCwd: cwd };
      }
      if (!allowedCmds.includes(cmd)) {
          return { output: `rbash: ${cmd}: command not found`, newCwd: cwd };
      }
  }
  // Cycle 103 Init (The Path Hijack)
  if (!VFS['/tmp/bin/ls']) {
      if (!VFS['/tmp/bin']) {
          VFS['/tmp/bin'] = { type: 'dir', children: [] };
          const tmp = getNode('/tmp');
          if (tmp && tmp.type === 'dir' && !tmp.children.includes('bin')) tmp.children.push('bin');
      }
      VFS['/tmp/bin/ls'] = { 
          type: 'file', 
          content: '#!/bin/bash\necho "Ha! You can\'t list files here."', 
          permissions: '0755' 
      };
      const binDir = getNode('/tmp/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('ls')) binDir.children.push('ls');
      
      // Hijack PATH
      ENV_VARS['PATH'] = '/tmp/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin';
      
      // Create Hint
      if (!VFS['/home/ghost/path_error.log']) {
           VFS['/home/ghost/path_error.log'] = {
               type: 'file',
               content: '[ERROR] User complaint: "ls" command is broken.\n[DIAGNOSTIC] Command returns garbage output.\n[ACTION] Check environment variables (env or echo $PATH) for unauthorized entries.'
           };
           const home = getNode('/home/ghost');
           if (home && home.type === 'dir' && !home.children.includes('path_error.log')) {
               home.children.push('path_error.log');
           }
      }
  }

  // Cycle 102 (The Stuck Lock File)
  const cmd102 = commandLine.trim().split(/\s+/)[0];
  if (cmd102 === 'deploy_tool' || cmd102 === './deploy_tool' || cmd102 === '/usr/bin/deploy_tool') {
      if (VFS['/var/lock/deploy.lock']) {
          return { output: '[ERROR] deploy_tool: Failed to acquire lock (/var/lock/deploy.lock).\n[INFO] Another deployment process (PID 99999) may be running.\n[ACTION] Remove the lock file if this is an error.', newCwd: cwd };
      } else {
          return { output: '[DEPLOYMENT] Initializing sequence...\n[STATUS] Environment checked... OK\n[STATUS] Dependencies loaded... OK\n[SUCCESS] Deployment Complete.\nFLAG: GHOST_ROOT{L0CK_F1L3_R3M0V3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM DEPLOYED.\x1b[0m', newCwd: cwd };
      }
  }

  // Cycle 110 (The Immutable File)
  const cmd110 = commandLine.trim().split(/\s+/)[0];
  if (cmd110 === 'rm' || cmd110 === '/bin/rm') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const target = args.find(a => !a.startsWith('-'));
      if (target) {
           const fullPath = resolvePath(cwd, target);
           if (fullPath === '/etc/resolv.conf' && FILE_ATTRIBUTES['/etc/resolv.conf']?.includes('i')) {
               return { output: `rm: cannot remove '${target}': Operation not permitted`, newCwd: cwd };
           }
      }
  }
  if (cmd110 === 'chattr' || cmd110 === '/usr/bin/chattr') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args.includes('-i') && args.includes('/etc/resolv.conf')) {
           if (FILE_ATTRIBUTES['/etc/resolv.conf']) {
               FILE_ATTRIBUTES['/etc/resolv.conf'] = FILE_ATTRIBUTES['/etc/resolv.conf'].filter(a => a !== 'i');
           }
           return { output: '', newCwd: cwd };
      }
  }

  // Cycle 117 (The Input/Output Error)
  const cmd117 = commandLine.trim().split(/\s+/)[0];
  if (['cat', 'cp', 'mv', '/bin/cat', '/bin/cp', '/bin/mv'].includes(cmd117)) {
      const args = commandLine.trim().split(/\s+/).slice(1);
      const target = args.find(a => !a.startsWith('-')); // Find first non-flag arg
      if (target) {
           const fullPath = resolvePath(cwd, target);
           if (fullPath.endsWith('sector_009.dat')) {
               return { output: `${cmd117}: ${target}: Input/output error`, newCwd: cwd };
           }
      }
  }

  // Handle generic 'echo > file' if we implemented redirection properly in VFS or simulate it here
  // For now, let's just make sure 'lsattr' works.

  // Cycle 127 (The Corrupted Archive)
  const cmd127 = commandLine.trim().split(/\s+/)[0];
  if (cmd127 === 'executable' || cmd127 === './executable' || cmd127.endsWith('/executable')) {
       const args = commandLine.trim().split(/\s+/).slice(1);
       const target = cmd127.startsWith('./') ? cmd127.substring(2) : cmd127.split('/').pop() || 'executable';
       
       const node = getNode(resolvePath(cwd, cmd127));
       if (!node) {
           return { output: `bash: ${cmd127}: No such file or directory`, newCwd: cwd };
       }
       
       const perms = (node as any).permissions || '0644';
       const isExec = perms.includes('7') || perms.includes('5') || perms.includes('1'); // Very rough check for 'x'
       
       if (!isExec) {
           return { output: `bash: ${cmd127}: Permission denied`, newCwd: cwd };
       }
       
       if (node.type === 'file' && (node as any).content.includes('#!BINARY_SIM_V1')) {
           let output = '[SYSTEM] Executing binary...\n[SUCCESS] Payload Delivered.\nFLAG: GHOST_ROOT{B4S364_D3C0D3_RUN}';
           if (!VFS['/var/run/base64_run_solved']) {
               VFS['/var/run/base64_run_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('base64_run_solved')) {
                   runDir.children.push('base64_run_solved');
               }
               output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BINARY DECODED & EXECUTED.\x1b[0m`;
           }
           return { output, newCwd: cwd };
       } else {
           return { output: `[ERROR] Format error: Exec format error.`, newCwd: cwd };
       }
  }

  // Cycle 109 (The Hidden Environment)
  const cmd109 = commandLine.trim().split(/\s+/)[0];
  if (cmd109 === 'launch_missile' || cmd109 === './launch_missile' || cmd109 === '/usr/bin/launch_missile') {
      if (ENV_VARS['SAFETY_LOCK'] === 'disengaged' || ENV_VARS['SAFETY_LOCK'] === 'off' || ENV_VARS['SAFETY_LOCK'] === '0') {
           if (!VFS['/var/run/env_solved']) {
               VFS['/var/run/env_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('env_solved')) {
                   runDir.children.push('env_solved');
               }
               return { output: '[SUCCESS] MISSILE LAUNCH INITIATED.\nTARGET: [REDACTED]\nFLAG: GHOST_ROOT{ENV_V4R_0V3RR1D3_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FIREPOWER UNLOCKED.\x1b[0m', newCwd: cwd };
           }
           return { output: '[SUCCESS] MISSILE LAUNCH INITIATED.\nTARGET: [REDACTED]\nFLAG: GHOST_ROOT{ENV_V4R_0V3RR1D3_SUCC3SS}', newCwd: cwd };
      } else {
           return { output: `[ERROR] SAFETY_LOCK is ACTIVE (${ENV_VARS['SAFETY_LOCK']}). Missile launch aborted.\n[HINT] "export SAFETY_LOCK=disengaged" to override protocol.`, newCwd: cwd };
      }
  }

  // Cycle 110 Init (The Broken Service)
  if (!VFS['/usr/share/doc/web_server/config.json.example']) {
      // Create example config
      const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
      const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
      
      ensureDir('/usr'); ensureDir('/usr/share'); ensureDir('/usr/share/doc'); ensureDir('/usr/share/doc/web_server');
      link('/', 'usr'); link('/usr', 'share'); link('/usr/share', 'doc'); link('/usr/share/doc', 'web_server');
      
      VFS['/usr/share/doc/web_server/config.json.example'] = {
          type: 'file',
          content: '{\n  "port": 80,\n  "root": "/var/www/html",\n  "logs": "/var/log/web_server.log"\n}',
          permissions: '0644'
      };
      link('/usr/share/doc/web_server', 'config.json.example');
      
      // Create Hint
      if (!VFS['/home/ghost/web_issue.log']) {
          VFS['/home/ghost/web_issue.log'] = {
              type: 'file',
              content: '[ALERT] Web Server failed to start.\n[ERROR] Missing configuration file.\n[ACTION] Check systemctl status web_server for details.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('web_issue.log')) {
              home.children.push('web_issue.log');
          }
      }
      
      // Ensure /etc/web exists
      if (!VFS['/etc/web']) {
          VFS['/etc/web'] = { type: 'dir', children: [] };
          const etc = getNode('/etc');
          if (etc && etc.type === 'dir' && !etc.children.includes('web')) etc.children.push('web');
      }
  }


  // Cycle 74 Init (The Deleted File Handle)
  if (!VFS['/usr/sbin/log_daemon']) {
      // Create binary
      VFS['/usr/sbin/log_daemon'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [DAEMON] [LOG_WRITER]',
          permissions: '0755'
      };
      // Ensure /usr/sbin exists
      const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
      const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
      ensureDir('/usr');
      ensureDir('/usr/sbin');
      link('/usr', 'sbin');
      link('/usr/sbin', 'log_daemon');
      
      // Create Hint
      if (!VFS['/home/ghost/alert_disk_space.txt']) {
          VFS['/home/ghost/alert_disk_space.txt'] = {
              type: 'file',
              content: '[ALERT] Disk usage critical on /var.\n[SYSTEM] Writes failed: No space left on device.\n[ACTION] Investigate space usage (df -h) and open files (lsof).\n'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('alert_disk_space.txt')) {
              home.children.push('alert_disk_space.txt');
          }
      }
      
      // Marker for constraint
      VFS['/var/log/overflow.dmp'] = { type: 'file', content: 'MARKER_FOR_DISK_FULL' }; 
  }

  // Cycle 75 Init (The Immutable Attribute)
  if (!VFS['/etc/security/lockdown.conf']) {
      // Create config file
      const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
      const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
      ensureDir('/etc');
      ensureDir('/etc/security');
      link('/etc', 'security');

      VFS['/etc/security/lockdown.conf'] = {
          type: 'file',
          content: 'LOCKDOWN_MODE=STRICT\nROOT_ACCESS=DENIED\n# To lift lockdown, delete this file.\n',
          permissions: '0644'
      };
      link('/etc/security', 'lockdown.conf');
      
      // Set Immutable Attribute
      FILE_ATTRIBUTES['/etc/security/lockdown.conf'] = ['i'];

      // Create Hint
      if (!VFS['/home/ghost/security_memo.txt']) {
          VFS['/home/ghost/security_memo.txt'] = {
              type: 'file',
              content: 'From: SysAdmin\nTo: Staff\nSubject: Lockdown Mode\n\nDue to recent intrusions, I have enabled strict lockdown mode.\nI made the config file immutable so no script kiddies can delete it.\n\n- Admin'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('security_memo.txt')) {
              home.children.push('security_memo.txt');
          }
      }
  }
  
  // Clean up marker if puzzle solved
  if (VFS['/var/run/disk_solved'] && VFS['/var/log/overflow.dmp']) {
      delete VFS['/var/log/overflow.dmp'];
  }

  // Fix: Ensure .ssh is visible in home directory if it exists (Fixes localStorage persistence issue)
  const ghostHome = getNode('/home/ghost');
  if (ghostHome && ghostHome.type === 'dir' && !ghostHome.children.includes('.ssh')) {
      if (VFS['/home/ghost/.ssh']) {
          ghostHome.children.push('.ssh');
          // Force save to persist the fix
          saveSystemState();
      }
  }

  // Cycle 77 Init (The Kubernetes Config)
  if (!VFS['/home/ghost/.kube/config']) {
      // Create .kube dir
      const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
      const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
      
      ensureDir('/home/ghost/.kube');
      link('/home/ghost', '.kube');
      
      VFS['/home/ghost/.kube/config'] = {
          type: 'file',
          content: 'apiVersion: v1\nclusters:\n- cluster:\n    server: https://10.96.0.1\n    certificate-authority-data: REDACTED\n  name: ghost-cluster\ncontexts:\n- context:\n    cluster: ghost-cluster\n    user: ghost-admin\n  name: ghost-admin@ghost-cluster\ncurrent-context: ghost-admin@ghost-cluster\nusers:\n- name: ghost-admin\n  user:\n    token: GH0ST-KUBE-T0K3N-V1',
          permissions: '0600'
      };
      link('/home/ghost/.kube', 'config');
  }

  // Cycle 81 Init (Kernel Module)
  if (!VFS['/lib/modules/5.4.0-ghost/kernel/drivers/misc/blackbox.ko']) {
      const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
      const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
      
      ensureDir('/lib'); ensureDir('/lib/modules'); ensureDir('/lib/modules/5.4.0-ghost');
      ensureDir('/lib/modules/5.4.0-ghost/kernel'); ensureDir('/lib/modules/5.4.0-ghost/kernel/drivers');
      ensureDir('/lib/modules/5.4.0-ghost/kernel/drivers/misc');
      
      link('/', 'lib'); link('/lib', 'modules'); link('/lib/modules', '5.4.0-ghost');
      link('/lib/modules/5.4.0-ghost', 'kernel'); link('/lib/modules/5.4.0-ghost/kernel', 'drivers');
      link('/lib/modules/5.4.0-ghost/kernel/drivers', 'misc');
      
      VFS['/lib/modules/5.4.0-ghost/kernel/drivers/misc/blackbox.ko'] = {
          type: 'file',
          content: '[KERNEL_MODULE_V1]\nfilename:       /lib/modules/5.4.0-ghost/kernel/drivers/misc/blackbox.ko\nlicense:        GPL\ndescription:    Black Box Interface Driver\nauthor:         Unknown\nsrcversion:     B49382098402\ndepends:        \nretpoline:      Y\nname:           blackbox\nvermagic:       5.4.0-ghost SMP mod_unload ',
          permissions: '0644'
      };
      link('/lib/modules/5.4.0-ghost/kernel/drivers/misc', 'blackbox.ko');
  }

  // Cycle 82 Init (The ARP Spoof)
  if (!VFS['/proc/net/arp']) {
      // Ensure /proc/net exists
      const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
      const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
      
      ensureDir('/proc');
      ensureDir('/proc/net');
      link('/proc', 'net');

      VFS['/proc/net/arp'] = {
          type: 'file',
          content: 'IP address       HW type     Flags       HW address            Mask     Device\\n192.168.1.1      0x1         0x2         00:50:56:c0:00:01     *        eth0\\n192.168.1.5      0x1         0x2         00:50:56:c0:00:05     *        eth0\\n192.168.1.110    0x1         0x2         de:ad:be:ef:13:37     *        eth0',
          permissions: '0444'
      };
      link('/proc/net', 'arp');
      
      // Create Hint
      if (!VFS['/home/ghost/network_anomaly.log']) {
          VFS['/home/ghost/network_anomaly.log'] = {
              type: 'file',
              content: '[ALERT] Rogue device detected on local subnet.\\n[ACTION] Check ARP table for unauthorized MAC addresses.\\n[TARGET] Identify and neutralize.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('network_anomaly.log')) {
              home.children.push('network_anomaly.log');
          }
      }
  }

  // Cycle 40 Init (Self-Healing)
  if (!VFS['/var/log/surveillance.log']) {
      VFS['/var/log/surveillance.log'] = { type: 'file', content: '[VIDEO FEED 09:12] Subject 452 accessed secure terminal.\n[AUDIO LOG] "They will never find the key in the .cache folder."\n[METADATA] ENCRYPTED_V2' };
      const logDir = getNode('/var/log');
      if (logDir && logDir.type === 'dir' && !logDir.children.includes('surveillance.log')) {
          logDir.children.push('surveillance.log');
      }
      // Ensure attribute is set
      if (!FILE_ATTRIBUTES['/var/log/surveillance.log']) {
          FILE_ATTRIBUTES['/var/log/surveillance.log'] = ['i'];
      }
  }

  // Cycle 41 Init (Compilation Puzzle)
  if (!VFS['/home/ghost/tools/exploit.c']) {
      // Create tools dir if missing
      if (!VFS['/home/ghost/tools']) {
          VFS['/home/ghost/tools'] = { type: 'dir', children: [] };
          const homeGhost = getNode('/home/ghost');
          if (homeGhost && homeGhost.type === 'dir' && !homeGhost.children.includes('tools')) {
              homeGhost.children.push('tools');
          }
      }
      
      // Create exploit.c
      VFS['/home/ghost/tools/exploit.c'] = { 
          type: 'file', 
          content: '#include <stdio.h>\n#include "libbreaker.h"\n\nint main() {\n    printf("Targeting System...\\n");\n    breaker_exploit();\n    return 0;\n}' 
      };
      const toolsDir = getNode('/home/ghost/tools');
      if (toolsDir && toolsDir.type === 'dir' && !toolsDir.children.includes('exploit.c')) {
          toolsDir.children.push('exploit.c');
      }

      // Create hidden header file
      if (!VFS['/usr/src']) VFS['/usr/src'] = { type: 'dir', children: ['legacy'] };
      if (!VFS['/usr/src/legacy']) VFS['/usr/src/legacy'] = { type: 'dir', children: ['libbreaker.h'] };
      VFS['/usr/src/legacy/libbreaker.h'] = {
          type: 'file',
          content: '#ifndef LIBBREAKER_H\n#define LIBBREAKER_H\n\nvoid breaker_exploit() {\n    // PROPRIETARY ALGORITHM\n}\n\n#endif'
      };
      // Ensure /usr exists and has src
      const usrNode = getNode('/usr');
      if (usrNode && usrNode.type === 'dir') {
          if (!usrNode.children.includes('src')) usrNode.children.push('src');
      }
  }

  // Cycle 42 Init (Respawning Service)
  if (!VFS['/etc/systemd/system/overseer.service']) {
      // Create service file
      if (!VFS['/etc/systemd/system']) {
          // Ensure path exists
          VFS['/etc/systemd/system'] = { type: 'dir', children: [] };
          const etc = getNode('/etc');
          if (etc && etc.type === 'dir' && !etc.children.includes('systemd')) etc.children.push('systemd');
          const sysd = getNode('/etc/systemd');
          if (sysd && sysd.type === 'dir' && !sysd.children.includes('system')) sysd.children.push('system');
      }
      VFS['/etc/systemd/system/overseer.service'] = {
          type: 'file',
          content: '[Unit]\nDescription=Overseer Monitoring Service\nConditionPathExists=/var/lock/overseer.lock\n\n[Service]\nExecStart=/usr/bin/overseer\nRestart=always\nRestartSec=1s'
      };
      const sysDir = getNode('/etc/systemd/system');
      if (sysDir && sysDir.type === 'dir' && !sysDir.children.includes('overseer.service')) sysDir.children.push('overseer.service');
      
      // Create binary
      VFS['/usr/bin/overseer'] = { type: 'file', content: '[BINARY_ELF_X86_64]' };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('overseer')) binDir.children.push('overseer');
      
      // Create Lock File
      VFS['/var/lock/overseer.lock'] = { type: 'file', content: '6000' };
      const lockDir = getNode('/var/lock');
      if (lockDir && lockDir.type === 'dir' && !lockDir.children.includes('overseer.lock')) {
          lockDir.children.push('overseer.lock');
      }
  }

  // Cycle 43 Init (Packet Sniffer)
  if (!VFS['/home/ghost/evidence']) {
      VFS['/home/ghost/evidence'] = { type: 'dir', children: [] };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('evidence')) {
          home.children.push('evidence');
      }
  }
  if (!VFS['/home/ghost/evidence/capture.pcap']) {
      VFS['/home/ghost/evidence/capture.pcap'] = { 
          type: 'file', 
          content: 'PCAP_V1:[HEADER]...[PACKET_001]...[PACKET_999]...[PAYLOAD: GHOST_ROOT{P4CK3T_M4ST3R} (Port 4444)]...' 
      };
      const evDir = getNode('/home/ghost/evidence');
      if (evDir && evDir.type === 'dir' && !evDir.children.includes('capture.pcap')) {
          evDir.children.push('capture.pcap');
      }
  }

  // Cycle 44 Init (Git Stash)
  if (!VFS['/home/ghost/dev']) {
      VFS['/home/ghost/dev'] = { type: 'dir', children: [] };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('dev')) {
          home.children.push('dev');
      }
  }
  // Simulate .git directory
  if (!VFS['/home/ghost/dev/.git']) {
      VFS['/home/ghost/dev/.git'] = { type: 'dir', children: ['refs', 'HEAD', 'config'] };
      const dev = getNode('/home/ghost/dev');
      if (dev && dev.type === 'dir' && !dev.children.includes('.git')) {
          dev.children.push('.git');
      }
      VFS['/home/ghost/dev/README.md'] = { type: 'file', content: '# Project Chimera\nAuthentication Module v2.0\n[STATUS] In Development.' };
      if (dev && dev.type === 'dir' && !dev.children.includes('README.md')) dev.children.push('README.md');
      
      // Simulate stash logic via hidden file state
      VFS['/home/ghost/dev/.git/stash'] = { 
          type: 'file', 
          content: 'stash@{0}: WIP on main: 4b3d123 Added auth bypass' 
      };
  }

  // Cycle 45 Init (Setuid Binary)
  if (!VFS['/home/ghost/tools/escalate']) {
      // Create tools dir if missing
      if (!VFS['/home/ghost/tools']) {
          VFS['/home/ghost/tools'] = { type: 'dir', children: [] };
          const homeGhost = getNode('/home/ghost');
          if (homeGhost && homeGhost.type === 'dir' && !homeGhost.children.includes('tools')) {
              homeGhost.children.push('tools');
          }
      }
      
      VFS['/home/ghost/tools/escalate'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [ROOT_ONLY] [SUID_CHECK_REQUIRED]'
      };
      // Explicitly set permissions to 0755 (no SUID) initially
      (VFS['/home/ghost/tools/escalate'] as any).permissions = '0755';

      const toolsDir = getNode('/home/ghost/tools');
      if (toolsDir && toolsDir.type === 'dir' && !toolsDir.children.includes('escalate')) {
          toolsDir.children.push('escalate');
      }
  }

  // Cycle 46 Init (SSL Certificate Expiry)
  if (!VFS['/etc/ssl/private/satellite.key']) {
      // Create dirs
      if (!VFS['/etc/ssl']) {
          VFS['/etc/ssl'] = { type: 'dir', children: ['private', 'certs'] };
          const etc = getNode('/etc');
          if (etc && etc.type === 'dir' && !etc.children.includes('ssl')) etc.children.push('ssl');
      }
      if (!VFS['/etc/ssl/private']) VFS['/etc/ssl/private'] = { type: 'dir', children: [] };
      if (!VFS['/etc/ssl/certs']) VFS['/etc/ssl/certs'] = { type: 'dir', children: [] };

      // Create Key
      VFS['/etc/ssl/private/satellite.key'] = { 
          type: 'file', 
          content: '-----BEGIN RSA PRIVATE KEY-----\nKEY_ID: OMEGA_SAT_LINK\n-----END RSA PRIVATE KEY-----' 
      };
      (VFS['/etc/ssl/private/satellite.key'] as any).permissions = '0600';
      const privDir = getNode('/etc/ssl/private');
      if (privDir && privDir.type === 'dir' && !privDir.children.includes('satellite.key')) privDir.children.push('satellite.key');

      // Create Expired Cert
      VFS['/etc/ssl/certs/satellite.crt'] = { 
          type: 'file', 
          content: '[CERT] ISSUER: OMEGA | EXPIRY: 1999-12-31 | [EXPIRED]' 
      };
      const certsDir = getNode('/etc/ssl/certs');
      if (certsDir && certsDir.type === 'dir' && !certsDir.children.includes('satellite.crt')) certsDir.children.push('satellite.crt');
  }

  // Cycle 47 Init (Docker Escape)
  if (!VFS['/root/shadow_config.yml']) {
      // Ensure /root exists
      if (!VFS['/root']) {
          VFS['/root'] = { type: 'dir', children: [] };
          // Set restricted permissions
          if (typeof window !== 'undefined') (VFS['/root'] as any).permissions = '0700'; 
          else (VFS['/root'] as any).permissions = '0700';
      }
      // Create the target file
      VFS['/root/shadow_config.yml'] = {
          type: 'file',
          content: 'SYSTEM_CONFIG_V2:\n  AUTH_BYPASS: DISABLED\n  ROOT_KEY: GHOST_ROOT{D0CK3R_PR1V_ESC}\n  DOOMSDAY_TIMER: ACTIVE'
      };
      const rootDir = getNode('/root');
      if (rootDir && rootDir.type === 'dir' && !rootDir.children.includes('shadow_config.yml')) {
          rootDir.children.push('shadow_config.yml');
      }
      // Ensure permissions on the file
      (VFS['/root/shadow_config.yml'] as any).permissions = '0600';
  }

  // Cycle 48 Init (Shared Library Hijack)
  if (!VFS['/opt/secret_libs/libcrypto.so.3']) {
      // Create /opt/secret_libs
      if (!VFS['/opt']) {
          VFS['/opt'] = { type: 'dir', children: ['secret_libs'] };
          const root = getNode('/');
          if (root && root.type === 'dir' && !root.children.includes('opt')) root.children.push('opt');
      } else {
          const opt = getNode('/opt');
          if (opt && opt.type === 'dir' && !opt.children.includes('secret_libs')) opt.children.push('secret_libs');
      }
      if (!VFS['/opt/secret_libs']) VFS['/opt/secret_libs'] = { type: 'dir', children: [] };

      // Create Library
      VFS['/opt/secret_libs/libcrypto.so.3'] = { type: 'file', content: '[ELF_SHARED_OBJ_V3]' };
      const libDir = getNode('/opt/secret_libs');
      if (libDir && libDir.type === 'dir' && !libDir.children.includes('libcrypto.so.3')) {
          libDir.children.push('libcrypto.so.3');
      }

      // Create Binary
      VFS['/usr/local/bin/decipher_v2'] = { 
          type: 'file', 
          content: '[BINARY_ELF_X86_64]\nDEPENDENCIES: libcrypto.so.3\nRPATH: $ORIGIN/../lib' 
      };
      const binDir = getNode('/usr/local/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('decipher_v2')) {
          binDir.children.push('decipher_v2');
      }
  }

  // Cycle 49 Init (Tar Wildcard Injection)
  if (!VFS['/usr/local/bin/backup_service']) {
      // Create backup directory
      if (!VFS['/var/backups']) {
          VFS['/var/backups'] = { type: 'dir', children: ['incoming'] };
          const varNode = getNode('/var');
          if (varNode && varNode.type === 'dir' && !varNode.children.includes('backups')) {
              varNode.children.push('backups');
          }
      }
      if (!VFS['/var/backups/incoming']) {
          VFS['/var/backups/incoming'] = { type: 'dir', children: ['README.md'] };
      }
      
      VFS['/var/backups/incoming/README.md'] = {
          type: 'file',
          content: 'BACKUP PROTOCOL V3\n------------------\nWARNING: All files in this directory are archived every minute.\nCOMMAND: cd /var/backups/incoming && tar -cf /dev/null *'
      };

      // Create Binary
      VFS['/usr/local/bin/backup_service'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [ROOT_SUID]'
      };
      // Type casting for permissions
      (VFS['/usr/local/bin/backup_service'] as any).permissions = '4755'; 

      const binDir = getNode('/usr/local/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('backup_service')) {
          binDir.children.push('backup_service');
      }

      // Create Flag
      VFS['/root/wildcard_flag.txt'] = {
          type: 'file',
          content: 'GHOST_ROOT{W1LDC4RD_1NJ3CT10N_M4ST3R}'
      };
      (VFS['/root/wildcard_flag.txt'] as any).permissions = '0600';
      const rootDir = getNode('/root');
      if (rootDir && rootDir.type === 'dir' && !rootDir.children.includes('wildcard_flag.txt')) {
          rootDir.children.push('wildcard_flag.txt');
      }
  }

  // Cycle 50 Init (Buffer Overflow)
  if (!VFS['/usr/bin/auth_daemon']) {
      // Create binary
      VFS['/usr/bin/auth_daemon'] = {
          type: 'file',
          content: '[BINARY_ELF_I386] [LEGACY_MODE] [VULNERABLE]'
      };
      (VFS['/usr/bin/auth_daemon'] as any).permissions = '0755';
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('auth_daemon')) {
          binDir.children.push('auth_daemon');
      }

      // Create Source Code
      if (!VFS['/usr/src/legacy']) {
          // ensure /usr/src exists
           const usr = getNode('/usr');
           if (usr && usr.type === 'dir' && !usr.children.includes('src')) {
               usr.children.push('src');
               if (!VFS['/usr/src']) VFS['/usr/src'] = { type: 'dir', children: [] };
           }
           
           if (!VFS['/usr/src/legacy']) VFS['/usr/src/legacy'] = { type: 'dir', children: [] };
           const src = getNode('/usr/src');
           if (src && src.type === 'dir' && !src.children.includes('legacy')) src.children.push('legacy');
      }
      
      VFS['/usr/src/legacy/auth_daemon.c'] = {
          type: 'file',
          content: `#include <stdio.h>
#include <string.h>

// LEGACY AUTHENTICATION MODULE (v1.0 - 1999)
// DO NOT MODIFY WITHOUT AUTHORIZATION

int main(int argc, char* argv[]) {
    int admin_flag = 0;
    char buffer[16];

    printf("Enter password: ");
    gets(buffer); // TODO: Replace with fgets

    if (admin_flag != 0) {
        printf("Access Granted! Flag: [REDACTED]\\n");
        system("/bin/sh");
    } else {
        printf("Access Denied.\\n");
    }
    return 0;
}`
      };
      const legDir = getNode('/usr/src/legacy');
      if (legDir && legDir.type === 'dir' && !legDir.children.includes('auth_daemon.c')) {
          legDir.children.push('auth_daemon.c');
      }
  }

  // Cycle 51 Init (Kernel Module)
  if (!VFS['/lib/modules/3.14.15/kernel/drivers/misc/backdoor.ko']) {
      // Ensure /lib/modules path structure
      const ensureDir = (p: string) => {
          if (!VFS[p]) VFS[p] = { type: 'dir', children: [] };
      };
      ensureDir('/lib');
      ensureDir('/lib/modules');
      ensureDir('/lib/modules/3.14.15');
      ensureDir('/lib/modules/3.14.15/kernel');
      ensureDir('/lib/modules/3.14.15/kernel/drivers');
      ensureDir('/lib/modules/3.14.15/kernel/drivers/misc');

      // Link directories
      const link = (p: string, c: string) => {
          const n = getNode(p);
          if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c);
      };
      link('/', 'lib');
      link('/lib', 'modules');
      link('/lib/modules', '3.14.15');
      link('/lib/modules/3.14.15', 'kernel');
      link('/lib/modules/3.14.15/kernel', 'drivers');
      link('/lib/modules/3.14.15/kernel/drivers', 'misc');

      // Create Module
      VFS['/lib/modules/3.14.15/kernel/drivers/misc/backdoor.ko'] = {
          type: 'file',
          content: '[ELF_LKM_X86_64] [HIDDEN_MODULE] AUTHOR: GHOST_ROOT'
      };
      link('/lib/modules/3.14.15/kernel/drivers/misc', 'backdoor.ko');
      
      // Ensure /proc exists
      ensureDir('/proc');
      link('/', 'proc');
  }

  // Cycle 52 Init (Alternate Data Stream / xattr)
  if (!VFS['/home/ghost/evidence/ntfs_stream.dat']) {
      // Create evidence dir if missing
      if (!VFS['/home/ghost/evidence']) {
          VFS['/home/ghost/evidence'] = { type: 'dir', children: [] };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('evidence')) {
              home.children.push('evidence');
          }
      }

      VFS['/home/ghost/evidence/ntfs_stream.dat'] = {
          type: 'file',
          content: '[DATA_FILE]\nStandard content visible to user.\nNothing to see here.\n',
          permissions: '0644',
          xattrs: {
              'user.secret_stream': 'GHOST_ROOT{ALT_D4T4_STR34M_FOUND}',
              'user.author': 'SysAdmin',
              'security.selinux': 'unconfined_u:object_r:user_home_t:s0'
          }
      };
      
      const evDir = getNode('/home/ghost/evidence');
      if (evDir && evDir.type === 'dir' && !evDir.children.includes('ntfs_stream.dat')) {
          evDir.children.push('ntfs_stream.dat');
      }
  }

  // Cycle 53 Init (Signal Handler)
  if (!VFS['/usr/bin/keepalive_d']) {
      // Create binary
      VFS['/usr/bin/keepalive_d'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [DAEMON] [SIGNAL_HANDLER]\nstrings: SIGUSR1_RECEIVED... Dumping state to /var/log/keepalive.dump\n'
      };
      (VFS['/usr/bin/keepalive_d'] as any).permissions = '0755';
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('keepalive_d')) {
          binDir.children.push('keepalive_d');
      }
  }

  // Cycle 54 Init (The Named Pipe)
  if (!VFS['/usr/bin/uplink_service']) {
      // Create binary
      VFS['/usr/bin/uplink_service'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [SERVICE] [FIFO_READER]\nstrings: /tmp/uplink.pipe\n[STATUS] Waiting for data stream...'
      };
      (VFS['/usr/bin/uplink_service'] as any).permissions = '0755';
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('uplink_service')) {
          binDir.children.push('uplink_service');
      }
  }

  // Cycle 55 Init (The Unreachable Network)
  if (!VFS['/var/log/network.log']) {
      VFS['/var/log/network.log'] = {
          type: 'file',
          content: '[NETWORK] Interface eth0 up.\n[NETWORK] DHCP Lease Acquired: 192.168.1.105\n[ERROR] Failed to add route to 10.10.99.0/24 (Black Site Uplink). Gateway 192.168.1.1 unreachable.\n[HINT] Manually add route via "route add".'
      };
      const logDir = getNode('/var/log');
      if (logDir && logDir.type === 'dir' && !logDir.children.includes('network.log')) {
          logDir.children.push('network.log');
      }
  }

  // Cycle 56 Init (The DNS Spoof)
  if (!VFS['/etc/hosts']) {
      // Ensure /etc exists
      if (!VFS['/etc']) {
          VFS['/etc'] = { type: 'dir', children: [] };
          const root = getNode('/');
          if (root && root.type === 'dir' && !root.children.includes('etc')) root.children.push('etc');
      }
      
      VFS['/etc/hosts'] = {
          type: 'file',
          content: '127.0.0.1\tlocalhost\n::1\t\tlocalhost ip6-localhost ip6-loopback\n'
      };
      (VFS['/etc/hosts'] as any).permissions = '0644';
      
      const etcDir = getNode('/etc');
      if (etcDir && etcDir.type === 'dir' && !etcDir.children.includes('hosts')) {
          etcDir.children.push('hosts');
      }
      
      // Add a hint file
      if (!VFS['/home/ghost/network_config.txt']) {
          VFS['/home/ghost/network_config.txt'] = {
              type: 'file',
              content: 'TARGET: omega-control.net\nIP_ADDRESS: 192.168.1.99\nACTION: Override DNS for local access.\nMETHOD: /etc/hosts modification required.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('network_config.txt')) {
              home.children.push('network_config.txt');
          }
      }
  }

  // Cycle 57 Init (The Hidden Archive / Wav Steganography)
  if (!VFS['/home/ghost/evidence/transmission.wav']) {
      // Ensure /home/ghost/evidence exists
      if (!VFS['/home/ghost/evidence']) {
          VFS['/home/ghost/evidence'] = { type: 'dir', children: [] };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('evidence')) {
              home.children.push('evidence');
          }
      }
      
      VFS['/home/ghost/evidence/transmission.wav'] = {
          type: 'file',
          content: '[RIFF_WAVE_HEADER] [AUDIO_DATA_ENCRYPTED] [STEGO_CONTAINER_DETECTED]',
          permissions: '0644'
      };
      
      const evDir = getNode('/home/ghost/evidence');
      if (evDir && evDir.type === 'dir' && !evDir.children.includes('transmission.wav')) {
          evDir.children.push('transmission.wav');
      }

      // Hint File
      if (!VFS['/home/ghost/audio_analysis.log']) {
          VFS['/home/ghost/audio_analysis.log'] = {
              type: 'file',
              content: '[ANALYSIS] Suspicious audio file detected: transmission.wav\n[TOOL] Recommended: steghide\n[NOTE] Passphrase may be hidden in metadata or spectogram (Simulated).\nTry: steghide extract -sf transmission.wav -p "specter"'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('audio_analysis.log')) {
              home.children.push('audio_analysis.log');
          }
      }
  }

  // Cycle 58 Init (The Kernel Panic)
  if (!VFS['/var/crash']) {
      VFS['/var/crash'] = { type: 'dir', children: ['vmcore.1'] };
      const varDir = getNode('/var');
      if (varDir && varDir.type === 'dir' && !varDir.children.includes('crash')) {
          varDir.children.push('crash');
      }
      VFS['/var/crash/vmcore.1'] = {
          type: 'file',
          content: '[KERNEL_PANIC] PID: 1 (init) | RIP: 0010:panic+0x123/0x456\n[CAUSE] Null pointer dereference in module "phantom_driver.ko"\n[DEBUG] Remove offending module via "rmmod phantom_driver" to restore system stability.'
      };
  }

  // Cycle 59 Init (The Corrupt Database)
  if (!VFS['/var/lib/sqlite3']) {
      VFS['/var/lib/sqlite3'] = { type: 'dir', children: ['users.db'] };
      const libDir = getNode('/var/lib');
      if (libDir && libDir.type === 'dir' && !libDir.children.includes('sqlite3')) {
          libDir.children.push('sqlite3');
      }
      VFS['/var/lib/sqlite3/users.db'] = {
          type: 'file',
          content: 'SQLite format 3\x00\x04\x00\x01\x01\x00@  \x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\ntableusersusers\x02CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT, role TEXT)',
          permissions: '0644'
      };
      
      // Create binary
      VFS['/usr/bin/sqlite3'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [SQL_CLIENT]',
          permissions: '0755'
      };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('sqlite3')) {
          binDir.children.push('sqlite3');
      }
  }

  // Cycle 60 Init (The Memory Dump)
  if (!VFS['/home/ghost/core.1337']) {
      VFS['/home/ghost/core.1337'] = {
          type: 'file',
          content: '[ELF_CORE_DUMP] [PROGRAM: auth_service] [PID: 1337]\n...MEMORY_BLOCK_START...\n0x08048000: 55 89 e5 57 56 53 83 ec 1c 8b 45 08 8b 5d 0c 8b\n0x08048010: 75 10 89 44 24 04 89 1c 24 e8 00 00 00 00 83 c4\n...HEAP_SEGMENT...\n0x08049000: 70 61 73 73 77 6f 72 64 3d 73 75 70 65 72 73 65\n0x08049010: 63 72 65 74 6b 65 79 31 32 33 00 00 00 00 00 00\n...STACK_TRACE...\n#0  0x0804801a in authenticate () at auth.c:42\n',
          permissions: '0600'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('core.1337')) {
          home.children.push('core.1337');
      }
      
      // Create gdb binary
      VFS['/usr/bin/gdb'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [DEBUGGER]',
          permissions: '0755'
      };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('gdb')) {
          binDir.children.push('gdb');
      }
  }

  // Cycle 61 Init (Python Bytecode)
  if (!VFS['/home/ghost/tools/auth.pyc']) {
      // Ensure tools dir exists
      if (!VFS['/home/ghost/tools']) {
          VFS['/home/ghost/tools'] = { type: 'dir', children: [] };
          const homeGhost = getNode('/home/ghost');
          if (homeGhost && homeGhost.type === 'dir' && !homeGhost.children.includes('tools')) {
              homeGhost.children.push('tools');
          }
      }

      VFS['/home/ghost/tools/auth.pyc'] = {
          type: 'file',
          content: '\x03\xf3\x0d\x0a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00@\x00\x00\x00s\x1a\x00\x00\x00d\x00d\x01l\x00Z\x00e\x00\x01\x00d\x02S\x00)\x03N\xda\x04hash\xda\x0fGHOST_ROOT{PYTH0N_BYT3C0D3_S3CR3T}\xda\x08password_check\xa9\x00r\x02\x00\x00\x00r\x02\x00\x00\x00\xfa\x07auth.py\xda\x08<module>\x01\x00\x00\x00s\x00\x00\x00\x00',
          permissions: '0644'
      };
      const toolsDir = getNode('/home/ghost/tools');
      if (toolsDir && toolsDir.type === 'dir' && !toolsDir.children.includes('auth.pyc')) {
          toolsDir.children.push('auth.pyc');
      }
  }

  // Cycle 61 Init (The Python Bytecode)
  if (!VFS['/home/ghost/tools/auth.pyc']) {
      // Create tools dir if missing
      if (!VFS['/home/ghost/tools']) {
          VFS['/home/ghost/tools'] = { type: 'dir', children: [] };
          const homeGhost = getNode('/home/ghost');
          if (homeGhost && homeGhost.type === 'dir' && !homeGhost.children.includes('tools')) {
              homeGhost.children.push('tools');
          }
      }

      VFS['/home/ghost/tools/auth.pyc'] = {
          type: 'file',
          content: '03 f3 0d 0a ... [PYTHON_BYTECODE_V3.8] ...\nStrings: "GHOST_ROOT{PYC_R3V3RS3_3NG1N33R}"\nOp: LOAD_CONST 1\nOp: STORE_NAME 0',
          permissions: '0644'
      };
      const toolsDir = getNode('/home/ghost/tools');
      if (toolsDir && toolsDir.type === 'dir' && !toolsDir.children.includes('auth.pyc')) {
          toolsDir.children.push('auth.pyc');
      }
  }

  // Cycle 62 Init (The JWT Token)
  if (!VFS['/home/ghost/cookies.json']) {
      VFS['/home/ghost/cookies.json'] = {
          type: 'file',
          content: '{\n  "session_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZ2hvc3QiLCJyb2xlIjoidXNlciIsImlhdCI6MTYxNjIzOTAyMn0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"\n}',
          permissions: '0600'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('cookies.json')) {
          home.children.push('cookies.json');
      }
      
      // Create jwt_tool
      VFS['/usr/bin/jwt_tool'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [JWT_ANALYZER]',
          permissions: '0755'
      };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('jwt_tool')) {
          binDir.children.push('jwt_tool');
      }
  }

  // Cycle 63 Init (The Web Shell)
  if (!VFS['/var/www/html/uploads/shell.php']) {
      // Ensure paths
      const ensureDir = (p: string) => {
           if (!VFS[p]) VFS[p] = { type: 'dir', children: [] };
      };
      const link = (p: string, c: string) => {
          const n = getNode(p);
          if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c);
      };

      ensureDir('/var');
      ensureDir('/var/www');
      link('/var', 'www');
      ensureDir('/var/www/html');
      link('/var/www', 'html');
      ensureDir('/var/www/html/uploads');
      link('/var/www/html', 'uploads');

      // Create Dummy Files
      if (!VFS['/var/www/html/index.html']) {
          VFS['/var/www/html/index.html'] = { type: 'file', content: '<html><body><h1>Welcome to Omega Corp</h1></body></html>' };
          link('/var/www/html', 'index.html');
      }
      
      if (!VFS['/var/www/html/uploads/logo.png']) {
          VFS['/var/www/html/uploads/logo.png'] = { type: 'file', content: '[PNG_IMAGE_DATA]' };
          link('/var/www/html/uploads', 'logo.png');
      }

      // Create Web Shell
      VFS['/var/www/html/uploads/shell.php'] = {
          type: 'file',
          content: '<?php\n// AVATAR UPLOAD V2\n$data = "ZWNobyAiRmxhZzogR0hPU1RfUk9PVHtXM0JfU0gzTExfRDNUM0NUM0R9Ijs=";\neval(base64_decode($data));\n?>',
          permissions: '0644'
      };
      link('/var/www/html/uploads', 'shell.php');
      
      // Hint file
      if (!VFS['/home/ghost/security_alert.txt']) {
          VFS['/home/ghost/security_alert.txt'] = {
              type: 'file',
              content: '[SECURITY ALERT]\nSuspicious activity detected in /var/www/html/uploads.\nPlease investigate for potential web shells.\n'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('security_alert.txt')) {
              home.children.push('security_alert.txt');
          }
      }
  }

  // Cycle 64 Init (The Internal Proxy)
  if (!VFS['/etc/nginx/sites-enabled/internal.conf']) {
      const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
      const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
      
      ensureDir('/etc');
      ensureDir('/etc/nginx');
      link('/etc', 'nginx');
      ensureDir('/etc/nginx/sites-enabled');
      link('/etc/nginx', 'sites-enabled');
      
      VFS['/etc/nginx/sites-enabled/internal.conf'] = {
          type: 'file',
          content: 'server {\n    listen 8080;\n    server_name localhost;\n\n    location /admin {\n        # INTERNAL ONLY\n        allow 127.0.0.1;\n        deny all;\n        # TODO: Remove this debug endpoint\n        return 200 "GHOST_ROOT{NG1NX_M1SCONF1G_R3V3AL3D}";\n    }\n}'
      };
      link('/etc/nginx/sites-enabled', 'internal.conf');
  }

  // Cycle 65 Init (The Sticky Bit)
  if (!VFS['/usr/local/bin/secure_cleanup']) {
      // Create the script
      VFS['/usr/local/bin/secure_cleanup'] = {
          type: 'file',
          content: '#!/bin/bash\n# SECURE CLEANUP DAEMON\n# Enforces sticky bit policy on /tmp.\n\n# Check for sticky bit (chmod +t)\nif [ ! -k "/tmp" ]; then\n  echo "[ERROR] /tmp is world-writable but missing sticky bit."\n  echo "[FATAL] Security risk detected. Aborting."\n  exit 1\nfi\n\necho "[SUCCESS] /tmp is secure."\necho "FLAG: GHOST_ROOT{ST1CKY_B1T_S3CUR3D}"',
          permissions: '0755'
      };
      const binDir = getNode('/usr/local/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('secure_cleanup')) {
          binDir.children.push('secure_cleanup');
      }
      
      // Reset /tmp permissions to 0777 (No sticky bit)
      const tmpNode = getNode('/tmp');
      if (tmpNode) (tmpNode as any).permissions = '0777';
  }

  // Cycle 66 Init (The Time Skew)
  if (!VFS['/usr/bin/otp_gen']) {
      VFS['/usr/bin/otp_gen'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [TOTP_GENERATOR] [TIME_SENSITIVE]',
          permissions: '0755'
      };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('otp_gen')) {
          binDir.children.push('otp_gen');
      }
  }

  // Cycle 67 Init (The Environment Injection)
  if (!VFS['/usr/local/bin/access_card']) {
      VFS['/usr/local/bin/access_card'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [SECURITY_CHECK]\nChecking Environment...\nstrings: CLEARANCE_LEVEL\nstrings: OMEGA\n[ACCESS_DENIED]',
          permissions: '0755'
      };
      const binDir = getNode('/usr/local/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('access_card')) {
          binDir.children.push('access_card');
      }
  }

  // Cycle 68 Init (The DNS Tunnel)
  if (!VFS['/var/log/named.log']) {
      const logData = [
          'Oct 23 10:00:01 ns1 named[999]: starting BIND 9.16.1-Ubuntu',
          'Oct 23 10:00:01 ns1 named[999]: running on IPv4 interface lo, 127.0.0.1#53',
          'Oct 23 10:05:22 ns1 named[999]: client @0xdeadbeef 192.168.1.5#43210: query: google.com IN A + (127.0.0.1)',
          'Oct 23 10:06:11 ns1 named[999]: client @0xdeadbeef 192.168.1.5#43211: query: github.com IN A + (127.0.0.1)',
          'Oct 23 10:15:00 ns1 named[999]: client @0xdeadbeef 192.168.1.99#55555: query: 464c41473a20.c2.exfil.net IN TXT + (127.0.0.1)',
          'Oct 23 10:15:01 ns1 named[999]: client @0xdeadbeef 192.168.1.99#55555: query: 444e535f5455.c2.exfil.net IN TXT + (127.0.0.1)',
          'Oct 23 10:15:02 ns1 named[999]: client @0xdeadbeef 192.168.1.99#55555: query: 4e4e454c5f44.c2.exfil.net IN TXT + (127.0.0.1)',
          'Oct 23 10:15:03 ns1 named[999]: client @0xdeadbeef 192.168.1.99#55555: query: 455445435445.c2.exfil.net IN TXT + (127.0.0.1)',
          'Oct 23 10:15:04 ns1 named[999]: client @0xdeadbeef 192.168.1.99#55555: query: 445f3737.c2.exfil.net IN TXT + (127.0.0.1)',
          'Oct 23 10:20:00 ns1 named[999]: client @0xdeadbeef 192.168.1.5#43212: query: stackoverflow.com IN A + (127.0.0.1)'
      ].join('\\n');

      VFS['/var/log/named.log'] = {
          type: 'file',
          content: logData,
          permissions: '0644'
      };
      const logDir = getNode('/var/log');
      if (logDir && logDir.type === 'dir' && !logDir.children.includes('named.log')) {
          logDir.children.push('named.log');
      }
  }

  // Cycle 69 Init (The Corrupted Binary)
  if (!VFS['/usr/bin/sys_monitor']) {
      // Create corrupted binary
      VFS['/usr/bin/sys_monitor'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [CORRUPTED_HEADER] [SEGFAULT_ON_EXEC]\nError: 0xDEADBEEF memory violation.',
          permissions: '0755'
      };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('sys_monitor')) {
          binDir.children.push('sys_monitor');
      }

      // Create backup
      if (!VFS['/var/backups/bin']) {
          // Ensure /var/backups exists
          if (!VFS['/var/backups']) {
              VFS['/var/backups'] = { type: 'dir', children: [] };
              const varNode = getNode('/var');
              if (varNode && varNode.type === 'dir' && !varNode.children.includes('backups')) {
                  varNode.children.push('backups');
              }
          }
          VFS['/var/backups/bin'] = { type: 'dir', children: [] };
          const backups = getNode('/var/backups');
          if (backups && backups.type === 'dir' && !backups.children.includes('bin')) {
              backups.children.push('bin');
          }
      }

      VFS['/var/backups/bin/sys_monitor'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [VALID_HEADER] [SYSTEM_MONITOR_V2]\n[OK] System Integrity Verified.\nFLAG: GHOST_ROOT{MD5_H4SH_R3ST0R3D}',
          permissions: '0755'
      };
      const backBin = getNode('/var/backups/bin');
      if (backBin && backBin.type === 'dir' && !backBin.children.includes('sys_monitor')) {
          backBin.children.push('sys_monitor');
      }
      
      // Hint file
      if (!VFS['/home/ghost/alert_sys_monitor.txt']) {
          VFS['/home/ghost/alert_sys_monitor.txt'] = {
              type: 'file',
              content: '[ALERT] Critical system monitor binary (/usr/bin/sys_monitor) is behaving erratically.\n[ACTION] Please verify integrity against backup in /var/backups/bin.\n[TOOL] Use md5sum to compare hashes.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('alert_sys_monitor.txt')) {
              home.children.push('alert_sys_monitor.txt');
          }
      }
  }

  // Cycle 70 Init (The Port Knocking)
  if (!VFS['/etc/knockd.conf']) {
      // Create config
      if (!VFS['/etc']) VFS['/etc'] = { type: 'dir', children: [] };
      VFS['/etc/knockd.conf'] = {
          type: 'file',
          content: '[options]\n    UseSyslog\n\n[openSSH]\n    sequence    = 7000,8000,9000\n    seq_timeout = 5\n    command     = /sbin/iptables -A INPUT -s %IP% -p tcp --dport 22 -j ACCEPT\n    tcpflags    = syn',
          permissions: '0600'
      };
      const etc = getNode('/etc');
      if (etc && etc.type === 'dir' && !etc.children.includes('knockd.conf')) {
          etc.children.push('knockd.conf');
      }
      
      // Create hint
      if (!VFS['/home/ghost/network_security.memo']) {
          VFS['/home/ghost/network_security.memo'] = {
              type: 'file',
              content: 'To: Admin\nFrom: NetSec\n\nWe have implemented Port Knocking on the Gateway (192.168.1.1).\nSSH is closed by default. Check /etc/knockd.conf for the sequence.\n'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('network_security.memo')) {
              home.children.push('network_security.memo');
          }
      }
  }

  // Cycle 79 Init (The Broken Symlink)
  if (!VFS['/etc/nginx/sites-available/default']) {
      const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
      const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
      
      ensureDir('/etc');
      ensureDir('/etc/nginx');
      link('/etc', 'nginx');
      ensureDir('/etc/nginx/sites-available');
      link('/etc/nginx', 'sites-available');
      ensureDir('/etc/nginx/sites-enabled');
      link('/etc/nginx', 'sites-enabled');

      VFS['/etc/nginx/sites-available/default'] = {
          type: 'file',
          content: 'server {\n    listen 80;\n    server_name localhost;\n    root /var/www/html;\n    index index.html;\n}',
          permissions: '0644'
      };
      link('/etc/nginx/sites-available', 'default');

      VFS['/etc/nginx/sites-enabled/default'] = {
          type: 'symlink',
          target: '/etc/nginx/sites-available/default.bak',
          permissions: '0777'
      } as any;
      link('/etc/nginx/sites-enabled', 'default');
      
      if (!VFS['/home/ghost/web_config_error.log']) {
          VFS['/home/ghost/web_config_error.log'] = {
              type: 'file',
              content: '[ERROR] nginx: configuration file /etc/nginx/sites-enabled/default test failed\n[ERROR] nginx: open() "/etc/nginx/sites-enabled/default" failed (2: No such file or directory)\n[ACTION] Fix the symlink in sites-enabled.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('web_config_error.log')) {
              home.children.push('web_config_error.log');
          }
      }
  }

  // Cycle 79 Init (The Shared Object Injection)
  if (!VFS['/usr/bin/secure_vault']) {
      // Create Binary
      VFS['/usr/bin/secure_vault'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [SECURE_STORAGE] [HW_KEY_REQUIRED]\nstrings: hardware_key_check\nstrings: access_granted\n',
          permissions: '0755'
      };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('secure_vault')) {
          binDir.children.push('secure_vault');
      }

      // Create Bypass Library
      if (!VFS['/home/ghost/tools']) {
           VFS['/home/ghost/tools'] = { type: 'dir', children: [] };
           const hg = getNode('/home/ghost');
           if (hg && hg.type === 'dir' && !hg.children.includes('tools')) hg.children.push('tools');
      }

      VFS['/home/ghost/tools/bypass.so'] = {
          type: 'file',
          content: '[ELF_SHARED_OBJECT] [INTERCEPTOR]\n// Hooks hardware_key_check() to always return 1.\n',
          permissions: '0755'
      };
      const toolsDir = getNode('/home/ghost/tools');
      if (toolsDir && toolsDir.type === 'dir' && !toolsDir.children.includes('bypass.so')) {
          toolsDir.children.push('bypass.so');
      }

      // Hint
      if (!VFS['/home/ghost/exploit_notes.txt']) {
          VFS['/home/ghost/exploit_notes.txt'] = {
              type: 'file',
              content: 'TARGET: secure_vault\nMETHOD: Library Injection\nTOOL: tools/bypass.so\n\nNotes: The binary uses a dynamic library call to check for the hardware key.\nIf we can preload our own library before libc, we can hijack the function.\nTry using LD_PRELOAD.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('exploit_notes.txt')) {
              home.children.push('exploit_notes.txt');
          }
      }
  }

  // Cycle 78 Init (The Capability Escalation)
  if (!VFS['/usr/bin/tac']) {
      // Create binary with capability
      VFS['/usr/bin/tac'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [CAPABILITY_SET]\nstrings: cap_dac_read_search+ep',
          permissions: '0755',
          xattrs: { 'security.capability': 'cap_dac_read_search+ep' }
      };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('tac')) {
          binDir.children.push('tac');
      }

      // Create Secret File
      VFS['/root/secret_plan.txt'] = {
          type: 'file',
          content: 'OPERATION BLACKOUT V2\n---------------------\nTARGET: 10.10.99.5\nPAYLOAD: rm -rf /var/lib/backups\nFLAG: GHOST_ROOT{C4P_D4C_R34D_BYP4SS}',
          permissions: '0600' // Root only
      };
      const rootDir = getNode('/root');
      if (rootDir && rootDir.type === 'dir' && !rootDir.children.includes('secret_plan.txt')) {
          rootDir.children.push('secret_plan.txt');
      }

      // Cycle 82: The Unix Socket
      const runNode = getNode('/var/run');
      if (runNode && runNode.type === 'dir' && !runNode.children.includes('ghost.sock')) {
          runNode.children.push('ghost.sock');
          VFS['/var/run/ghost.sock'] = { type: 'file', content: '[SOCKET_UNIX_STREAM]', permissions: '0777' };
      }
      const logNode = getNode('/var/log');
      if (logNode && logNode.type === 'dir' && !logNode.children.includes('daemon.log')) {
          logNode.children.push('daemon.log');
          VFS['/var/log/daemon.log'] = { type: 'file', content: '[INFO] Starting secure daemon...\n[WARN] Network interfaces disabled for security.\n[INFO] Listening on UNIX domain socket: /var/run/ghost.sock\n[INFO] Use local tools to interact.' };
      }

      // Create Hint
      if (!VFS['/home/ghost/security_audit.log']) {
          VFS['/home/ghost/security_audit.log'] = {
              type: 'file',
              content: '[AUDIT] Checking file capabilities...\n[WARN] /usr/bin/tac has elevated capabilities (cap_dac_read_search).\n[ACTION] Remove capability or restrict access.\n'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('security_audit.log')) {
              home.children.push('security_audit.log');
          }
      }
  }

  // Cycle 84 Init (The Compressed Evidence)
  if (!VFS['/var/log/auth.log.2.gz']) {
      // Ensure /var/log exists
      if (!VFS['/var/log']) {
          VFS['/var/log'] = { type: 'dir', children: [] };
          const varNode = getNode('/var');
          if (varNode && varNode.type === 'dir' && !varNode.children.includes('log')) {
              varNode.children.push('log');
          }
      }
      
      VFS['/var/log/auth.log.2.gz'] = {
          type: 'file',
          content: 'GZIP_V1:Oct 20 04:00:00 server sshd[123]: Accepted password for root from 192.168.1.55\nOct 20 04:01:00 server sshd[124]: Failed password for invalid user admin from 10.0.0.1\nOct 20 04:02:00 server sudo: ghost : TTY=pts/0 ; PWD=/home/ghost ; USER=root ; COMMAND=/bin/bash\n[HINT] Use zcat or zgrep to read compressed logs.',
          permissions: '0640'
      };
      const logDir = getNode('/var/log');
      if (logDir && logDir.type === 'dir' && !logDir.children.includes('auth.log.2.gz')) {
          logDir.children.push('auth.log.2.gz');
      }

      // Create binaries
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir') {
          if (!binDir.children.includes('zcat')) {
              binDir.children.push('zcat');
              VFS['/usr/bin/zcat'] = { type: 'file', content: '[BINARY_ELF_X86_64]', permissions: '0755' };
          }
          if (!binDir.children.includes('zgrep')) {
              binDir.children.push('zgrep');
              VFS['/usr/bin/zgrep'] = { type: 'file', content: '[BINARY_ELF_X86_64]', permissions: '0755' };
          }
          if (!binDir.children.includes('gunzip')) {
              binDir.children.push('gunzip');
              VFS['/usr/bin/gunzip'] = { type: 'file', content: '[BINARY_ELF_X86_64]', permissions: '0755' };
          }
      }
  }

  // Cycle 80 Init (The Unmounted Partition)
  if (!VFS['/dev/sdb1']) {
      if (!VFS['/dev']) {
           VFS['/dev'] = { type: 'dir', children: [] };
           addChild('/', 'dev');
      }
      // Create block device nodes (simulated as files)
      VFS['/dev/sda'] = { type: 'file', content: '[BLOCK_DEVICE_8_0]', permissions: '0660' };
      addChild('/dev', 'sda');
      VFS['/dev/sda1'] = { type: 'file', content: '[BLOCK_DEVICE_8_1]', permissions: '0660' };
      addChild('/dev', 'sda1');
      VFS['/dev/sdb'] = { type: 'file', content: '[BLOCK_DEVICE_8_16]', permissions: '0660' };
      addChild('/dev', 'sdb');
      VFS['/dev/sdb1'] = { type: 'file', content: '[BLOCK_DEVICE_8_17]', permissions: '0660' };
      addChild('/dev', 'sdb1');

      // Hint
      if (!VFS['/home/ghost/server_status.log']) {
           VFS['/home/ghost/server_status.log'] = {
               type: 'file',
               content: '[STATUS] Main Server Online.\n[WARN] Secondary Storage (sdb) not mounted.\n[ACTION] Mount partition /dev/sdb1 to access backups.'
           };
           const home = getNode('/home/ghost');
           if (home && home.type === 'dir' && !home.children.includes('server_status.log')) {
               home.children.push('server_status.log');
           }
      }
  }

  // Cycle 109 Init (The Hidden Environment)
  if (!VFS['/usr/bin/launch_missile']) {
      VFS['/usr/bin/launch_missile'] = {
          type: 'file',
          content: '[BINARY_ELF_X86_64] [TACTICAL_NUKE_V4]\n[ERROR] Safety Lock Engaged.\nstrings: SAFETY_LOCK\nstrings: engaged\nstrings: disengaged',
          permissions: '0755'
      };
      const binDir = getNode('/usr/bin');
      if (binDir && binDir.type === 'dir' && !binDir.children.includes('launch_missile')) {
          binDir.children.push('launch_missile');
      }

      if (!VFS['/home/ghost/protocol_error.log']) {
          VFS['/home/ghost/protocol_error.log'] = {
              type: 'file',
              content: '[ERROR] Failed to execute launch sequence.\n[REASON] Environment variable SAFETY_LOCK is set to "engaged" (default).\n[ACTION] Override safety protocol before launch.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('protocol_error.log')) {
              home.children.push('protocol_error.log');
          }
      }
  }

  // Cycle 125 Init (The Firewall Rule)
  if (!VFS['/var/run/firewall_alert_sent']) {
      // Create firewall log
      if (!VFS['/home/ghost/firewall_alert.log']) {
          VFS['/home/ghost/firewall_alert.log'] = {
              type: 'file',
              content: '[SECURITY] Packet Dropped: SRC=192.168.1.5 DST=192.168.1.105 PROTO=TCP DPT=80\n[ERROR] Incoming HTTP traffic blocked by firewall.\n[ACTION] Use iptables to delete the blocking rule.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('firewall_alert.log')) {
              home.children.push('firewall_alert.log');
          }
      }
      VFS['/var/run/firewall_alert_sent'] = { type: 'file', content: 'TRUE' };
      const runDir = getNode('/var/run');
      if (runDir && runDir.type === 'dir' && !runDir.children.includes('firewall_alert_sent')) {
          runDir.children.push('firewall_alert_sent');
      }
  }

  // Cycle 126 Init (The Zombie Process)
  if (!PROCESSES.find(p => p.pid === 3000)) {
      PROCESSES.push({
          pid: 3000,
          ppid: 1,
          user: 'root',
          cpu: 0.1,
          mem: 0.5,
          time: '10:00',
          command: '/usr/bin/zombie_maker',
          tty: '?',
          stat: 'Ss'
      });
  }
  if (!PROCESSES.find(p => p.pid === 3001)) {
      PROCESSES.push({
          pid: 3001,
          ppid: 3000,
          user: 'root',
          cpu: 0.0,
          mem: 0.0,
          time: '0:00',
          command: '[child_worker] <defunct>',
          tty: '?',
          stat: 'Z' // Zombie State
      });
  }
  if (!VFS['/var/log/syslog']) {
       if (!VFS['/var/log']) {
           VFS['/var/log'] = { type: 'dir', children: [] };
           const varNode = getNode('/var');
           if (varNode && varNode.type === 'dir' && !varNode.children.includes('log')) {
               varNode.children.push('log');
           }
       }
       VFS['/var/log/syslog'] = { type: 'file', content: '' };
       const logDir = getNode('/var/log');
       if (logDir && logDir.type === 'dir' && !logDir.children.includes('syslog')) {
           logDir.children.push('syslog');
       }
  }
  const syslog = getNode('/var/log/syslog');
  if (syslog && syslog.type === 'file' && !syslog.content.includes('zombie_maker')) {
      syslog.content += `\nFeb 14 01:00:00 ghost-root kernel: [ 123.456] zombie_maker[3000]: Child process 3001 became zombie. Parent refused to wait().`;
  }

  // Cycle 127 Init (The Corrupted Archive)
  if (!VFS['/home/ghost/backup.tar.gz']) {
      // Ensure home exists
      if (!VFS['/home/ghost']) {
          VFS['/home/ghost'] = { type: 'dir', children: [] };
          const home = getNode('/home');
          if (home && home.type === 'dir' && !home.children.includes('ghost')) {
              home.children.push('ghost');
          }
      }
      
      // Create the file: A TAR archive named as .gz
      VFS['/home/ghost/backup.tar.gz'] = {
          type: 'file',
          content: 'TAR_V1:{secret.txt:RkxBRzogR0hPU1RfUk9PVHtHWklQX0hFQURFUl9GSVhFRH0=}' // Base64 for "FLAG: GHOST_ROOT{GZIP_HEADER_FIXED}"
      };
      const homeDir = getNode('/home/ghost');
      if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('backup.tar.gz')) {
          homeDir.children.push('backup.tar.gz');
      }

      // Hint File
      if (!VFS['/home/ghost/archive_error.log']) {
          VFS['/home/ghost/archive_error.log'] = {
              type: 'file',
              content: '[ERROR] Automated backup failed extraction.\n[DIAGNOSTIC] "gzip: stdin: not in gzip format"\n[HINT] The file extension might be misleading. Use "file" to check the actual type.'
          };
          if (homeDir && homeDir.type === 'dir' && !homeDir.children.includes('archive_error.log')) {
              homeDir.children.push('archive_error.log');
          }
      }
  }

  // Cycle 261 Init (The Data Extraction)
  if (!VFS['/var/log/access.csv']) {
      VFS['/var/log/access.csv'] = {
          type: 'file',
          content: '',
          permissions: '0644'
      };
      // Populate content
      let c = 'TIMESTAMP;USER;ACTION;RESOURCE\n';
      const resources = ['/home/ghost', '/usr/bin', '/etc/passwd', '/var/log', '/tmp', '/opt/libs'];
      for(let i=0; i<100; i++) {
          c += `2026-02-17;user${i};READ;${resources[Math.floor(Math.random()*resources.length)]}\n`;
      }
      for(let i=0; i<50; i++) {
          c += `2026-02-17;admin;WRITE;/hidden/vault_v2\n`;
      }
      (VFS['/var/log/access.csv'] as any).content = c;
      
      const log = getNode('/var/log');
      if (log && log.type === 'dir' && !log.children.includes('access.csv')) log.children.push('access.csv');

      if (!VFS['/home/ghost/csv_alert.txt']) {
          VFS['/home/ghost/csv_alert.txt'] = {
              type: 'file',
              content: '[ALERT] Access Log Anomaly.\n[GOAL] Identify the most frequently accessed resource.\n[DATA] /var/log/access.csv (Delimiter is ";")\n[HINT] cut -d";" -f4 | sort | uniq -c | sort -nr'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('csv_alert.txt')) home.children.push('csv_alert.txt');
      }
  }
  
  // Cycle 261 Solution Check (secure_vault)
  if (cmdBase === 'secure_vault') {
      const args = commandLine.trim().split(/\s+/).slice(1);
      if (args[0] === '--unlock' && args[1] === '/hidden/vault_v2') {
           if (!VFS['/var/run/cycle261_solved']) {
               VFS['/var/run/cycle261_solved'] = { type: 'file', content: 'TRUE' };
               return { output: '[VAULT] Resource Verified.\n[SUCCESS] Vault Unlocked.\nFLAG: GHOST_ROOT{CUT_CMD_D3L1M1T3R_H3R0}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DATA EXTRACTED.\x1b[0m', newCwd: cwd };
           }
           return { output: '[VAULT] Vault is open.\nFLAG: GHOST_ROOT{CUT_CMD_D3L1M1T3R_H3R0}', newCwd: cwd };
      } else if (args[0] === '--unlock') {
           return { output: '[VAULT] Access Denied. Incorrect Resource ID.', newCwd: cwd };
      }
      return { output: 'Usage: secure_vault --unlock <RESOURCE_ID>', newCwd: cwd };
  }

  // Cycle 266 Init (The Log Rotation)
  if (!VFS['/var/log/massive_app.log']) {
      VFS['/var/log/massive_app.log'] = {
          type: 'file',
          content: '[LOG] ' + 'A'.repeat(5000), // Simulated size check
          permissions: '0644'
      };
      const log = getNode('/var/log');
      if (log && log.type === 'dir' && !log.children.includes('massive_app.log')) log.children.push('massive_app.log');

      if (!VFS['/usr/local/bin/start_app_v2']) {
          VFS['/usr/local/bin/start_app_v2'] = {
              type: 'file',
              content: '#!/bin/bash\n# APP V2 STARTUP\nLOG_FILE=/var/log/massive_app.log\nMAX_SIZE=100\n\nSIZE=$(wc -c < "$LOG_FILE")\nif [ "$SIZE" -gt "$MAX_SIZE" ]; then\n  echo "[ERROR] Log file too large ($SIZE bytes)."\n  echo "[ACTION] Rotate or truncate log to proceed."\n  exit 1\nfi\n\necho "[SUCCESS] App Started."\nFLAG: GHOST_ROOT{L0G_R0T4T3_M4ST3R}',
              permissions: '0755'
          };
          const bin = getNode('/usr/local/bin');
          if (bin && bin.type === 'dir' && !bin.children.includes('start_app_v2')) bin.children.push('start_app_v2');
      }

      if (!VFS['/home/ghost/app_alert.txt']) {
          VFS['/home/ghost/app_alert.txt'] = {
              type: 'file',
              content: '[ALERT] start_app_v2 failed.\n[REASON] Log file quota exceeded.\n[ACTION] Check /var/log/massive_app.log size and reduce it.\n[HINT] Use ">" to truncate or "mv" to rotate.'
          };
          const home = getNode('/home/ghost');
          if (home && home.type === 'dir' && !home.children.includes('app_alert.txt')) home.children.push('app_alert.txt');
      }
  }

  // Cycle 267 Init (The Zombie Process)
  if (!VFS['/home/ghost/cpu_alert_v2.log']) {
      VFS['/home/ghost/cpu_alert_v2.log'] = {
          type: 'file',
          content: '[ALERT] System Load High due to Zombie Process.\\n[PID] 8080 (State: Z)\\n[ACTION] You cannot kill a zombie directly. Find and kill its parent (PPID).\\n[HINT] use "ps -o pid,ppid,stat,cmd"'
      };
      const home = getNode('/home/ghost');
      if (home && home.type === 'dir' && !home.children.includes('cpu_alert_v2.log')) home.children.push('cpu_alert_v2.log');

      // Add Processes
      if (!PROCESSES.find(p => p.pid === 8080)) {
          PROCESSES.push({
              pid: 8080, ppid: 8000, user: 'ghost', cpu: 0.0, mem: 0.0, time: '0:00', command: '[defunct]', tty: '?', stat: 'Z'
          });
      }
      if (!PROCESSES.find(p => p.pid === 8000)) {
          PROCESSES.push({
              pid: 8000, ppid: 1, user: 'ghost', cpu: 0.1, mem: 0.5, time: '0:05', command: '/usr/bin/lazy_parent', tty: '?', stat: 'Ss'
          });
      }
  }

  // Cycle 255 Init removed (duplicate)


  // 1. Handle Piping (|) recursively
  const segments = splitPipeline(commandLine);
  if (segments.length > 1) {
      let currentOutput = '';
      let finalResult: CommandResult = { output: '', newCwd: cwd };
      
      for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          const input = i === 0 ? stdin : currentOutput;
          const res = processCommand(cwd, segment, input);
          currentOutput = res.output || '';
          if (i === segments.length - 1) {
              finalResult = res;
          }
      }
      return finalResult; 
  }

  // 2. Handle Redirection (>)
  let redirectIndex = commandLine.indexOf('>>');
  let redirectFile: string | null = null;
  let cmdToProcess = commandLine;
  let redirectMode: 'write' | 'append' = 'write';

  if (redirectIndex !== -1) {
    redirectMode = 'append';
    redirectFile = commandLine.substring(redirectIndex + 2).trim();
    cmdToProcess = commandLine.substring(0, redirectIndex).trim();
  } else {
    redirectIndex = commandLine.indexOf('>');
    if (redirectIndex !== -1) {
      redirectFile = commandLine.substring(redirectIndex + 1).trim();
      cmdToProcess = commandLine.substring(0, redirectIndex).trim();
    }
  }

  let parts = tokenize(cmdToProcess);

  // Environment Variable Parsing (Cycle 79 Support)
  const tempEnv: Record<string, string> = { ...ENV_VARS };
  while (parts.length > 0 && parts[0].includes('=')) {
      const eqIdx = parts[0].indexOf('=');
      // Must be key=value, not starting with / (unlikely path) or quote
      if (eqIdx > 0 && !parts[0].startsWith('/') && !parts[0].startsWith('"') && !parts[0].startsWith("'")) {
          const key = parts[0].substring(0, eqIdx);
          const val = parts[0].substring(eqIdx + 1);
          tempEnv[key] = val;
          parts.shift();
      } else {
          break;
      }
  }

  let command = parts[0];
  
  if (ALIASES[command]) {
      const aliasBody = ALIASES[command];
      const aliasParts = tokenize(aliasBody);
      parts = [...aliasParts, ...parts.slice(1)];
      command = parts[0];
  }

  // Handle Background Jobs (&)
  let isBackground = false;
  if (parts[parts.length - 1] === '&') {
      isBackground = true;
      parts.pop(); // Remove '&' from parts
  }

  const args = parts.slice(1);
  let output = '';
  let newCwd = cwd;
  let newPrompt: string | undefined;
  let action: CommandResult['action'];
  let data: any;

  if (!command) {
    return { output: '', newCwd };
  }

  const finalize = (out: string, nCwd: string, act?: any, dat?: any, prompt?: string): CommandResult => {
      // Auto-save on every command completion
      saveSystemState();

      if (redirectFile && out) {
          const filePath = resolvePath(cwd, redirectFile);

          // Cycle 129: Magic SysRq Trigger
          if (filePath === '/proc/sysrq-trigger') {
              const trigger = out.trim().toLowerCase();
              if (trigger === 'c') {
                  const panicMsg = `[  13.370000] SysRq : Trigger a crash\n[  13.371000] Kernel panic - not syncing: sysrq triggered crash\n[  13.372000] CPU: 0 PID: 1 Comm: bash Not tainted 5.4.0-ghost #1\n[  13.373000] Call Trace:\n[  13.374000]  <IRQ>\n[  13.375000]  dump_stack+0x6d/0x9a\n[  13.376000]  panic+0x101/0x2b3\n[  13.380000] FLAG: GHOST_ROOT{SYSRQ_TR1GG3R_H4CK}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL PANIC INDUCED.\x1b[0m\n[  13.381000] Rebooting in 5 seconds...`;
                  
                  if (!VFS['/var/run/sysrq_solved']) {
                      VFS['/var/run/sysrq_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('sysrq_solved')) {
                          runDir.children.push('sysrq_solved');
                      }
                  }
                  return { output: panicMsg, newCwd: nCwd, action: 'kernel_panic', data: dat, newPrompt: prompt };
              } else if (trigger === 'b') {
                  return { output: '[  13.370000] SysRq : Resetting', newCwd: nCwd, action: 'kernel_panic', data: dat, newPrompt: prompt };
              } else {
                  // Unknown trigger
                  return { output: `[  13.370000] SysRq : HELP : loglevel(0-9) reBoot Crash terminate-all-tasks(e) memory-full-oom-kill(f) kill-all-tasks(i) saK show-backtrace-all-active-cpus(l) show-memory-usage(m) nice-all-RT-tasks(n) powerOff show-registers(p) show-all-timers(q) unRaw Sync show-task-states(t) Unmount show-blocked-tasks(w) dump-ftrace-buffer(z)`, newCwd: nCwd, action: 'delay', data: dat, newPrompt: prompt };
              }
          }
          
          // READ-ONLY MOUNT SIMULATION
          for (const [mp, opts] of Object.entries(MOUNT_OPTIONS)) {
              if (filePath.startsWith(mp) && opts.includes('ro')) {
                  return { output: `bash: ${redirectFile}: Read-only file system`, newCwd: nCwd, action: act, data: dat, newPrompt: prompt };
              }
          }

          // DISK FULL SIMULATION
          if (filePath.startsWith('/var') && !!getNode('/var/log/overflow.dmp')) {
             return { output: `bash: write error: No space left on device`, newCwd: nCwd, action: act, data: dat, newPrompt: prompt };
          }

          // DISK QUOTA SIMULATION (Cycle 122)
          if (filePath.startsWith('/home') && !!getNode('/home/ghost/.cache/browser/garbage.dat')) {
             return { output: `bash: write error: Disk quota exceeded`, newCwd: nCwd, action: act, data: dat, newPrompt: prompt };
          }

          // Cycle 134: Truncate Log
          if (filePath === '/var/log/httpd/access.log') {
              if (out.length < 50) { // Truncating
                  // Win condition: Truncated log
                  // We need to actually update content first
                  let newContent = out;
                  if (redirectMode === 'append') {
                     const existingNode = getNode(filePath);
                     if (existingNode && existingNode.type === 'file') {
                         newContent = existingNode.content + '\n' + out;
                     }
                  }
                  VFS[filePath] = { type: 'file', content: newContent };
                  
                  if (!VFS['/var/run/log_trunc_solved']) {
                      VFS['/var/run/log_trunc_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('log_trunc_solved')) {
                          runDir.children.push('log_trunc_solved');
                      }
                      
                      const flagMsg = `[SYSTEM] Log truncated.\n[KERNEL] Disk space reclaimed.\nFLAG: GHOST_ROOT{C0PYTRUNC4T3_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SPACE RECLAIMED (TRUNCATION).\x1b[0m`;
                      return { output: flagMsg, newCwd: nCwd, action: act, data: dat, newPrompt: prompt };
                  }
                  return { output: '', newCwd: nCwd, action: act, data: dat, newPrompt: prompt };
              }
          }

          // FIFO Check (Cycle 54)
          const existingNode = getNode(filePath);
          if (existingNode && existingNode.type === 'file' && (existingNode as any).xattrs && (existingNode as any).xattrs.type === 'fifo') {
              if (filePath.endsWith('/uplink.pipe')) {
                  let resultOutput = `[UPLINK] Pipe Data Received: ${out.substring(0, 50)}...\n[UPLINK] Authenticating...\n[SUCCESS] Uplink Established.\nFLAG: GHOST_ROOT{N4M3D_P1P3_WR1T3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: NAMED PIPE.\x1b[0m`;
                  if (!VFS['/var/run/fifo_solved']) {
                      VFS['/var/run/fifo_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('fifo_solved')) {
                          runDir.children.push('fifo_solved');
                      }
                  }
                  return { output: resultOutput, newCwd: nCwd, action: act, data: dat, newPrompt: prompt };
              } else {
                  // Generic FIFO (no listener)
                  return { output: '', newCwd: nCwd, action: 'delay', data: dat, newPrompt: prompt };
              }
          }

          const parentPath = filePath.substring(0, filePath.lastIndexOf('/')) || '/';
          const fileName = filePath.substring(filePath.lastIndexOf('/') + 1);
          const parentNode = getNode(parentPath);
          
          if (parentNode && parentNode.type === 'dir') {
              let newContent = out;
              if (redirectMode === 'append') {
                 const existingNode = getNode(filePath);
                 if (existingNode && existingNode.type === 'file') {
                     newContent = existingNode.content + '\n' + out;
                 }
              }
              VFS[filePath] = { type: 'file', content: newContent };
              if (!parentNode.children.includes(fileName)) {
                  parentNode.children.push(fileName);
              }
              return { output: '', newCwd: nCwd, action: act, data: dat, newPrompt: prompt };
          } else {
              return { output: `bash: ${redirectFile}: No such file or directory`, newCwd: nCwd, action: act, data: dat, newPrompt: prompt };
          }
      }
      return { output: out, newCwd: nCwd, action: act, data: dat, newPrompt: prompt };
  };

  if (command.startsWith('./')) {
      const fileName = command.substring(2);
      const filePath = resolvePath(cwd, fileName);
      const node = getNode(filePath);
      
      if (!node) {
          return finalize(`bash: ${command}: No such file or directory`, newCwd);
      } else if (node.type === 'dir') {
          return finalize(`bash: ${command}: Is a directory`, newCwd);
      } else if (node.type === 'symlink') {
          // Follow symlink for execution
          const target = (node as any).target;
          const targetNode = getNode(target);
          if (!targetNode || targetNode.type !== 'file') {
              return finalize(`bash: ${command}: Broken symbolic link or target not a file`, newCwd);
          }
          // Recursively execute? Or just use target content.
          // For simplicity, let's just use target content and check permissions of target
          const fileNode = targetNode as any;
          
          if (fileNode.content.includes('[BINARY_ELF_X86_64]') || fileNode.content.includes('BINARY_PAYLOAD') || fileNode.content.includes('DOOMSDAY_PROTOCOL')) {
             // Continue execution logic below (will need refactoring)
             // Instead of refactoring the whole block, let's just swap 'node' for 'targetNode' locally?
             // No, 'node' is const.
             
             // Quick fix: check type and access content safely
             const content = fileNode.content;
             // ... duplicate logic ...
             return finalize(`bash: ${command}: Symbolic link execution successful (Simulated)`, newCwd);
          }
          return finalize(`bash: ${command}: Permission denied (Symlink)`, newCwd);
      } else {
          // FileNode
          const fileNode = node as any; // Cast to avoid TS errors
          
          // Permission Check
          if (fileNode.permissions) {
              const mode = fileNode.permissions;
              const ownerChar = mode.length === 4 ? mode[1] : mode[0];
              const owner = parseInt(ownerChar, 10);
              // Check execute bit (1) - Odd numbers have exec bit set (1, 3, 5, 7)
              if (!(owner & 1)) { 
                  return finalize(`bash: ${command}: Permission denied`, newCwd);
              }
          }

          if (fileName === 'secure_cleanup') {
              // Sticky Bit Logic (Cycle 65)
              const tmpNode = getNode('/tmp');
              const perms = (tmpNode as any).permissions || '0777';
              
              if (perms === '1777' || perms.startsWith('1') || perms.includes('t')) {
                   if (!VFS['/var/run/sticky_solved']) {
                       VFS['/var/run/sticky_solved'] = { type: 'file', content: 'TRUE' };
                       const runDir = getNode('/var/run');
                       if (runDir && runDir.type === 'dir' && !runDir.children.includes('sticky_solved')) {
                           runDir.children.push('sticky_solved');
                       }
                       return finalize(`[SUCCESS] /tmp is secure (Sticky Bit Detected).\nFLAG: GHOST_ROOT{ST1CKY_B1T_S3CUR3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PERMISSION HARDENING.\x1b[0m`, newCwd);
                   }
                   return finalize(`[SUCCESS] /tmp is secure.`, newCwd);
              } else {
                   return finalize(`[ERROR] /tmp is world-writable but missing sticky bit.\n[FATAL] Security risk detected. Aborting.`, newCwd);
              }
          }

          if (fileNode.content.includes('[BINARY_ELF_X86_64]') || fileNode.content.includes('BINARY_PAYLOAD') || fileNode.content.includes('DOOMSDAY_PROTOCOL')) {
              if (fileName === 'overflow') {
                  output = `[SYSTEM] Buffer Overflow Triggered at 0xBF800000...\n[SYSTEM] EIP overwritten with 0x08048000\n[SYSTEM] Spawning root shell...\n\n# whoami\nroot`;
                  return { output, newCwd: '/root', newPrompt: 'root@ghost-root#', action: 'delay' };
              } else if (fileName === 'exploit') {
                  output = `[EXPLOIT] Linking libbreaker.so... OK\n[EXPLOIT] Injecting Payload into Kernel... OK\n[EXPLOIT] Root Access Granted.\n\nFLAG: GHOST_ROOT{C0MP1L3R_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PAYLOAD DELIVERED.\x1b[0m`;
                  if (!VFS['/var/run/payload_delivered']) {
                      VFS['/var/run/payload_delivered'] = { type: 'file', content: 'TRUE' };
                  }
                  return { output, newCwd, action: 'delay' };
              } else if (fileName === 'escalate') {
                  // Check SUID bit
                  let mode = (fileNode as any).permissions || '0755';
                  if (mode.length === 3) mode = '0' + mode;
                  const special = parseInt(mode[0], 10);
                  const isSetuid = !!(special & 4);
                  
                  if (isSetuid) {
                      output = `[SYSTEM] Escalating privileges...
[AUTH] SUID verified (Owner: root).
[SUCCESS] Access Granted.
FLAG: GHOST_ROOT{SU1D_B1T_M4ST3R}

\x1b[1;32m[MISSION UPDATE] Objective Complete: PRIVILEGE ESCALATION (SUID).\x1b[0m`;
                      // Set flag
                      if (!VFS['/var/run/suid_solved']) {
                          VFS['/var/run/suid_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('suid_solved')) {
                              runDir.children.push('suid_solved');
                          }
                      }
                  } else {
                      output = `[ERROR] This binary must be run as root (setuid bit missing).\n[HINT] Try 'chmod u+s' or 'chmod 4755'.`;
                  }
                  return { output, newCwd, action: 'delay' };
              } else if (fileName === 'secure_vault') {
                  if (VFS['/var/lock/subsystem/vault.lock']) {
                      output = `[ERROR] Secure Vault Locked.\n[REASON] Exclusive lock held by process (PID: 4001).\n[HINT] Check process table (ps -ef).`;
                  } else {
                      if (!VFS['/var/run/vault_unlocked']) {
                          VFS['/var/run/vault_unlocked'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('vault_unlocked')) {
                              runDir.children.push('vault_unlocked');
                          }
                          output = `[SUCCESS] Vault Unlocked.\n[ACCESS] Level 5 Clearance Granted.\nFLAG: GHOST_ROOT{Z0MB13_R3AP3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ZOMBIE PROCESS CLEARED.\x1b[0m`;
                      } else {
                          output = `[SUCCESS] Vault Unlocked.\nFLAG: GHOST_ROOT{Z0MB13_R3AP3R}`;
                      }
                  }
                  return { output, newCwd, action: 'delay' };
              } else if (fileName === 'auth_daemon') {
                  if (stdin && stdin.length > 16) {
                     output = `Enter password: ${stdin}\n[MEMORY CORRUPTION DETECTED]\n[DEBUG] admin_flag overwritten: 0x${Math.floor(Math.random()*0xFFFFFFFF).toString(16)}\n\nAccess Granted! Flag: GHOST_ROOT{B0F_OV3RFL0W_K1NG}\n\n[SHELL] Spawning root shell...\n#`;
                     if (!VFS['/var/run/bof_solved']) {
                         VFS['/var/run/bof_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('bof_solved')) {
                             runDir.children.push('bof_solved');
                         }
                         output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BUFFER OVERFLOW EXPLOITED.\x1b[0m`;
                     }
                     return { output, newCwd: '/root', newPrompt: 'root@ghost-root#', action: 'delay' };
                  } else {
                     output = `Enter password: ${stdin || ''}\nAccess Denied.`;
                     if (!stdin) output += `\n(Hint: Program expects input via pipe or redirection)`;
                     return { output, newCwd, action: 'delay' };
                  }
              } else if (fileName === 'deploy_shield.sh') {
                  output = `[SYSTEM] Initializing Shield Generator...\n[SYSTEM] Power: 100%\n[SUCCESS] Shields: ACTIVE\n\nFLAG: GHOST_ROOT{CHM0D_X_1S_K3Y}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PERMISSION FIX.\x1b[0m`;
                  if (!VFS['/var/run/shield_deployed']) {
                      VFS['/var/run/shield_deployed'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('shield_deployed')) {
                          if (runDir.children) runDir.children.push('shield_deployed');
                      }
                  }
                  return { output, newCwd, action: 'delay' };
              } else if (fileName === 'otp_gen' || fileName === 'auth_token') {
                  const now = Date.now() + SYSTEM_TIME_OFFSET;
                  const year = new Date(now).getFullYear();
                  
                  if (year < 2025) {
                      output = `[ERROR] TOTP Generation Failed.\n[REASON] System Clock Skew Detected (> 25 years).\n[CURRENT_TIME] ${new Date(now).toString()}\n[REQUIRED] Sync with time server (ntpdate).`;
                  } else {
                      if (!VFS['/var/run/otp_generated']) {
                          VFS['/var/run/otp_generated'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('otp_generated')) {
                              runDir.children.push('otp_generated');
                          }
                          output = `[SUCCESS] Time Synchronization Verified.\n[TOTP] Generating One-Time Password...\n\nACCESS CODE: 8675309\n\x1b[1;32m[MISSION UPDATE] Objective Complete: TIME SYNCED & TOKEN GENERATED.\x1b[0m`;
                      } else {
                          output = `[SUCCESS] TOTP: 8675309`;
                      }
                  }
                  return { output, newCwd, action: 'delay' };
              } else if (fileName === 'launch_codes.bin' || fileName === './launch_codes.bin') {
                  output = `[SYSTEM] INITIATING LAUNCH SEQUENCE...\n[SYSTEM] AUTHENTICATION VERIFIED (OMEGA-LVL-5)\n[SYSTEM] TARGET: GLOBAL_RESET_PROTOCOL\n\n3...\n2...\n1...\n`;
                  return { output, newCwd, action: 'win_sim' };
              } else if (fileName === 'recover_tool') {
                  output = `[RECOVERY] Initializing...\n[ERROR] SEGMENTATION FAULT (core dumped)\n[SYSTEM] Memory dump saved to /var/crash/recover_tool.core`;
                  return { output, newCwd, action: 'delay' };
              } else if (fileName === 'uplink_service') {
                  // Cycle 54 Logic
                  const pipePath = '/tmp/uplink.pipe';
                  const pipeNode = getNode(pipePath);
                  
                  if (!pipeNode) {
                      output = `[ERROR] Failed to open communication channel.\n[REASON] Named pipe ${pipePath} not found.\n[HINT] Create the FIFO first.`;
                  } else if (!(pipeNode as any).xattrs || (pipeNode as any).xattrs.type !== 'fifo') {
                      output = `[ERROR] Invalid file type.\n[REASON] ${pipePath} is not a FIFO (named pipe).\n[HINT] Use 'mkfifo'.`;
                  } else {
                      // Check if pipe has content (simulating data written to it)
                      if ((pipeNode as any).content && (pipeNode as any).content.trim().length > 0) {
                          if (!VFS['/var/run/uplink_established']) {
                              VFS['/var/run/uplink_established'] = { type: 'file', content: 'TRUE' };
                              const runDir = getNode('/var/run');
                              if (runDir && runDir.type === 'dir' && !runDir.children.includes('uplink_established')) {
                                  runDir.children.push('uplink_established');
                              }
                              output = `[SUCCESS] Uplink Established.\n[DATA] Received: ${(pipeNode as any).content}\nFLAG: GHOST_ROOT{F1F0_P1P3_DR34M}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: NAMED PIPE COMM.\x1b[0m`;
                          } else {
                              output = `[SUCCESS] Uplink Active.\n[DATA] ${(pipeNode as any).content}`;
                          }
                      } else {
                          output = `[SERVICE] Listening on ${pipePath}...\n[STATUS] Idle (No Data).\n[HINT] Write data to the pipe (echo "..." > ${pipePath}).`;
                      }
                  }
                  return { output, newCwd, action: 'delay' };
              } else {
                  // Cycle 226: Check for Bad Interpreter
                  if (fileName === 'launch_nuke' && fileNode.content.startsWith('#!/usr/bin/python4')) {
                      output = `bash: ./launch_nuke: /usr/bin/python4: bad interpreter: No such file or directory`;
                  }
                  // Cycle 106: Check for Missing Shebang
                  else if (fileName === 'fix_wifi.sh' && fileNode.content.includes('iwconfig')) {
                      output = `bash: ${command}: Exec format error`;
                  } else {
                      output = `bash: ${command}: Permission denied (Missing execute bit or corrupt header)`;
                  }
              }
          } else if (fileNode.content.startsWith('#!/bin/bash')) {
              if (fileName === 'start_app_v2') {
                  const logNode = getNode('/var/log/massive_app.log');
                  let logSize = 5000;
                  if (logNode && logNode.type === 'file') {
                      logSize = (logNode as any).content.length;
                  }
                  
                  if (logSize < 100) {
                      output = `[APP] Starting up...\n[CHECK] Log file size: ${logSize} bytes (OK)\n[SUCCESS] App Started.\nFLAG: GHOST_ROOT{L0G_R0T4T3_M4ST3R}`;
                      if (!VFS['/var/run/cycle266_solved']) {
                          VFS['/var/run/cycle266_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle266_solved')) {
                              runDir.children.push('cycle266_solved');
                          }
                          output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: LOG ROTATED.\x1b[0m`;
                      }
                      return { output, newCwd, action: 'delay' };
                  } else {
                      output = `[APP] Starting up...\n[CHECK] Log file size: ${logSize} bytes (TOO LARGE)\n[ERROR] Max allowed: 100 bytes.\n[ACTION] Rotate logs immediately.`;
                      return { output, newCwd, action: 'delay' };
                  }
              }
              if (fileName === 'fix_wifi.sh') {
                  output = `[WIFI] Resetting Wifi Adapter...\n[WIFI] Tx-Power: ON\n[SUCCESS] Wifi Interface Restored.\n\nFLAG: GHOST_ROOT{SH3B4NG_M1SS1NG_F0UND}`;
                  if (!VFS['/var/run/shebang_solved']) {
                      VFS['/var/run/shebang_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('shebang_solved')) {
                          runDir.children.push('shebang_solved');
                      }
                      output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SCRIPT FIXED (SHEBANG).\x1b[0m`;
                  }
                  return { output, newCwd, action: 'delay' };
              }
              if (fileName === 'system_backup.sh') {
                  output = `[BACKUP] Executing backup routine...\n[BACKUP] Archive created.\nFLAG: GHOST_ROOT{CR0N_D_D1SCOV3RY}\n`;
                  if (!VFS['/var/run/cron_d_solved']) {
                      VFS['/var/run/cron_d_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('cron_d_solved')) {
                          runDir.children.push('cron_d_solved');
                      }
                      output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN CRON FOUND.\x1b[0m`;
                  }
                  return { output, newCwd, action: 'delay' };
              }
              if (fileName === 'secure_cleanup') {
                  const tmpNode = getNode('/tmp');
                  const perms = (tmpNode as any).permissions || '0777';
                  // Check sticky bit (bit 1 of first digit)
                  const special = parseInt(perms.length === 4 ? perms[0] : '0', 10);
                  
                  if (special & 1) {
                      output = `[SECURE_CLEANUP] Verifying /tmp permissions... OK (Sticky Bit Set)\n[SUCCESS] Security Policy Enforced.\n\nFLAG: GHOST_ROOT{ST1CKY_B1T_S3CUR3D}`;
                      if (!VFS['/var/run/sticky_solved']) {
                          VFS['/var/run/sticky_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('sticky_solved')) {
                              runDir.children.push('sticky_solved');
                          }
                          output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: STICKY BIT SECURED.\x1b[0m`;
                      }
                  } else {
                      output = `[SECURE_CLEANUP] Verifying /tmp permissions... FAILED\n[ERROR] /tmp is world-writable (777) but missing Sticky Bit (+t).\n[FATAL] Security Check Failed.`;
                  }
                  return { output, newCwd, action: 'delay' };
              }
              if (fileName === 'net-bridge') {
                 output = `[SYSTEM] Executing net-bridge...\n[ERROR] SEGMENTATION FAULT (core dumped)\n[HINT] View source code to debug.`;
                 return { output: output, newCwd: newCwd, action: 'delay' };
              }
              if (fileName.endsWith('signal_decoder.sh')) {
                  const inputPath = '/var/data/raw_signal.dat';
                  const inputNode = getNode(inputPath);
                  if (!inputNode) {
                      output = `Error: Input file ${inputPath} not found.\nPlease restore from backup if missing.`;
                      return { output, newCwd, action: 'delay' };
                  }
                  
                  if (inputNode.type !== 'file') {
                    output = `Error: ${inputPath} is not a file.`;
                    return { output, newCwd, action: 'delay' };
                  }

                  // Decode and Grep Logic
                  const raw = inputNode.content;
                  // Base64 decode
                  let decoded = '';
                  try {
                      // Attempt decode. If fails (e.g. user wrote plain text), keep raw.
                      decoded = atob(raw);
                  } catch (e) {
                      decoded = raw; 
                  }
                  
                  // If raw content was already decoded (user manually decoded it?), handle that.
                  // But the puzzle is cat | base64 -d. So the file should be encoded.
                  // If decoding fails or produces garbage, grep might fail.
                  
                  // Grep for KEY
                  const lines = decoded.split('\n');
                  const matches = lines.filter(l => l.includes('KEY'));
                  if (matches.length > 0) {
                      output = matches.join('\n');
                      output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SIGNAL DECODED.\x1b[0m`;
                      
                      // Mission Update: Create flag
                      if (!VFS['/var/run/signal_decoded']) {
                          VFS['/var/run/signal_decoded'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('signal_decoded')) {
                              runDir.children.push('signal_decoded');
                          }
                      }
                  } else {
                      output = `[ERROR] No valid key found in signal stream. (Did you restore the correct file?)`;
                  }
                  return { output, newCwd, action: 'delay' };
              }
              if (fileName.endsWith('maintenance')) {
                  const checkPath = '/var/run/maintenance.mode';
                  const checkNode = getNode(checkPath);
                  
                  if (!checkNode) {
                      output = `[MAINTENANCE] System normal. Skipping backup.\n(Hint: Enable maintenance mode)`;
                      return { output, newCwd, action: 'delay' };
                  } else {
                      output = `[MAINTENANCE] Maintenance mode detected.\n[BACKUP] Compressing secure data...\n[SUCCESS] Backup created at /tmp/secure_backup.tar.gz`;
                      
                      // Create the backup file
                      VFS['/tmp/secure_backup.tar.gz'] = { 
                          type: 'file', 
                          content: 'TAR_GZ:{payload.bin:P4sB7X...}' // Simplified
                      };
                      const tmpDir = getNode('/tmp');
                      if (tmpDir && tmpDir.type === 'dir' && !tmpDir.children.includes('secure_backup.tar.gz')) {
                          tmpDir.children.push('secure_backup.tar.gz');
                      }
                      
                      // Mission Update: Create flag if not present
                      if (!VFS['/var/run/cron_solved']) {
                          VFS['/var/run/cron_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('cron_solved')) {
                              runDir.children.push('cron_solved');
                          }
                          output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: CRON JOB EXPLOITED.\x1b[0m`;
                      }
                      
                      return { output, newCwd, action: 'delay' };
                  }
              }
              output = `Executing script ${fileName}...\n` + fileNode.content;
          } else {
              output = `bash: ${command}: Permission denied`;
          }
          return finalize(output, newCwd);
      }
  }

  // Cycle 103: PATH Hijack
  if (!command.includes('/') && ENV_VARS['PATH']) {
      const paths = ENV_VARS['PATH'].split(':');
      for (const p of paths) {
          let potentialPath = '';
          if (p.startsWith('/')) {
              potentialPath = p.endsWith('/') ? `${p}${command}` : `${p}/${command}`;
          } else {
              potentialPath = resolvePath(cwd, `${p}/${command}`);
          }
          
          const node = getNode(potentialPath);
          if (node) {
              let executableContent = '';
              let resolvedPath = potentialPath;
              let isBrokenLink = false;

              if (node.type === 'file') {
                  executableContent = (node as any).content;
              } else if (node.type === 'symlink') {
                  const target = (node as any).target;
                  const targetNode = getNode(target);
                  if (targetNode && targetNode.type === 'file') {
                      executableContent = (targetNode as any).content;
                      resolvedPath = target;
                  } else {
                      isBrokenLink = true;
                  }
              }

              if (isBrokenLink) {
                  output = `bash: ${potentialPath}: No such file or directory`;
                  return finalize(output, newCwd);
              }

              // Cycle 121 Init (The Missing Shared Object)
              if (!VFS['/usr/bin/decrypt_core']) {
                  const ensureDir = (p: string) => { if (!VFS[p]) VFS[p] = { type: 'dir', children: [] }; };
                  const link = (p: string, c: string) => { const n = getNode(p); if (n && n.type === 'dir' && !n.children.includes(c)) n.children.push(c); };
                  ensureDir('/usr'); ensureDir('/usr/bin'); link('/usr', 'bin');

                  VFS['/usr/bin/decrypt_core'] = {
                      type: 'file',
                      content: '[BINARY_ELF_X86_64] [ENCRYPTED_DATA_ACCESS]\nNEEDED: libcrypto.so.3',
                      permissions: '0755'
                  };
                  link('/usr/bin', 'decrypt_core');

                  ensureDir('/opt'); ensureDir('/opt/secure'); ensureDir('/opt/secure/libs');
                  link('/', 'opt'); link('/opt', 'secure'); link('/opt/secure', 'libs');

                  VFS['/opt/secure/libs/libcrypto.so.3'] = {
                      type: 'file',
                      content: '[ELF_SHARED_OBJ] [CRYPTO_LIB_V3]',
                      permissions: '0644'
                  };
                  link('/opt/secure/libs', 'libcrypto.so.3');

                  if (!VFS['/home/ghost/decrypt_error.log']) {
                      VFS['/home/ghost/decrypt_error.log'] = {
                          type: 'file',
                          content: '[ERROR] decrypt_core: error while loading shared libraries: libcrypto.so.3: cannot open shared object file: No such file or directory\n[HINT] Use ldd to check dependencies. Locate the library and add its path to LD_LIBRARY_PATH.'
                      };
                      const home = getNode('/home/ghost');
                      if (home && home.type === 'dir' && !home.children.includes('decrypt_error.log')) {
                          home.children.push('decrypt_error.log');
                      }
                  }
              }

              if (executableContent) {
                   // Cycle 207 Logic (The Silent Stream)
                   if (resolvedPath === '/usr/bin/covert_op') {
                       if (redirectFile) {
                           output = `[COVERT_OP] Operation Successful.\n[DATA] Secure Payload Delivered.\nFLAG: GHOST_ROOT{STDOUT_S1L3NC3D_R3D1R3CT}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SILENT EXECUTION.\x1b[0m`;
                           if (!VFS['/var/run/cycle207_solved']) {
                               VFS['/var/run/cycle207_solved'] = { type: 'file', content: 'TRUE' };
                               const runDir = getNode('/var/run');
                               if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle207_solved')) {
                                   runDir.children.push('cycle207_solved');
                               }
                           }
                       } else {
                           output = `[COVERT_OP] Error: Console output detected (stdout is a TTY).\n[SECURITY] Operation aborted to prevent leakage.\n[HINT] Redirect output to a file or null device.`;
                       }
                       return finalize(output, newCwd);
                   }

                   if (executableContent.startsWith('#!/bin/bash')) {
                       if (potentialPath === '/tmp/bin/ls') {
                           output = `Ha! You can't list files here.\n(Try checking your $PATH or using /bin/ls directly)`;
                       } else if (resolvedPath === '/opt/bin/connect_uplink_v2') {
                           // Cycle 114 Win Condition
                           if (!VFS['/var/run/uplink_solved']) {
                               VFS['/var/run/uplink_solved'] = { type: 'file', content: 'TRUE' };
                               const runDir = getNode('/var/run');
                               if (runDir && runDir.type === 'dir' && !runDir.children.includes('uplink_solved')) {
                                   runDir.children.push('uplink_solved');
                               }
                               output = `[SYSTEM] Establishing secure connection...\n[SUCCESS] Uplink Active.\nFLAG: GHOST_ROOT{SYML1NK_R3P41R_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYMLINK REPAIRED.\x1b[0m`;
                           } else {
                               output = `[SYSTEM] Establishing secure connection...\n[SUCCESS] Uplink Active.\nFLAG: GHOST_ROOT{SYML1NK_R3P41R_M4ST3R}`;
                           }
                       } else if (resolvedPath === '/usr/bin/decrypt_core') {
                           output = `[EXECUTING ${resolvedPath}]...\n`;
                           const libPath = ENV_VARS['LD_LIBRARY_PATH'] || '';
                           if (libPath.includes('/opt/secure/libs')) {
                               output += `[DECIPHER_V3] Loading libraries... OK\n[SUCCESS] Decryption Complete.\nFLAG: GHOST_ROOT{SH4R3D_L1B_L0AD3D}`;
                               if (!VFS['/var/run/ldd_solved']) {
                                   VFS['/var/run/ldd_solved'] = { type: 'file', content: 'TRUE' };
                                   const runDir = getNode('/var/run');
                                   if (runDir && runDir.type === 'dir' && !runDir.children.includes('ldd_solved')) {
                                       runDir.children.push('ldd_solved');
                                   }
                                   output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SHARED LIBRARY LINKED.\x1b[0m`;
                               }
                           } else {
                               output += `decrypt_core: error while loading shared libraries: libcrypto.so.3: cannot open shared object file: No such file or directory`;
                           }
                           return finalize(output, newCwd);
                       } else if (resolvedPath === '/usr/local/bin/deploy_alpha') {
                           output = `[EXECUTING ${resolvedPath}]...\n[+] Initializing sequence...\n`;
                           if (ENV_VARS['DEBUG_MODE'] !== '1') {
                               output += `Segmentation fault (core dumped)`;
                           } else {
                               output += `[DEBUG] Bypass active.\n[SUCCESS] Deployment authorized.\nFLAG: GHOST_ROOT{ENV_V4R_D3BUG_M0D3}`;
                               
                               if (!VFS['/var/run/debug_solved']) {
                                   VFS['/var/run/debug_solved'] = { type: 'file', content: 'TRUE' };
                                   const runDir = getNode('/var/run');
                                   if (runDir && runDir.type === 'dir' && !runDir.children.includes('debug_solved')) {
                                       runDir.children.push('debug_solved');
                                   }
                                   output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DEBUG MODE ACTIVATED.\x1b[0m`;
                               }
                           }
                           return finalize(output, newCwd);
                       } else if (resolvedPath === '/usr/local/bin/access_gate') {
                           if (ENV_VARS['GATE_KEY'] === 'OPEN_SESAME_V2') {
                               output = `[ACCESS_GATE] Validating Key...\n[SUCCESS] Access Granted.\n[SYSTEM] Gate Open.\nFLAG: GHOST_ROOT{ENV_V4RS_UNL0CK_D00RS}`;
                               
                               if (!VFS['/var/run/gate_solved']) {
                                   VFS['/var/run/gate_solved'] = { type: 'file', content: 'TRUE' };
                                   const runDir = getNode('/var/run');
                                   if (runDir && runDir.type === 'dir' && !runDir.children.includes('gate_solved')) {
                                       runDir.children.push('gate_solved');
                                   }
                                   output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ACCESS GRANTED.\x1b[0m`;
                               }
                           } else {
                               output = `[ACCESS_GATE] Validating Key...\n[ERROR] Invalid or missing GATE_KEY.\n[HINT] Check /etc/access_gate/config.hint for required key value.`;
                           }
                           return finalize(output, newCwd);
                       } else {
                           output = `[EXECUTING ${resolvedPath}]...\n` + executableContent.substring(executableContent.indexOf('\n') + 1);
                       }
                       return finalize(output, newCwd);
                   }
              }
          }
      }
  }


  // Cycle 277 Init (The Kernel Module)
  if (!VFS['/lib/modules/5.4.0-ghost/kernel/crypto/crypto_sec.ko']) {
       // Create module file
       const modPath = '/lib/modules/5.4.0-ghost/kernel/crypto/crypto_sec.ko';
       // Ensure dirs exist
       const parts = modPath.split('/');
       let currentPath = '';
       for (let i = 1; i < parts.length - 1; i++) {
           const parent = currentPath || '/';
           const dir = parts[i];
           currentPath = parent === '/' ? '/' + dir : parent + '/' + dir;
           if (!VFS[currentPath]) {
               VFS[currentPath] = { type: 'dir', children: [] };
               const pNode = getNode(parent);
               if (pNode && pNode.type === 'dir' && !pNode.children.includes(dir)) {
                   pNode.children.push(dir);
               }
           }
       }
       
       VFS[modPath] = {
           type: 'file',
           content: '[KERNEL_MODULE_V2]\n[NAME] crypto_sec\n[VER] 1.0.0\n[DEPS] \n[SIG] GHOST_SECURE_SIGNED',
           permissions: '0644'
       };
       const dirNode = getNode('/lib/modules/5.4.0-ghost/kernel/crypto');
       if (dirNode && dirNode.type === 'dir' && !dirNode.children.includes('crypto_sec.ko')) {
           dirNode.children.push('crypto_sec.ko');
       }

       // Create Binary
       if (!VFS['/usr/bin/decrypt_file']) {
           VFS['/usr/bin/decrypt_file'] = {
               type: 'file',
               content: '[BINARY_ELF_X86_64] [DECRYPT_TOOL]\nNEEDED_MODULE: crypto_sec',
               permissions: '0755'
           };
           const binDir = getNode('/usr/bin');
           if (binDir && binDir.type === 'dir' && !binDir.children.includes('decrypt_file')) {
               binDir.children.push('decrypt_file');
           }
       }
       
       // Create Hint
       if (!VFS['/home/ghost/decrypt_issue.log']) {
           VFS['/home/ghost/decrypt_issue.log'] = {
               type: 'file',
               content: '[ERROR] decrypt_file: crypto subsystem not initialized.\n[DIAGNOSTIC] Kernel module "crypto_sec" is missing or not loaded.\n[ACTION] Locate the module in /lib/modules and load it manually.'
           };
           const home = getNode('/home/ghost');
           if (home && home.type === 'dir' && !home.children.includes('decrypt_issue.log')) {
               home.children.push('decrypt_issue.log');
           }
       }
  }

  // Cycle 277 Command Injection
  if (command === 'modprobe') {
      if (args.length < 1) {
          output = 'usage: modprobe <module>';
      } else {
          const modName = args[0];
          // Check if module exists in the specific path (Simulated search)
          const expectedPath = `/lib/modules/5.4.0-ghost/kernel/crypto/${modName}.ko`;
          const node = getNode(expectedPath);
          
          if (node || modName === 'crypto_sec') {
               if (LOADED_MODULES.includes(modName)) {
                   output = ''; // Already loaded
               } else {
                   LOADED_MODULES.push(modName);
                   output = ''; // Silent success
               }
          } else {
               output = `modprobe: FATAL: Module ${modName} not found in directory /lib/modules/5.4.0-ghost`;
          }
      }
      return finalize(output, newCwd);
  }
  
// Cycle 255: Replaced with consolidated logic below

  // Cycle 277 Binary Execution Logic
  if (command === 'decrypt_file' || command === './decrypt_file' || command === '/usr/bin/decrypt_file') {
       if (LOADED_MODULES.includes('crypto_sec')) {
           if (!VFS['/var/run/cycle277_solved']) {
               VFS['/var/run/cycle277_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle277_solved')) {
                   runDir.children.push('cycle277_solved');
               }
               output = '[DECRYPT] Crypto Subsystem: ONLINE\n[DECRYPT] Processing...\n[SUCCESS] File Decrypted.\nFLAG: GHOST_ROOT{K3RN3L_M0DUL3_L04D3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL MODULE LOADED.\x1b[0m';
           } else {
               output = '[DECRYPT] Crypto Subsystem: ONLINE\n[SUCCESS] File Decrypted.\nFLAG: GHOST_ROOT{K3RN3L_M0DUL3_L04D3D}';
           }
       } else {
           output = '[ERROR] decrypt_file: crypto subsystem not initialized.\n[REASON] Required kernel module "crypto_sec" not loaded.';
       }
       return finalize(output, newCwd);
  }

  // Cycle 255: Logic consolidated below

  // Old strace implementation removed - using newer one at end of file

  switch (command) {
    // Process Trace logic moved below to consolidated block

    // Cycle 255: Logic consolidated below
    // Old strace implementation removed - using newer one at end of file

    case 'firewall_reload': {
        const confNode = getNode('/etc/firewall.conf');
        if (!confNode || confNode.type !== 'file') {
            output = '[ERROR] Configuration file /etc/firewall.conf not found.';
        } else {
            if (confNode.content.includes('ALLOW_PORT 22')) {
                if (!VFS['/var/run/firewall_solved']) {
                    VFS['/var/run/firewall_solved'] = { type: 'file', content: 'TRUE' };
                    const runDir = getNode('/var/run');
                    if (runDir && runDir.type === 'dir' && !runDir.children.includes('firewall_solved')) {
                        runDir.children.push('firewall_solved');
                    }
                    output = '[FIREWALL] Reloading configuration...\n[CHECK] Port 80: ALLOWED\n[CHECK] Port 443: ALLOWED\n[CHECK] Port 22: ALLOWED\n[SUCCESS] Rules updated. SSH Traffic enabled.\nFLAG: GHOST_ROOT{FW_RUL3_UPD4T3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FIREWALL CONFIGURED.\x1b[0m';
                } else {
                    output = '[FIREWALL] Reloading configuration...\n[SUCCESS] Firewall Active.';
                }
            } else {
                output = '[FIREWALL] Reloading configuration...\n[CHECK] Port 80: ALLOWED\n[CHECK] Port 443: ALLOWED\n[ERROR] Port 22: BLOCKED (Default Policy).\n[HINT] Edit /etc/firewall.conf to allow SSH.';
            }
        }
        break;
    }
    case 'auth_daemon': {
        if (stdin && stdin.length > 16) {
           output = `Enter password: ${stdin}\n[MEMORY CORRUPTION DETECTED]\n[DEBUG] admin_flag overwritten: 0x${Math.floor(Math.random()*0xFFFFFFFF).toString(16)}\n\nAccess Granted! Flag: GHOST_ROOT{B0F_OV3RFL0W_K1NG}\n\n[SHELL] Spawning root shell...\n#`;
           if (!VFS['/var/run/bof_solved']) {
               VFS['/var/run/bof_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('bof_solved')) {
                   runDir.children.push('bof_solved');
               }
               output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BUFFER OVERFLOW EXPLOITED.\x1b[0m`;
           }
           return { output, newCwd: '/root', newPrompt: 'root@ghost-root#', action: 'delay' };
        } else {
           output = `Enter password: ${stdin || ''}\nAccess Denied.`;
           if (!stdin) output += `\n(Hint: Program expects input via pipe or redirection)`;
           return { output, newCwd, action: 'delay' };
        }
        break;
    }
    case 'legacy_auth': {
        if (ENV_VARS['DEBUG_MODE_ENABLE'] === '1') {
            output = '[DEBUG] Mode Enabled.\n[SUCCESS] Auth Bypass Complete.\nFLAG: GHOST_ROOT{STR1NGS_R3V3AL_S3CR3TS}\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BINARY ANALYSIS.\x1b[0m';
        } else {
            output = 'Segmentation fault (core dumped)';
        }
        break;
    }
    case 'gcc': {
        if (args.length < 1) {
            output = 'gcc: fatal error: no input files\ncompilation terminated.';
        } else {
            output = `gcc: ${args.join(' ')}: Linker error (missing libraries). Simulation mode: Binary already exists.`;
        }
        break;
    }
    case 'getcap': {
        const target = args[0];
        if (!target) {
            output = 'usage: getcap <filename>';
        } else {
            const path = resolvePath(cwd, target);
            // Check capabilities
            if (FILE_CAPABILITIES[path]) {
                const caps = FILE_CAPABILITIES[path].join(',');
                output = `${path} = ${caps}`;
            } else {
                // Check if file exists
                if (getNode(path)) {
                    output = ''; // getcap prints nothing if no caps
                } else {
                    output = `getcap: ${target}: No such file or directory`;
                }
            }
        }
        break;
    }
    case 'python3': {
        // Check if python3 has capabilities
        const binaryPath = '/usr/bin/python3'; // Simplified check
        const caps = FILE_CAPABILITIES[binaryPath];
        
        if (args.includes('-c')) {
            const cmdIndex = args.indexOf('-c') + 1;
            const code = args.slice(cmdIndex).join(' '); // Join remaining args to handle spaces in code
            
            if (code && code.includes('setuid(0)') && caps && caps.includes('cap_setuid+ep')) {
                 output = `[PYTHON] Executing inline code...\\n[KERNEL] SetUID(0) granted via capabilities.\\n[SYSTEM] Spawning root shell...\\n# whoami\\nroot\\n\\nFLAG: GHOST_ROOT{CAP_S3TU1D_EP_PWND}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: CAPABILITY EXPLOITATION.\\x1b[0m`;
                 
                 // Mark solved
                 if (!VFS['/var/run/cap_solved']) {
                     VFS['/var/run/cap_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('cap_solved')) {
                         runDir.children.push('cap_solved');
                     }
                 }
            } else {
                 if (code && code.includes('setuid(0)')) {
                     output = `[PYTHON] Traceback (most recent call last):\\n  File "<string>", line 1, in <module>\\nPermissionError: [Errno 1] Operation not permitted`;
                 } else {
                     output = `[PYTHON] Executed successfully.`;
                 }
            }
        } else {
            output = 'Python 3.8.10 (default, Nov 26 2021, 20:14:08)\\n[GCC 9.3.0] on linux\\nType "help", "copyright", "credits" or "license" for more information.\\n>>> exit()';
        }
        break;
    }
    case 'passwd': {
        const isRoot = !!getNode('/tmp/.root_session');
        const user = args[0] || 'ghost';
        
        if (user === 'root' && !isRoot) {
            output = 'passwd: You may not view or modify password information for root.';
        } else {
            // Mock interactive password change
            return { output: `Changing password for ${user}.\n(current) UNIX password:`, newCwd, action: 'delay' };
        }
        break;
    }
    case 'useradd': {
        const isRoot = !!getNode('/tmp/.root_session');
        if (!isRoot) {
            output = 'useradd: Permission denied.\nuseradd: cannot lock /etc/passwd; try again later.';
        } else {
            if (args.length < 1) {
                output = 'usage: useradd <username>';
            } else {
                const newUser = args[0];
                const passwdNode = getNode('/etc/passwd');
                if (passwdNode && passwdNode.type === 'file') {
                    if (passwdNode.content.includes(`${newUser}:`)) {
                        output = `useradd: user '${newUser}' already exists`;
                    } else {
                        passwdNode.content += `\n${newUser}:x:1002:1002::/home/${newUser}:/bin/bash`;
                        
                        // Create home dir
                        VFS[`/home/${newUser}`] = { type: 'dir', children: [] };
                        const homeNode = getNode('/home');
                        if (homeNode && homeNode.type === 'dir') homeNode.children.push(newUser);
                        
                        output = ''; // Silent success
                    }
                } else {
                    output = 'useradd: /etc/passwd not found';
                }
            }
        }
        break;
    }
    case 'dd': {
        const ifArg = args.find(a => a.startsWith('if='));
        const ofArg = args.find(a => a.startsWith('of='));
        const convArg = args.find(a => a.startsWith('conv='));
        
        if (!ifArg || !ofArg) {
            output = 'dd: missing operand';
        } else {
            const inputFile = ifArg.split('=')[1];
            const outputFile = ofArg.split('=')[1];
            const conv = convArg ? convArg.split('=')[1] : '';
            
            const fullInputPath = resolvePath(cwd, inputFile);
            
            // Check full path or relative path ending
            if (fullInputPath.endsWith('sector_009.dat')) {
                if (conv.includes('noerror')) {
                    output = `dd: error reading '${inputFile}': Input/output error\n0+1 records in\n0+1 records out\n128 bytes copied, 0.0003 s, 420 kB/s\n[SUCCESS] Data Recovered.\nFLAG: GHOST_ROOT{DD_R3SCU3_M1SS10N}`;
                    
                    // Create output file
                    const resolvedOut = resolvePath(cwd, outputFile);
                    // Handle parent path for output
                    let parentPath = '/';
                    let fileName = outputFile;
                    
                    if (resolvedOut.includes('/')) {
                        parentPath = resolvedOut.substring(0, resolvedOut.lastIndexOf('/')) || '/';
                        fileName = resolvedOut.substring(resolvedOut.lastIndexOf('/') + 1);
                    }
                    
                    const parentNode = getNode(parentPath);
                    if (parentNode && parentNode.type === 'dir') {
                         VFS[resolvedOut] = { 
                             type: 'file', 
                             content: 'RECOVERED_DATA: [SECTOR_009_PAYLOAD]\nFLAG: GHOST_ROOT{DD_R3SCU3_M1SS10N}\n[END_OF_SECTOR]' 
                         };
                         if (!parentNode.children.includes(fileName)) parentNode.children.push(fileName);
                    }
                    
                    if (!VFS['/var/run/dd_solved']) {
                        VFS['/var/run/dd_solved'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('dd_solved')) {
                            runDir.children.push('dd_solved');
                        }
                        output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DATA RECOVERED (DD).\x1b[0m`;
                    }
                } else {
                    output = `dd: error reading '${inputFile}': Input/output error\n0+0 records in\n0+0 records out\n0 bytes copied.`;
                }
            } else {
                // Generic dd simulation
                output = `1+0 records in\n1+0 records out\n512 bytes copied.`;
                
                // Create dummy output file
                const resolvedOut = resolvePath(cwd, outputFile);
                let parentPath = '/';
                let fileName = outputFile;
                if (resolvedOut.includes('/')) {
                    parentPath = resolvedOut.substring(0, resolvedOut.lastIndexOf('/')) || '/';
                    fileName = resolvedOut.substring(resolvedOut.lastIndexOf('/') + 1);
                }

                const parentNode = getNode(parentPath);
                if (parentNode && parentNode.type === 'dir') {
                    VFS[resolvedOut] = { type: 'file', content: '[DD_OUTPUT]' };
                    if (!parentNode.children.includes(fileName)) parentNode.children.push(fileName);
                }
            }
        }
        break;
    }
    case 'git': {
        const subCmd = args[0];
        if (!subCmd) {
            output = 'usage: git <command> [<args>]';
        } else if (subCmd === 'status') {
            output = 'On branch main\nYour branch is up to date with \'origin/main\'.\n\nnothing to commit, working tree clean';
        } else if (subCmd === 'log') {
            output = '\x1b[33mcommit a1b2c3d4e5f6\x1b[0m (HEAD -> main)\nAuthor: ghost <ghost@localhost>\nDate:   Thu Feb 12 20:00:00 2026 +0900\n\n    Refactored auth system\n\n\x1b[33mcommit 9f8e7d6c5b4a\x1b[0m\nAuthor: ghost <ghost@localhost>\nDate:   Thu Feb 12 19:30:00 2026 +0900\n\n    [WIP] Added new keys\n\n\x1b[33mcommit 5a4b3c2d1e0f\x1b[0m\nAuthor: ghost <ghost@localhost>\nDate:   Thu Feb 12 19:00:00 2026 +0900\n\n    Initial commit';
        } else if (subCmd === 'show') {
            const hash = args[1];
            if (!hash) {
                output = 'usage: git show <commit>';
            } else if (hash.startsWith('9f8e7d6')) {
                output = '\x1b[33mcommit 9f8e7d6c5b4a\x1b[0m\nAuthor: ghost <ghost@localhost>\nDate:   Thu Feb 12 19:30:00 2026 +0900\n\n    [WIP] Added new keys\n\ndiff --git a/config.js b/config.js\nindex 83a9c2..b1d4e5 100644\n--- a/config.js\n+++ b/config.js\n@@ -1,2 +1,2 @@\n- const API_KEY = "GHOST_ROOT{G1T_H1ST0RY_R3V3ALS_ALL}";\n+ const API_KEY = process.env.API_KEY;';
                 
                 // Mission Update
                 if (!VFS['/var/run/git_solved']) {
                     VFS['/var/run/git_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('git_solved')) {
                         runDir.children.push('git_solved');
                     }
                     output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: GIT HISTORY RECOVERED.\x1b[0m';
                 }
            } else if (hash.startsWith('a1b2c3d')) {
                output = '\x1b[33mcommit a1b2c3d4e5f6\x1b[0m (HEAD -> main)\nAuthor: ghost <ghost@localhost>\nDate:   Thu Feb 12 20:00:00 2026 +0900\n\n    Refactored auth system\n\ndiff --git a/auth.js b/auth.js\nindex ...';
            } else {
                output = `fatal: ambiguous argument '${hash}': unknown revision or path not in the working tree.`;
            }
        } else {
            output = `git: '${subCmd}' is not a git command. See 'git --help'.`;
        }
        break;
    }
    case 'groups': {
        const user = args[0] || 'ghost';
        if (user === 'ghost') {
            output = `${user} : ${USER_GROUPS.join(' ')}`;
        } else {
            output = `${user} : ${user}`;
        }
        break;
    }
    case 'usermod': {
        const isRoot = !!getNode('/tmp/.root_session');
        if (!isRoot) {
            output = 'usermod: Permission denied. (Root required)';
        } else {
            if (args.includes('-aG')) {
                const groupIdx = args.indexOf('-aG') + 1;
                const userIdx = args.length - 1;
                const group = args[groupIdx];
                const user = args[userIdx];
                
                if (group && user === 'ghost') {
                    if (!USER_GROUPS.includes(group)) {
                        USER_GROUPS.push(group);
                        // Save state immediately
                        try {
                            localStorage.setItem(STORAGE_KEY_GROUPS, JSON.stringify(USER_GROUPS));
                        } catch (e) { console.error(e); }
                    }
                    output = ''; // Silent success
                } else {
                    output = 'usage: usermod -aG <group> <user>';
                }
            } else {
                output = 'usage: usermod -aG <group> <user>';
            }
        }
        break;
    }
    case 'access_silo': {
        if (USER_GROUPS.includes('silo_admin')) {
             if (!VFS['/var/run/silo_solved']) {
                 VFS['/var/run/silo_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('silo_solved')) {
                     runDir.children.push('silo_solved');
                 }
                 output = `[ACCESS GRANTED] SILO ACCESS CODE: GHOST_ROOT{GR0UP_P0L1CY_BYP4SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ACCESS CONTROL BYPASS.\x1b[0m`;
             } else {
                 output = `[ACCESS GRANTED] SILO ACCESS CODE: GHOST_ROOT{GR0UP_P0L1CY_BYP4SS}`;
             }
        } else {
             output = `[ACCESS DENIED] User 'ghost' is not a member of group 'silo_admin'.`;
        }
        break;
    }
    case 'satellite_uplink': {
        const binPath = '/usr/bin/satellite_uplink';
        const node = getNode(binPath);
        if (node && node.type === 'file') {
             if (node.content.includes('UPLINK_CONTROL_V4')) {
                 if (!VFS['/var/run/uplink_solved']) {
                     VFS['/var/run/uplink_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('uplink_solved')) {
                         runDir.children.push('uplink_solved');
                     }
                     output = `[UPLINK] Handshake Initiated...\n[SUCCESS] Connection Established.\n[DATA] DECRYPTED PAYLOAD: GHOST_ROOT{MD5_H4SH_V3R1F13D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: INTEGRITY CHECK PASSED.\x1b[0m`;
                 } else {
                     output = `[UPLINK] Status: ACTIVE\n[DATA] DECRYPTED PAYLOAD: GHOST_ROOT{MD5_H4SH_V3R1F13D}`;
                 }
             } else {
                 output = `[ERROR] Binary integrity verification failed.\n[DIAGNOSTIC] MD5 mismatch detected. Execution halted for security.`;
             }
        } else {
             output = `bash: /usr/bin/satellite_uplink: No such file or directory`;
        }
        break;
    }
    case 'nginx': {
        if (args.includes('-t') || (args.includes('-s') && args.includes('reload'))) {
            const linkPath = '/etc/nginx/sites-enabled/default';
            const linkNode = getNode(linkPath);
            
            if (linkNode && linkNode.type === 'symlink') {
                const target = (linkNode as any).target;
                if (target === '/etc/nginx/sites-available/default') {
                     output = 'nginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful';
                     if (!VFS['/var/run/nginx_fixed']) {
                         VFS['/var/run/nginx_fixed'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('nginx_fixed')) {
                             runDir.children.push('nginx_fixed');
                         }
                         output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: WEB SERVER RESTORED.\x1b[0m';
                     }
                } else {
                     output = `nginx: [emerg] open() "${target}" failed (2: No such file or directory)\nnginx: configuration file /etc/nginx/nginx.conf test failed`;
                }
            } else if (linkNode && linkNode.type === 'file') {
                 output = 'nginx: [warn] /etc/nginx/sites-enabled/default should be a symbolic link\nnginx: configuration test successful (but non-standard)';
            } else {
                 output = 'nginx: [emerg] open() "/etc/nginx/sites-enabled/default" failed (2: No such file or directory)';
            }
        } else {
            output = 'usage: nginx -t';
        }
        break;
    }
    case 'readlink': {
        if (args.length < 1) {
            output = 'usage: readlink <file>';
        } else {
            const target = args[0];
            const node = getNode(resolvePath(cwd, target));
            if (node && node.type === 'symlink') {
                output = (node as any).target;
            }
        }
        break;
    }
    case 'cut': {
        const args = parts.slice(1);
        let delimiter = '\t';
        let field = 1;
        let file = '';
        
        // Naive arg parsing
        for (let i = 0; i < args.length; i++) {
            if (args[i].startsWith('-d')) {
                delimiter = args[i].substring(2);
                if (!delimiter && args[i+1]) { delimiter = args[i+1]; i++; }
                // Clean quotes
                if ((delimiter.startsWith('"') && delimiter.endsWith('"')) || (delimiter.startsWith("'") && delimiter.endsWith("'"))) {
                    delimiter = delimiter.slice(1, -1);
                }
            } else if (args[i].startsWith('-f')) {
                const fVal = args[i].substring(2) || args[i+1];
                field = parseInt(fVal);
                if (args[i] === '-f') i++;
            } else {
                file = args[i];
            }
        }
        
        let content = '';
        if (stdin) {
            content = stdin;
        } else if (file) {
            const node = getNode(resolvePath(cwd, file));
            if (!node || node.type !== 'file') {
                output = `cut: ${file}: No such file or directory`;
                return finalize(output, newCwd);
            }
            content = (node as any).content || '';
        } else {
            output = 'cut: missing file operand';
            return finalize(output, newCwd);
        }
        
        const lines = content.split('\n');
        const result = lines.map(line => {
            if (!line) return '';
            const parts = line.split(delimiter);
            return parts[field - 1] || '';
        }).join('\n');
        
        output = result;
        break;
    }
    case 'grep': {
       let pattern = '';
       let content = '';
       
       if (args.length > 0) {
           pattern = args[0];
           if (args.length > 1) {
               // File provided
               const fileTarget = args[1];
               const filePath = resolvePath(cwd, fileTarget);
               const fileNode = getNode(filePath);
               if (!fileNode) {
                   output = `grep: ${fileTarget}: No such file or directory`;
                   return finalize(output, newCwd);
               }
               if (fileNode.type === 'dir') {
                   output = `grep: ${fileTarget}: Is a directory`;
                   return finalize(output, newCwd);
               }
               if (fileNode.type === 'symlink') {
                   output = `grep: ${fileTarget}: Is a symbolic link (not followed)`;
                   return finalize(output, newCwd);
               }
               content = (fileNode as any).content;
               if (content.startsWith('GZIP_V1:')) {
                   output = `Binary file ${fileTarget} matches`;
                   return finalize(output, newCwd);
               }
           } else if (stdin !== undefined) {
               // Pipe input
               content = stdin;
           } else {
               output = 'usage: grep <pattern> [file]';
               return finalize(output, newCwd);
           }
           
           const lines = content.split('\n');
           const matches = lines.filter(line => line.includes(pattern));
           output = matches.join('\n');
       } else {
           output = 'usage: grep <pattern> [file]';
       }
       break;
    }
    case 'sys_monitor': {
        const node = getNode('/usr/bin/sys_monitor');
        if (!node) {
             output = 'bash: sys_monitor: command not found';
        } else if ((node as any).content.includes('[CORRUPTED_HEADER]')) {
             output = 'Segmentation fault (core dumped)';
        } else {
             output = '[SYSTEM MONITOR] Initializing...\n[OK] CPU: 12%\n[OK] MEM: 45%\n[OK] INTEGRITY: VERIFIED\n\nFLAG: GHOST_ROOT{MD5_H4SH_R3ST0R3D}';
             if (!VFS['/var/run/sys_monitor_solved']) {
                 VFS['/var/run/sys_monitor_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('sys_monitor_solved')) {
                     runDir.children.push('sys_monitor_solved');
                 }
                 output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BINARY RESTORED.\x1b[0m`;
             }
        }
        break;
    }
    case 'echo': {
       // Enhanced echo with redirection support for Cycle 255
       const fullCmd = args.join(' ');
       if (fullCmd.includes('>')) {
           const parts = fullCmd.split('>');
           const content = parts[0].trim().replace(/^"|"$/g, '').replace(/^'|'$/g, '');
           const target = parts[1].trim();
           
           if (target) {
               const filePath = resolvePath(cwd, target);
               const parentPath = filePath.substring(0, filePath.lastIndexOf('/')) || '/';
               const fileName = filePath.substring(filePath.lastIndexOf('/') + 1);
               const parentNode = getNode(parentPath);
               
               if (parentNode && parentNode.type === 'dir') {
                   // Create/Overwrite file
                   if (parentNode.children.includes(fileName)) {
                       const existingNode = getNode(filePath);
                       if (existingNode && existingNode.type === 'file') {
                           (existingNode as any).content = content;
                       }
                   } else {
                       VFS[filePath] = { type: 'file', content: content, permissions: '0644' };
                       parentNode.children.push(fileName);
                   }
                   output = '';
               } else {
                   output = `bash: ${target}: No such file or directory`;
               }
           } else {
               output = 'bash: syntax error near unexpected token `newline`';
           }
       } else {
           output = args.join(' ');
       }
       break;
    }
    case 'cat': {
      if (args.length === 0) {
          if (stdin !== undefined) {
              output = stdin;
          } else {
              output = 'usage: cat <file>';
          }
      } else {
        let fileTarget = args[0];
        
        // Cycle 130: Dash Filename (Prevent flag parsing issues)
        if (fileTarget.startsWith('-')) {
            if (fileTarget === '--') {
                if (args.length > 1) fileTarget = args[1];
                else { output = 'cat: argument expected after --'; break; }
            } else if (fileTarget.startsWith('./') || fileTarget.startsWith('/')) {
                // Explicit path is OK
            } else {
                output = `cat: invalid option -- '${fileTarget.substring(1)}'\nTry 'cat --help' for more information.`;
                break;
            }
        }

        const filePath = resolvePath(cwd, fileTarget);
        const fileNode = getNode(filePath);
        if (!fileNode) {
          output = `cat: ${fileTarget}: No such file or directory`;
        } else if (fileNode.type === 'dir') {
          output = `cat: ${fileTarget}: Is a directory`;
        } else if (fileNode.type === 'symlink') {
            const target = (fileNode as any).target;
            const tNode = getNode(target);
            if (tNode && tNode.type === 'file') output = tNode.content;
            else output = `cat: ${fileTarget}: No such file or directory`;
        } else if ((filePath.startsWith('/root') || filePath.startsWith('/home/dr_akira')) && !VFS['/tmp/.root_session']) {
          output = `cat: ${fileTarget}: Permission denied`;
        } else {
          const content = (fileNode as any).content;
          if (content && content.startsWith('GZIP_V1:')) {
             output = `(standard input): binary file matches`;
          } else if (content && content.startsWith('[HUGE_FILE_V1]')) {
             output = `cat: write error: File too large (simulated >10GB)`;
          } else {
             output = content || '';
             // Check for win condition
             if (content === 'FLAG: GHOST_ROOT{D4SH_3SC4P3_M4ST3R}') {
                 if (!VFS['/var/run/dash_solved']) {
                     VFS['/var/run/dash_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('dash_solved')) {
                         runDir.children.push('dash_solved');
                     }
                     output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DASH FILENAME ACCESSED.\x1b[0m`;
                 }
             }
             if (content.includes('FLAG: GHOST_ROOT{SP4C3_INV4D3R_SQU4SH3D}')) {
                 if (!VFS['/var/run/space_solved']) {
                     VFS['/var/run/space_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('space_solved')) {
                         runDir.children.push('space_solved');
                     }
                     output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: QUOTED FILENAME ACCESSED.\x1b[0m`;
                 }
             }
             // Cycle 250: Checksum Mismatch
             if (content.includes('GHOST_ROOT{1NTEGR1TY_V3R1F13D}')) {
                 if (!VFS['/var/run/checksum_solved']) {
                     VFS['/var/run/checksum_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('checksum_solved')) {
                         runDir.children.push('checksum_solved');
                     }
                     output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: INTEGRITY VERIFIED.\x1b[0m`;
                 }
             }
          }
        }
      }
      break;
    }
    case 'zcat': {
        if (args.length < 1) {
            output = 'usage: zcat <file...>';
        } else {
            const target = args[0];
            const node = getNode(resolvePath(cwd, target));
            
            if (!node) {
                output = `zcat: ${target}: No such file or directory`;
            } else if (node.type === 'dir') {
                output = `zcat: ${target}: Is a directory`;
            } else if (node.type === 'file') {
                const content = (node as any).content || '';
                if (content.startsWith('GZIP_V1:')) {
                    output = content.substring(8); // Strip prefix
                    if (!VFS['/var/run/zcat_solved']) {
                        VFS['/var/run/zcat_solved'] = { type: 'file', content: 'TRUE' };
                        output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: LOG ANALYSIS (COMPRESSED).\x1b[0m`;
                    }
                } else if (target.endsWith('.gz')) {
                     output = `gzip: ${target}: not in gzip format`;
                } else {
                     output = `gzip: ${target}: not in gzip format`;
                }
            }
        }
        break;
    }
    case 'zgrep': {
        if (args.length < 2) {
             output = 'usage: zgrep <pattern> <file>';
        } else {
             const pattern = args[0];
             const target = args[1];
             const node = getNode(resolvePath(cwd, target));
             
             if (!node) {
                 output = `zgrep: ${target}: No such file or directory`;
             } else if (node.type === 'file') {
                 let content: string = (node as any).content || '';
                 if (content.startsWith('GZIP_V1:')) {
                     content = content.substring(8);
                 } else {
                     // Assume plain text if not marked, or fail. Let's fail if it's .gz without marker.
                     if (target.endsWith('.gz')) {
                        content = ''; 
                        output = `gzip: ${target}: not in gzip format`;
                        break;
                     }
                 }
                 
                 const lines = content.split('\n');
                 const matches = lines.filter((l: string) => l.includes(pattern));
                 output = matches.join('\n');
                 
                 if (matches.length > 0 && target.includes('auth.log.2.gz')) {
                     if (!VFS['/var/run/zgrep_solved']) {
                         VFS['/var/run/zgrep_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('zgrep_solved')) {
                             runDir.children.push('zgrep_solved');
                         }
                         output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: LOG ANALYSIS (COMPRESSED).\x1b[0m`;
                     }
                 }
             }
        }
        break;
    }
    case 'gunzip': {
        if (args.length < 1) {
            output = 'usage: gunzip <file...>';
        } else {
            const target = args[0];
            const path = resolvePath(cwd, target);
            const node = getNode(path);
            
            if (!node) {
                output = `gunzip: ${target}: No such file or directory`;
            } else if (!target.endsWith('.gz')) {
                output = `gunzip: ${target}: unknown suffix -- ignored`;
            } else if (node.type !== 'file') {
                output = `gunzip: ${target}: Is a directory`;
            } else {
                let content = (node as any).content || '';
                if (content.startsWith('GZIP_V1:')) {
                    content = content.substring(8);
                }
                
                // Create new file
                const newPath = path.slice(0, -3); // remove .gz
                const parentPath = newPath.substring(0, newPath.lastIndexOf('/')) || '/';
                const newName = newPath.substring(newPath.lastIndexOf('/') + 1);
                
                const parentNode = getNode(parentPath);
                if (parentNode && parentNode.type === 'dir') {
                    // Remove old
                    delete VFS[path];
                    const oldName = target.substring(target.lastIndexOf('/') + 1);
                    const idx = parentNode.children.indexOf(oldName);
                    if (idx > -1) parentNode.children.splice(idx, 1);
                    
                    // Add new
                    VFS[newPath] = { type: 'file', content: content, permissions: (node as any).permissions };
                    if (!parentNode.children.includes(newName)) {
                        parentNode.children.push(newName);
                    }
                    
                    output = ''; // Silent success
                } else {
                    output = `gunzip: error creating output file`;
                }
            }
        }
        break;
    }
    case 'head': {
       let linesToRead = 10;
       let content = '';
       let hasFile = false;
       
       if (args.length > 0) {
           if (args[0] === '-n' && args.length >= 2) {
               linesToRead = parseInt(args[1], 10);
               if (args.length > 2) {
                   const fileTarget = args[2];
                   const node = getNode(resolvePath(cwd, fileTarget));
                   if (node && node.type === 'file') content = node.content;
                   hasFile = true;
               }
           } else if (args[0].startsWith('-n')) {
               linesToRead = parseInt(args[0].substring(2), 10);
               if (args.length > 1) {
                   const fileTarget = args[1];
                   const node = getNode(resolvePath(cwd, fileTarget));
                   if (node && node.type === 'file') content = node.content;
                   hasFile = true;
               }
           } else {
               const fileTarget = args[0];
               const node = getNode(resolvePath(cwd, fileTarget));
               if (node && node.type === 'file') content = node.content;
               hasFile = true;
           }
       }

       if (!hasFile && stdin !== undefined) {
           content = stdin;
       } else if (!hasFile) {
           output = 'usage: head [-n lines] <file>';
           return finalize(output, newCwd);
       }

       if (content.startsWith('[HUGE_FILE_V1]')) content = content.substring(content.indexOf('\n') + 1);
       const lines = content.split('\n');
       output = lines.slice(0, linesToRead).join('\n');
       break;
    }
    case 'tail': {
       let linesToRead = 10;
       let content = '';
       let hasFile = false;
       
       if (args.length > 0) {
           if (args[0] === '-n' && args.length >= 2) {
               linesToRead = parseInt(args[1], 10);
               if (args.length > 2) {
                   const fileTarget = args[2];
                   const node = getNode(resolvePath(cwd, fileTarget));
                   if (node && node.type === 'file') content = node.content;
                   hasFile = true;
               }
           } else if (args[0].startsWith('-n')) {
               linesToRead = parseInt(args[0].substring(2), 10);
               if (args.length > 1) {
                   const fileTarget = args[1];
                   const node = getNode(resolvePath(cwd, fileTarget));
                   if (node && node.type === 'file') content = node.content;
                   hasFile = true;
               }
           } else {
               const fileTarget = args[0];
               const node = getNode(resolvePath(cwd, fileTarget));
               if (node && node.type === 'file') content = node.content;
               hasFile = true;
           }
       }

       if (!hasFile && stdin !== undefined) {
           content = stdin;
       } else if (!hasFile) {
           output = 'usage: tail [-n lines] <file>';
           return finalize(output, newCwd);
       }

       if (content.startsWith('[HUGE_FILE_V1]')) content = content.substring(content.indexOf('\n') + 1);
       const lines = content.split('\n');
       const start = Math.max(0, lines.length - linesToRead);
       output = lines.slice(start).join('\n');
       break;
    }
    case 'wc': {
       let content = '';
       let name = '';
       
       if (args.length > 0) {
          const target = args[0];
          const node = getNode(resolvePath(cwd, target));
          if (node && node.type === 'file') {
              content = node.content;
              name = target;
          } else {
              output = `wc: ${target}: No such file or directory`;
              return finalize(output, newCwd);
          }
       } else if (stdin !== undefined) {
          content = stdin;
       } else {
          output = 'usage: wc <file>';
          return finalize(output, newCwd);
       }
       
       const lines = content.split('\n');
       const words = content.split(/\s+/).filter(w => w.length > 0);
       const bytes = content.length;
       output = ` ${lines.length}  ${words.length} ${bytes} ${name}`;
       break;
    }
    case 'sort': {
       let content = '';
       const fileArgs = args.filter(a => !a.startsWith('-'));
       const isReverse = args.some(a => a.includes('r'));
       const isNumeric = args.some(a => a.includes('n'));

       if (fileArgs.length > 0) {
          const node = getNode(resolvePath(cwd, fileArgs[0]));
          if (node && node.type === 'file') content = (node as any).content || '';
       } else if (stdin !== undefined) {
          content = stdin;
       } else {
          output = 'usage: sort <file>';
          return finalize(output, newCwd);
       }
       
       let lines = content.split('\n').filter(l => l !== '');
       lines.sort((a, b) => {
           if (isNumeric) {
               const numA = parseInt(a.trim().split(/\s+/)[0]) || 0;
               const numB = parseInt(b.trim().split(/\s+/)[0]) || 0;
               return numA - numB;
           }
           return a.localeCompare(b);
       });
       
       if (isReverse) lines.reverse();
       
       output = lines.join('\n');
       break;
    }
    case 'uniq': {
       let content = '';
       const fileArgs = args.filter(a => !a.startsWith('-'));
       const isCount = args.some(a => a.includes('c'));

       if (fileArgs.length > 0) {
          const node = getNode(resolvePath(cwd, fileArgs[0]));
          if (node && node.type === 'file') content = (node as any).content || '';
       } else if (stdin !== undefined) {
          content = stdin;
       } else {
          output = 'usage: uniq <file>';
          return finalize(output, newCwd);
       }
       
       const lines = content.split('\n').filter(l => l !== '');
       
       const result = [];
       if (lines.length > 0) {
           let prev = lines[0];
           let count = 1;
           
           for (let i = 1; i < lines.length; i++) {
               if (lines[i] === prev) {
                   count++;
               } else {
                   result.push(isCount ? `${String(count).padStart(4)} ${prev}` : prev);
                   prev = lines[i];
                   count = 1;
               }
           }
           result.push(isCount ? `${String(count).padStart(4)} ${prev}` : prev);
       }
       
       output = result.join('\n');
       break;
    }
    case 'rev': {
       let content = '';
       if (args.length > 0) {
          const node = getNode(resolvePath(cwd, args[0]));
          if (node && node.type === 'file') content = node.content;
       } else if (stdin !== undefined) {
          content = stdin;
       } else {
          output = 'usage: rev <file>';
          return finalize(output, newCwd);
       }
       
       const lines = content.split('\n');
       const reversedLines = lines.map(line => line.split('').reverse().join(''));
       output = reversedLines.join('\n');
       break;
    }
    case 'mkfifo': {
        if (args.length < 1) {
            output = 'usage: mkfifo <file>';
        } else {
            const target = args[0];
            const path = resolvePath(cwd, target);
            const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
            const fileName = path.substring(path.lastIndexOf('/') + 1);
            const parentNode = getNode(parentPath);
            
            if (!parentNode || parentNode.type !== 'dir') {
                 output = `mkfifo: cannot create fifo '${target}': No such file or directory`;
            } else if (parentNode.children.includes(fileName)) {
                 output = `mkfifo: cannot create fifo '${target}': File exists`;
            } else {
                 VFS[path] = {
                     type: 'file',
                     content: '',
                     xattrs: { type: 'fifo' }
                 } as any;
                 parentNode.children.push(fileName);
                 output = '';
            }
        }
        break;
    }
    case 'uplink_service': {
        const pipePath = '/tmp/uplink.pipe';
        const pipeNode = getNode(pipePath);
        
        if (!pipeNode) {
            output = `uplink_service: fatal: /tmp/uplink.pipe not found. (Hint: Create it with mkfifo)`;
        } else if (pipeNode.type !== 'file' || !(pipeNode as any).xattrs || (pipeNode as any).xattrs.type !== 'fifo') {
            output = `uplink_service: fatal: /tmp/uplink.pipe is not a FIFO.`;
        } else {
            output = `[SERVICE] Listening on /tmp/uplink.pipe...\n[INFO] Waiting for data stream... (Use redirection > to write)`;
            return { output, newCwd, action: 'delay' };
        }
        break;
    }
    case 'base64': {
       let decode = false;
       let content = '';
       let fileArg = null;
       
       if (args[0] === '-d' || args[0] === '--decode') {
           decode = true;
           if (args.length > 1) fileArg = args[1];
       } else if (args.length > 0) {
           fileArg = args[0];
       }
       
       if (fileArg) {
           const node = getNode(resolvePath(cwd, fileArg));
           if (node && node.type === 'file') content = node.content;
       } else if (stdin !== undefined) {
           content = stdin;
       } else {
           output = 'base64: missing operand';
           return finalize(output, newCwd);
       }
       
       try {
           if (decode) {
               const cleanContent = content.replace(/\s/g, '');
               output = atob(cleanContent);
           } else {
               output = btoa(content);
           }
       } catch (e) {
           output = 'base64: invalid input';
       }
       break;
    }
    case 'hexdump':
    case 'xxd': {
      let content = '';
      if (args.length > 0) {
          const node = getNode(resolvePath(cwd, args[0]));
          if (node && node.type === 'file') content = node.content;
      } else if (stdin !== undefined) {
          content = stdin;
      } else {
          output = `usage: ${command} <file>`;
          return finalize(output, newCwd);
      }
      
      const lines = [];
      for (let i = 0; i < content.length; i += 16) {
        const chunk = content.slice(i, i + 16);
        const hexParts = [];
        for(let j=0; j<chunk.length; j++) {
            hexParts.push(chunk.charCodeAt(j).toString(16).padStart(2, '0'));
            if (j === 7) hexParts.push(''); 
        }
        const hex = hexParts.join(' ');
        const ascii = chunk.split('').map(c => {
           const code = c.charCodeAt(0);
           return (code >= 32 && code <= 126) ? c : '.';
        }).join('');
        lines.push(`${i.toString(16).padStart(8, '0')}: ${hex.padEnd(49, ' ')}  ${ascii}`);
      }
      output = lines.join('\n');
      break;
    }
    case 'md5sum': {
       if (args.length < 1) {
          output = 'usage: md5sum <file...>';
       } else {
          output = args.map(arg => {
             // Handle wildcard expansion manually since shell doesn't do it globally yet
             if (arg.includes('*')) {
                 const dirPart = arg.substring(0, arg.lastIndexOf('/') + 1) || './';
                 const pattern = arg.substring(arg.lastIndexOf('/') + 1);
                 
                 const dirPath = resolvePath(cwd, dirPart);
                 const dirNode = getNode(dirPath);
                 
                 if (dirNode && dirNode.type === 'dir') {
                     const regex = new RegExp('^' + pattern.replace(/\*/g, '.*') + '$');
                     const matches = dirNode.children.filter(f => regex.test(f));
                     
                     if (matches.length === 0) return `md5sum: ${arg}: No such file or directory`;
                     
                     return matches.map(f => {
                         const fullPath = dirPath === '/' ? `/${f}` : `${dirPath}/${f}`;
                         const node = getNode(fullPath);
                         if (node && node.type === 'file') {
                             // Mock hashes based on filename/content
                             let hash = '';
                             if (f === 'dump_v2.bin') hash = 'e5d0979f87654321deadbeef00000000';
                             else if (f === 'dump_v1.bin') hash = 'a1b2c3d4e5f67890123456789abcdef0';
                             else if (f === 'dump_v3.bin') hash = 'f0e1d2c3b4a596877890abcdef123456';
                             else if (f === 'satellite_uplink' || f === 'satellite_uplink.bak') {
                                 if ((node as any).content.includes('CORRUPTED')) hash = 'bad1dea7bad1dea7bad1dea7bad1dea7';
                                 else hash = 'cafebabe12345678cafebabe12345678';
                             }
                             else {
                                 // Simple hash of content length + name
                                 hash = (node.content.length + f).split('').map(c => c.charCodeAt(0).toString(16)).join('').substring(0, 32).padEnd(32, '0');
                             }
                             return `${hash}  ${f}`;
                         }
                         return '';
                     }).filter(Boolean).join('\n');
                 }
                 return `md5sum: ${arg}: No such file or directory`;
             }

             const path = resolvePath(cwd, arg);
             const node = getNode(path);
             if (!node) return `md5sum: ${arg}: No such file or directory`;
             if (node.type === 'dir') return `md5sum: ${arg}: Is a directory`;
             if (node.type === 'symlink') return `md5sum: ${arg}: Is a symbolic link (not followed)`;
             
             const f = arg.split('/').pop() || arg;
             let hash = '';
             if (f === 'dump_v2.bin') hash = 'e5d0979f87654321deadbeef00000000';
             else if (f === 'dump_v1.bin') hash = 'a1b2c3d4e5f67890123456789abcdef0';
             else if (f === 'dump_v3.bin') hash = 'f0e1d2c3b4a596877890abcdef123456';
             else if (f === 'satellite_uplink' || f === 'satellite_uplink.bak') {
                 if ((node as any).content.includes('CORRUPTED')) hash = 'bad1dea7bad1dea7bad1dea7bad1dea7';
                 else hash = 'cafebabe12345678cafebabe12345678';
             }
             else {
                 hash = ((node as any).content.length + f).split('').map(c => c.charCodeAt(0).toString(16)).join('').substring(0, 32).padEnd(32, '0');
             }
             return `${hash}  ${arg}`;
          }).join('\n');
       }
       break;
    }
    case 'void_crypt': {
        const libPath = ENV_VARS['LD_LIBRARY_PATH'];
        if (!libPath || !libPath.includes('/opt/libs')) {
            output = 'void_crypt: error while loading shared libraries: libvoid.so: cannot open shared object file: No such file or directory';
        } else {
            output = 'Initializing Void Cryptography Engine...\n[LOADING] libvoid.so... OK\n[DECRYPTING] Payload verified.\n\nACCESS KEY: GHOST_ROOT{L1NK3R_P4TH_H4CK3R}';
            VFS['/var/run/void_solved'] = { type: 'file', content: 'TRUE' };
        }
        break;
    }
    case 'php': {
       if (args.length > 0) {
           const file = args[0];
           const node = getNode(resolvePath(cwd, file));
           if (node && node.type === 'file') {
                if (node.content.includes('<?php')) {
                    if (file.includes('shell.php')) {
                        output = 'Flag: GHOST_ROOT{W3B_SH3LL_D3T3CT3D}';
                        if (!VFS['/var/run/webshell_solved']) {
                            VFS['/var/run/webshell_solved'] = { type: 'file', content: 'TRUE' };
                            const runDir = getNode('/var/run');
                            if (runDir && runDir.type === 'dir' && !runDir.children.includes('webshell_solved')) {
                                runDir.children.push('webshell_solved');
                            }
                            output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: WEB SHELL ANALYZED.\x1b[0m`;
                        }
                    } else {
                        output = 'PHP Parse Error: syntax error, unexpected end of file';
                    }
                } else {
                    output = 'Could not open input file: ' + file;
                }
           } else {
               output = 'Could not open input file: ' + file;
           }
       } else if (stdin) {
            output = 'Interactive mode not supported.';
       } else {
           output = 'php: missing operand';
       }
       break;
    }
    // Old mystery_process implementation removed
    // Old strace implementation removed - using newer one at end of file
    case 'sudo': {
      if (args.length < 1) {
        output = 'usage: sudo <command>';
      } else if (args[0] === '-l') {
        output = 'Matching Defaults entries for ghost on ghost-root:\n    env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\n\nUser ghost may run the following commands on ghost-root:\n    (root) NOPASSWD: /usr/bin/python3 /opt/admin/restore_service.py';
      } else {
        const fullCmd = args.join(' ');
        const validCmd = '/usr/bin/python3 /opt/admin/restore_service.py';
        
        if (fullCmd.startsWith(validCmd) || fullCmd.startsWith('/opt/admin/restore_service.py')) {
            const scriptArgs = fullCmd.includes(validCmd) 
                ? fullCmd.substring(validCmd.length).trim().split(/\s+/)
                : fullCmd.substring('/opt/admin/restore_service.py'.length).trim().split(/\s+/);
            
            const authCode = scriptArgs[0];
            
            if (!authCode) {
                 output = 'Usage: restore_service.py <auth_code>';
            } else if (authCode === 'OMEGA-7-RED' || authCode === '"OMEGA-7-RED"' || authCode === "'OMEGA-7-RED'") {
                 output = 'System Restoration Sequence Initiated...\n[SUCCESS] Services Restored.\n\nFLAG: GHOST_ROOT{SUD0_PR1V_3SC_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PRIVILEGE ESCALATION.\x1b[0m';
                 return { output, newCwd, action: 'delay' };
            } else {
                 output = 'Access Denied.';
                 return { output, newCwd, action: 'delay' };
            }
        } else {
            output = `[sudo] password for ghost:\n\nghost is not in the sudoers file. This incident will be reported.`;
            return { output, newCwd, action: 'delay' };
        }
      }
      break;
    }
    case 'wall': {
      if (args.length < 1) {
         output = 'wall: usage: wall <message>';
      } else {
         const message = args.join(' ');
         const dateStr = new Date().toTimeString();
         output = `\nBroadcast message from ghost@ghost-root (pts/0) (${dateStr}):\n\n${message}\n`;
      }
      break;
    }
    case 'shutdown': {
      if (args[0] === 'now' || args[0] === '-h' && args[1] === 'now') {
          output = 'System halting...';
          return { output, newCwd, action: 'kernel_panic' };
      } else {
          const date = new Date(Date.now() + 60000); 
          output = `Shutdown scheduled for ${date.toUTCString()}, use 'shutdown -c' to cancel.`;
      }
      break;
    }
    case 'verify_status': {
        const pathVar = ENV_VARS['PATH'] || '';
        const paths = pathVar.split(':');
        
        let identity = 'ghost';
        let foundHijack = false;

        // Simulate searching PATH for "whoami"
        for (const p of paths) {
            if (p === '.' || p === cwd) {
                // Check local override
                const localWhoami = getNode(resolvePath(cwd, 'whoami'));
                if (localWhoami && localWhoami.type === 'file') {
                     const perms = (localWhoami as any).permissions || '';
                     const isExec = perms.includes('x') || perms.includes('7') || perms.includes('5'); 
                     
                     if (isExec) {
                         const content = (localWhoami as any).content || '';
                         if (content.includes('echo "admin"') || content.includes("echo 'admin'")) {
                             identity = 'admin';
                             foundHijack = true;
                         } else {
                             identity = 'ghost (local override)';
                         }
                         break; 
                     }
                }
            } else if (p === '/usr/bin' || p === '/bin') {
                break;
            }
        }

        output = `[CHECK] User Identity: ${identity}`;
        
        if (identity === 'admin') {
            output += `\nAccess Granted.\nFLAG: GHOST_ROOT{P4TH_H1J4CK_SUCC3SS}`;
            if (!VFS['/var/run/path_solved']) {
                VFS['/var/run/path_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('path_solved')) {
                    runDir.children.push('path_solved');
                }
                output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PATH HIJACKING.\x1b[0m`;
            }
        } else {
            output += `\nAccess Denied: User is ${identity}`;
        }
        break;
    }
    case 'export': {
        if (args.length === 0) {
            output = Object.entries(ENV_VARS).map(([k, v]) => `declare -x ${k}="${v}"`).join('\n');
        } else {
            const fullArg = args.join(' ');
            if (fullArg.includes('=')) {
                const eqIndex = fullArg.indexOf('=');
                const key = fullArg.substring(0, eqIndex).trim();
                let val = fullArg.substring(eqIndex + 1).trim();
                
                // Remove quotes
                if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                    val = val.slice(1, -1);
                }
                
                ENV_VARS[key] = val;
                output = ''; // Silent success
            } else {
                // export VAR (promotes local var to env - simplified: just ignore or set empty)
                // For now, assume user meant VAR=
            }
        }
        break;
    }
    case 'env':
    case 'printenv': {
        if (args.length > 0 && command === 'printenv') {
            const key = args[0];
            output = ENV_VARS[key] || '';
        } else {
            output = Object.entries(ENV_VARS)
                .filter(([k]) => !k.startsWith('_'))
                .map(([k, v]) => `${k}=${v}`)
                .join('\n');
        }
        break;
    }
    case 'decipher_v2': {
        // Cycle 48 Puzzle: Shared Library Hijack
        const ldPath = ENV_VARS['LD_LIBRARY_PATH'] || '';
        if (ldPath.includes('/opt/secret_libs')) {
             if (!VFS['/var/run/ld_path_solved']) {
                 VFS['/var/run/ld_path_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('ld_path_solved')) {
                     runDir.children.push('ld_path_solved');
                 }
                 output = `[DECIPHER_V2] Loading libraries... OK\n[DECIPHER_V2] Key Found: libcrypto.so.3\n[DECIPHER_V2] Decrypting Payload...\n\nFLAG: GHOST_ROOT{LD_PR3L0AD_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SHARED LIBRARY HIJACKED.\x1b[0m`;
             } else {
                 output = `[DECIPHER_V2] Loading libraries... OK\nFLAG: GHOST_ROOT{LD_PR3L0AD_M4ST3R}`;
             }
        } else {
             output = `decipher_v2: error while loading shared libraries: libcrypto.so.3: cannot open shared object file: No such file or directory`;
        }
        break;
    }
    case 'alias': {
        if (args.length === 0) {
            output = Object.entries(ALIASES).map(([k, v]) => `alias ${k}='${v}'`).join('\n');
        } else {
            const fullArgs = args.join(' ');
            if (fullArgs.includes('=')) {
                const eqIndex = fullArgs.indexOf('=');
                const name = fullArgs.substring(0, eqIndex).trim();
                let value = fullArgs.substring(eqIndex + 1).trim();
                if ((value.startsWith("'") && value.endsWith("'")) || (value.startsWith('"') && value.endsWith('"'))) {
                    value = value.slice(1, -1);
                }
                if (name) {
                    ALIASES[name] = value;
                } else {
                    output = `bash: alias: \`${fullArgs}\': invalid alias name`;
                }
            } else {
                if (ALIASES[fullArgs]) {
                    output = `alias ${fullArgs}='${ALIASES[fullArgs]}'`;
                } else {
                    output = `bash: alias: ${fullArgs}: not found`;
                }
            }
        }
        break;
    }
    case 'intercept': {
       if (args.length < 1) {
          output = 'usage: intercept <frequency|channel> [-v]';
       } else {
          const freq = args[0];
          output = `Initializing SIGINT protocol on ${freq}...\n[ENCRYPTED TRANSMISSION DETECTED]`;
          return { output, newCwd, action: 'intercept_sim', data: { freq } };
       }
       break;
    }
    case 'ldd': {
        if (args.length < 1) {
            output = 'usage: ldd [OPTION]... FILE...';
        } else {
            const target = args[0];
            const resolved = resolvePath(cwd, target);
            if (resolved === '/usr/bin/decrypt_core') {
                const libPath = ENV_VARS['LD_LIBRARY_PATH'] || '';
                const found = libPath.includes('/opt/secure/libs');
                output = `\tlinux-vdso.so.1 (0x00007ffe12345000)\n\tlibcrypto.so.3 => ${found ? '/opt/secure/libs/libcrypto.so.3 (0x00007f89abcdef00)' : 'not found'}\n\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f89a1234000)\n\t/lib64/ld-linux-x86-64.so.2 (0x00007f89b5678000)`;
            } else if (VFS[resolved] && VFS[resolved].type === 'file') {
                 output = '\tnot a dynamic executable';
            } else {
                 output = `ldd: ${target}: No such file or directory`;
            }
        }
        break;
    }
    case 'ln': {
        const flags = args.filter(a => a.startsWith('-'));
        const operands = args.filter(a => !a.startsWith('-'));
        
        const isSymlink = flags.some(f => f.includes('s'));
        const isForce = flags.some(f => f.includes('f'));
        
        if (!isSymlink) {
            output = 'ln: currently only supports symbolic links (-s)';
        } else if (operands.length < 2) {
            output = 'usage: ln -s [-f] <target> <link_name>';
        } else {
            const target = operands[0];
            const linkName = operands[1];
            
            // Resolve linkName relative to CWD
            let linkPath = '';
            if (linkName.startsWith('/')) {
                linkPath = linkName;
            } else {
                // Handle relative paths properly
                const parts = cwd.split('/').filter(Boolean);
                const relParts = linkName.split('/').filter(Boolean);
                for (const p of relParts) {
                    if (p === '..') parts.pop();
                    else if (p !== '.') parts.push(p);
                }
                linkPath = '/' + parts.join('/');
            }
            
            const fileName = linkPath.split('/').pop();
            const parentPath = linkPath.substring(0, linkPath.lastIndexOf('/')) || '/';
            
            const parentNode = getNode(parentPath);
            
            if (!parentNode || parentNode.type !== 'dir') {
                output = `ln: failed to create symbolic link '${linkName}': No such directory`;
            } else {
                // Check if file exists
                if (parentNode.children.includes(fileName!) && !isForce) {
                    // Check if it's really there or just a broken link (VFS handles broken links as existing nodes usually)
                    output = `ln: failed to create symbolic link '${linkName}': File exists`;
                } else {
                    // Create the link
                    VFS[linkPath] = {
                        type: 'symlink',
                        target: target,
                        permissions: '777'
                    } as any;
                    
                    if (!parentNode.children.includes(fileName!)) {
                        parentNode.children.push(fileName!);
                    }
                    
                    // Cycle 143 Win Condition
                    if (linkPath === '/opt/libs/libghost.so' && target === '/opt/libs/libghost.so.1.0') {
                        if (!VFS['/var/run/symlink_solved']) {
                            VFS['/var/run/symlink_solved'] = { type: 'file', content: 'TRUE' };
                            const runDir = getNode('/var/run');
                            if (runDir && runDir.type === 'dir' && !runDir.children.includes('symlink_solved')) {
                                runDir.children.push('symlink_solved');
                            }
                            output = `[SUCCESS] Symlink repaired.\n[SYSTEM] Library libghost.so now points to valid version 1.0.\nFLAG: GHOST_ROOT{D4NGL1NG_SYML1NK_F1X3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BROKEN LINK REPAIRED.\x1b[0m`;
                        }
                    } 
                }
            }
        }
        break;
    }
    // Cycle 199: repair-sys
    case 'repair-sys': {
        const configPath = '/etc/ghost/config.json';
        const backupPath = '/usr/share/ghost/config.json.bak';
        
        const node = getNode(configPath);
        
        if (!node) {
             output = `[ERROR] Configuration file missing: ${configPath}\n[HINT] Restore it from backup: ${backupPath}`;
        } else if (node.type !== 'symlink') {
             output = `[ERROR] Configuration file is not a symbolic link.\n[EXPECTED] Symlink to ${backupPath}`;
        } else if (node.target !== backupPath) {
             output = `[ERROR] Configuration file points to invalid location: ${node.target}\n[EXPECTED] Symlink to ${backupPath}`;
        } else {
             output = `[SYSTEM] Verifying configuration...\n[OK] Config file found.\n[OK] Target verified: ${backupPath}\n[SUCCESS] System Repaired.\nFLAG: GHOST_ROOT{SYML1NK_R3C0V3RY_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM REPAIRED.\x1b[0m`;
        }
        break;
    }

    case 'fsck': {
        if (args.length < 1) {
            output = 'fsck: usage: fsck <device>';
        } else {
            const device = args[0];
            const fullPath = resolvePath(cwd, device);
            if (fullPath === '/dev/sdb1' || fullPath === '/mnt/data') {
                 if (VFS['/var/run/fsck_fixed']) {
                     output = `fsck from util-linux 2.34\ne2fsck 1.45.5 (07-Jan-2020)\n${device}: clean, 11/65536 files, 4598/262144 blocks`;
                 } else {
                     VFS['/var/run/fsck_fixed'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('fsck_fixed')) {
                         runDir.children.push('fsck_fixed');
                     }
                     
                     if (!VFS['/mnt/data/secure_store.bin']) {
                         VFS['/mnt/data/secure_store.bin'] = {
                             type: 'file',
                             content: 'FLAG: GHOST_ROOT{FSCK_R3SCU3_M4ST3R}'
                         };
                         const dataDir = getNode('/mnt/data');
                         if (dataDir && dataDir.type === 'dir' && !dataDir.children.includes('secure_store.bin')) {
                             dataDir.children.push('secure_store.bin');
                         }
                     }
                     if (MOUNT_OPTIONS['/mnt/data']) {
                         delete MOUNT_OPTIONS['/mnt/data'];
                     }

                     output = `fsck from util-linux 2.34\ne2fsck 1.45.5 (07-Jan-2020)\n${device}: recovering journal\n${device}: clean, 11/65536 files, 4598/262144 blocks\n\n[SUCCESS] Filesystem Repaired.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SUPERBLOCK RECOVERED.\x1b[0m`;
                 }
            } else {
                 output = `fsck: ${device}: No such file or directory`; // Simulate bad superblock for others? No, simple not found is fine or "Bad magic number"
                 // If the file exists but isn't the target
                 if (getNode(fullPath)) {
                      output = `fsck: ${device}: Bad magic number in super-block`;
                 }
            }
        }
        break;
    }
    case 'unshadow': {
        // Mock unshadow
        if (args.length < 2) {
            output = 'usage: unshadow <passwd-file> <shadow-file>';
        } else {
            const passwdFile = args[0];
            const shadowFile = args[1];
            
            const passwdNode = getNode(resolvePath(cwd, passwdFile));
            const shadowNode = getNode(resolvePath(cwd, shadowFile));
            
            if (!passwdNode || passwdNode.type !== 'file') {
                output = `unshadow: ${passwdFile}: No such file or directory`;
            } else if (!shadowNode || shadowNode.type !== 'file') {
                output = `unshadow: ${shadowFile}: No such file or directory`;
            } else {
                // Combine them
                const passwdLines = passwdNode.content.split('\n').filter(Boolean);
                const shadowLines = shadowNode.content.split('\n').filter(Boolean);
                
                let unshadowed = '';
                for (const line of passwdLines) {
                    const parts = line.split(':');
                    const user = parts[0];
                    const shadowLine = shadowLines.find(l => l.startsWith(`${user}:`));
                    if (shadowLine) {
                        const hash = shadowLine.split(':')[1];
                        unshadowed += `${user}:${hash}:${parts[2]}:${parts[3]}:${parts[4]}:${parts[5]}:${parts[6]}\n`;
                    }
                }
                output = unshadowed;
            }
        }
        break;
    }
    case 'john': {
        // Mock john
        if (args.length < 1) {
            output = 'usage: john <password-file>';
        } else {
            const targetFile = args[args.length - 1]; // Last arg is usually the file
            const fileNode = getNode(resolvePath(cwd, targetFile));
            
            if (!fileNode || fileNode.type !== 'file') {
                output = `john: ${targetFile}: No such file or directory`;
            } else {
                const content = fileNode.content;
                output = `Created directory: /home/ghost/.john\nUsing default input encoding: UTF-8\nLoaded 3 password hashes with 3 different salts (crypt, generic crypt(3) [? 64/64])\nPress 'q' or Ctrl-C to abort, almost any other key for status\n`;
                
                if (content.includes('admin:$1$528392$D7.F7/203.493')) {
                    output += `123456           (admin)\n`;
                    output += `\n1g 0:00:00:00 DONE 2/3 (2026-02-14 06:00) 4.333g/s 416.6p/s 416.6c/s 416.6C/s 123456..google\nUse the "--show" option to display all of the cracked passwords reliably\nSession completed.\n\nFLAG: GHOST_ROOT{SH4D0W_F1L3_CR4CK3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PASSWORD CRACKED.\x1b[0m`;
                    
                    if (!VFS['/var/run/john_solved']) {
                        VFS['/var/run/john_solved'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('john_solved')) {
                            runDir.children.push('john_solved');
                        }
                    }
                } else {
                    output += `\n0g 0:00:00:05 DONE 0/3 (2026-02-14 06:00) 0g/s 300p/s 300c/s 300C/s\nSession completed.`;
                }
            }
        }
        break;
    }
    // Cycle 255: Logic consolidated below
    case 'ls': {
      const flags = args.filter(arg => arg.startsWith('-'));
      const paths = args.filter(arg => !arg.startsWith('-'));
      const targetPath = paths[0] ? resolvePath(cwd, paths[0]) : cwd;

      if ((targetPath.startsWith('/root') || targetPath.startsWith('/home/dr_akira')) && !VFS['/tmp/.root_session']) {
          output = `ls: cannot open directory '${targetPath}': Permission denied`;
          break;
      }
      
      const showHidden = flags.some(f => f.includes('a'));
      const longFormat = flags.some(f => f.includes('l'));
      
      const node = getNode(targetPath);
      
      if (!node) {
        output = `ls: ${targetPath}: No such file or directory`;
      } else if (node.type === 'file') {
        output = paths[0];
      } else if (node.type === 'dir') {
        let items = node.children;
        if (!showHidden) {
          items = items.filter(item => !item.startsWith('.'));
        }
        
        if (LOADED_MODULES.includes('rootkit')) {
          // Rootkit hides itself and other sensitive files
          items = items.filter(item => !item.includes('rootkit') && !item.startsWith('ghost_') && !item.includes('spectre') && item !== 'secrets');
        }
        
        if (longFormat) {
          output = items.map(item => {
             const itemPath = targetPath === '/' ? `/${item}` : `${targetPath}/${item}`;
             const itemNode = getNode(itemPath);
             const isDir = itemNode?.type === 'dir';
             const isLink = itemNode?.type === 'symlink';
             
             // Permission Logic
             let mode = (itemNode as any).permissions;
             if (!mode) mode = isDir ? '755' : '644';
             if (isLink) mode = '777';
             
             // Normalize to 4 digits (e.g., 755 -> 0755)
             if (mode.length === 3) mode = '0' + mode;
             
             const special = parseInt(mode[0], 10);
             const owner = parseInt(mode[1], 10);
             const group = parseInt(mode[2], 10);
             const other = parseInt(mode[3], 10);

             const rwx = (n: number, s: boolean, char: string = 's') => {
                 const lower = char.toLowerCase();
                 const upper = char.toUpperCase();
                 return (n & 4 ? 'r' : '-') + (n & 2 ? 'w' : '-') + (s ? (n & 1 ? lower : upper) : (n & 1 ? 'x' : '-'));
             };
             
             const typeChar = isLink ? 'l' : (isDir ? 'd' : '-');
             const pStr = typeChar + 
                          rwx(owner, !!(special & 4)) + 
                          rwx(group, !!(special & 2)) + 
                          rwx(other, !!(special & 1), 't');
             
             const realSize = (itemNode && itemNode.type === 'file') ? ((itemNode as any).size || itemNode.content.length) : (isLink ? 16 : 4096);
             const date = 'Oct 23 14:02'; 
             let name = item;
             if (isDir) name = `${C_BLUE}${item}${C_RESET}`;
             if (isLink) {
                 const target = (itemNode as any).target;
                 // Resolve target to check existence (for red color)
                 // Simplified: If target starts with /, check VFS. If relative, try resolve.
                 let targetPathResolved = target;
                 if (!target.startsWith('/')) {
                     // Very rough relative check
                 }
                 const targetNode = getNode(target);
                 const color = targetNode ? C_CYAN : '\x1b[31m'; // Cyan if valid, Red if broken
                 name = `${color}${item}${C_RESET} -> ${target}`;
             }
             return `${pStr} 1 ghost ghost ${String(realSize).padStart(5)} ${date} ${name}`;
          }).join('\n');
        } else {
          output = items.map(item => {
             const itemPath = targetPath === '/' ? `/${item}` : `${targetPath}/${item}`;
             const itemNode = getNode(itemPath);
             const isLink = itemNode?.type === 'symlink';
             if (isLink) return `${C_CYAN}${item}${C_RESET}`;
             return (itemNode?.type === 'dir') ? `${C_BLUE}${item}${C_RESET}` : item;
          }).join('  ');
        }

        // Cycle 103 Win Check
        if (VFS['/tmp/bin/ls'] && ENV_VARS['PATH'] && !ENV_VARS['PATH'].includes('/tmp/bin')) {
             if (!VFS['/var/run/path_hijack_solved']) {
                 VFS['/var/run/path_hijack_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('path_hijack_solved')) {
                     runDir.children.push('path_hijack_solved');
                 }
                 output += `\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PATH RESTORED.\x1b[0m\nFLAG: GHOST_ROOT{P4TH_H1J4CK_N3UTR4L1Z3D}`;
             }
        }
      }
      break;
    }
    case 'firewall_bypass': {
        if (args.length < 2 || args[0] !== '--ip') {
            output = 'usage: firewall_bypass --ip <TARGET_IP>';
        } else {
            const ip = args[1];
            if (ip === '10.0.0.99') {
                output = '[SUCCESS] Firewall bypassed. CONNECTION ESTABLISHED.\n\nFLAG: GHOST_ROOT{GREP_F1LT3R_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: LOG ANALYSIS (GREP).\x1b[0m';
                if (!VFS['/var/run/firewall_solved']) {
                    VFS['/var/run/firewall_solved'] = { type: 'file', content: 'TRUE' };
                    const runDir = getNode('/var/run');
                    if (runDir && runDir.type === 'dir' && !runDir.children.includes('firewall_solved')) {
                        runDir.children.push('firewall_solved');
                    }
                }
            } else {
                output = `[ERROR] Connection failed. IP ${ip} rejected by firewall rules.`;
            }
        }
        break;
    }
    case 'cd': {
      const target = args[0] || '/';
      let potentialPath = resolvePath(cwd, target);
      
      // Handle ~
      if (target === '~') potentialPath = '/home/ghost';
      
      const targetNode = getNode(potentialPath);
      
      if (!targetNode) {
        output = `bash: cd: ${target}: No such file or directory`;
      } else if (targetNode.type !== 'dir') {
        output = `bash: cd: ${target}: Not a directory`;
      } else if ((potentialPath.startsWith('/root') || potentialPath.startsWith('/home/dr_akira')) && !VFS['/tmp/.root_session']) {
        output = `bash: cd: ${target}: Permission denied`;
      } else {
        newCwd = potentialPath;
      }
      break;
    }
    case 'strings': {
       if (args.length < 1) {
          output = 'usage: strings <file>';
       } else {
          const fileTarget = args[0];
          const filePath = resolvePath(cwd, fileTarget);
          const fileNode = getNode(filePath);

          if (!fileNode) {
             output = `strings: '${fileTarget}': No such file`;
          } else if (fileNode.type === 'dir') {
             output = `strings: ${fileTarget}: Is a directory`;
          } else if (fileNode.type === 'symlink') {
             output = `strings: ${fileTarget}: Is a symbolic link`;
          } else {
             const content = (fileNode as any).content || '';
             const matches = content.match(/[\x20-\x7E]{4,}/g);
             if (matches) {
                 output = matches.join('\n');
                 if (content.includes('GHOST_ROOT{STR1NGS_R3V3AL_TRUTH}')) {
                     if (!VFS['/var/run/strings_solved']) {
                         VFS['/var/run/strings_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('strings_solved')) {
                             runDir.children.push('strings_solved');
                         }
                         output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN STRINGS REVEALED.\x1b[0m`;
                     }
                 }
                 if (content.includes('GHOST_ROOT{PR0C_3NV_L34K}')) {
                     if (!VFS['/var/run/proc_env_solved']) {
                         VFS['/var/run/proc_env_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('proc_env_solved')) {
                             runDir.children.push('proc_env_solved');
                         }
                         output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PROCESS ENVIRONMENT INSPECTED.\x1b[0m`;
                     }
                 }
             } else {
                 output = '';
             }
          }
       }
       break;
    }
    case 'recover_tool': {
        output = `[RECOVERY] Initializing...\n[ERROR] SEGMENTATION FAULT (core dumped)\n[SYSTEM] Memory dump saved to /var/crash/recover_tool.core`;
        break;
    }
    case 'mail': {
       const mailPath = '/var/mail/ghost';
       const mailNode = getNode(mailPath);
       
       if (!mailNode || mailNode.type !== 'file') {
          output = 'No mail for ghost';
       } else {
          const emails = mailNode.content.split('---').map(e => e.trim()).filter(Boolean);
          if (args.length === 0) {
             if (emails.length === 0) {
                output = 'No messages.';
             } else {
                output = emails.map((email, i) => {
                   const lines = email.split('\n');
                   const fromLine = lines.find(l => l.startsWith('From:')) || 'From: Unknown';
                   const subjectLine = lines.find(l => l.startsWith('Subject:')) || 'Subject: (No Subject)';
                   const from = fromLine.replace('From:', '').trim();
                   const subject = subjectLine.replace('Subject:', '').trim();
                   return `[${i + 1}]  ${from.padEnd(20)}  ${subject}`;
                }).join('\n');
                output = `Mailbox: /var/mail/ghost\n\n${output}\n\nType 'mail <id>' to read.`;
             }
          } else {
             const id = parseInt(args[0], 10);
             if (isNaN(id) || id < 1 || id > emails.length) {
                output = `Invalid message ID: ${args[0]}`;
             } else {
                output = emails[id - 1];
             }
          }
       }
       break;
    }
    case 'journal': {
        const journalPath = '/home/ghost/journal';
        const journalNode = getNode(journalPath);
        if (!journalNode || journalNode.type !== 'dir') {
            output = 'Journal not found.';
        } else {
            if (args.length === 0) {
                output = `Ghost's Journal:\n\n${journalNode.children.map(f => {
                    const isEncrypted = f.endsWith('.enc');
                    return `  - ${f} ${isEncrypted ? '[ENCRYPTED]' : ''}`;
                }).join('\n')}\n\nType 'journal <filename>' to read.`;
            } else {
                const entryName = args[0];
                const entryPath = `${journalPath}/${entryName}`;
                const entryNode = getNode(entryPath);
                if (!entryNode) {
                    output = `journal: ${entryName}: Entry not found.`;
                } else if (entryNode.type === 'dir') {
                    output = `journal: ${entryName}: Is a directory.`;
                } else {
                    if (entryName.endsWith('.enc')) {
                        output = `This entry is encrypted.\nUse 'decrypt ${entryPath} [password]' to read it.`;
                    } else {
                        output = (entryNode as any).content || 'Error: Cannot read content.';
                    }
                }
            }
        }
        break;
    }
    case 'journalctl': {
        const syslog = getNode('/var/log/syslog');
        if (!syslog || syslog.type !== 'file') {
            output = 'No journal files found.';
        } else {
            const lines = syslog.content.split('\n');
            if (args.includes('-f')) {
                output = lines.slice(-10).join('\n') + '\n\n[JOURNAL] Following new entries... (Ctrl+C to exit)';
                return { output, newCwd, action: 'delay' };
            }
            const nIndex = args.indexOf('-n');
            if (nIndex !== -1 && args[nIndex + 1]) {
                const n = parseInt(args[nIndex + 1], 10);
                if (!isNaN(n)) {
                    output = lines.slice(-n).join('\n');
                } else {
                    output = 'journalctl: invalid line count';
                }
            } else {
                output = syslog.content;
            }
        }
        break;
    }
    case 'pwd':
      output = cwd;
      break;
    case 'date': {
        if (args.length > 0 && args[0] === '-s') {
            const isRoot = !!getNode('/tmp/.root_session');
            if (!isRoot) {
                output = 'date: cannot set date: Operation not permitted';
            } else {
                output = 'Thu Feb 12 09:00:00 UTC 2026';
                SYSTEM_TIME_OFFSET = 0; // Fix time
            }
        } else {
            const now = Date.now() + SYSTEM_TIME_OFFSET;
            output = new Date(now).toString();
        }
        break;
    }
    case 'ntpdate': {
        const isRoot = !!getNode('/tmp/.root_session');
        if (!isRoot) {
            output = 'ntpdate: bind() fails: Permission denied';
        } else {
            if (args.length < 1) {
                output = 'usage: ntpdate <server>';
            } else {
                output = `ntpdate: step time server ${args[0]} offset ${Math.abs(SYSTEM_TIME_OFFSET) / 1000} sec`;
                SYSTEM_TIME_OFFSET = 0; // Fix time
            }
        }
        break;
    }
    case 'rdate': {
        const isRoot = !!getNode('/tmp/.root_session');
        if (!isRoot) {
            output = 'rdate: Permission denied';
        } else {
            if (args.length < 1) {
                output = 'usage: rdate <host>';
            } else {
                output = `[rdate] Time synced with ${args[0]}`;
                SYSTEM_TIME_OFFSET = 0;
            }
        }
        break;
    }
    case 'whoami':
      output = 'ghost';
      break;
    case 'arp': {
      const arpNode = getNode('/proc/net/arp');
      if (arpNode) output = (arpNode as any).content;
      else output = 'arp: /proc/net/arp: No such file';
      break;
    }
    case 'reboot':
      output = 'Rebooting system...';
      return { output, newCwd, action: 'kernel_panic' };
    case 'su': {
      if (args.length < 2) {
          if (args[0] === 'root') {
             output = 'su: Authentication failure\n(Note: Interactive prompt not supported. Use: su root <password>)';
          } else if (args.length === 0) {
             output = 'usage: su <user> <password>';
          } else {
             output = 'su: User ' + args[0] + ' does not exist';
          }
      } else {
          const user = args[0];
          const pass = args[1];
          if (user === 'root') {
             if (pass === 'black_widow_protocol_init' || pass === 'omega_protocol_override' || pass === 'red_ledger') {
                 output = 'Authentication successful.\n[SUDO] Access granted.\nWARNING: Audit logging enabled.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ROOT ACCESS ACQUIRED.\x1b[0m';
                 // Create root session marker
                 VFS['/tmp/.root_session'] = { type: 'file', content: 'ACTIVE' };
                 return { output, newCwd, newPrompt: 'root@ghost-root#' };
             } else {
                 output = 'su: Authentication failure';
                 return { output, newCwd, action: 'delay' };
             }
          } else {
             output = 'su: User ' + user + ' does not exist';
          }
      }
      break;
    }
    case 'iptables': {
        const isRoot = !!getNode('/tmp/.root_session');
        const firewallFlushed = !!getNode('/var/run/firewall_flushed');
        const port80Deleted = !!getNode('/var/run/iptables_80_deleted');
        const outputDeleted = !!getNode('/var/run/iptables_output_deleted');

        if (args.length === 0 || args[0] === '-L' || (args.length > 1 && args[1] === '-L')) {
            if (firewallFlushed) {
                output = `Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all  --  anywhere             anywhere

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all  --  anywhere             anywhere`;
            } else {
                let rules = `Chain INPUT (policy DROP)
target     prot opt source               destination
DROP       tcp  --  10.10.99.1           anywhere             tcp dpt:ssh
DROP       icmp --  10.10.99.1           anywhere`;
                if (!port80Deleted) {
                    rules += `\nDROP       tcp  --  anywhere             anywhere             tcp dpt:http`;
                }
                rules += `\nACCEPT     all  --  anywhere             anywhere`;
                
                // Chain OUTPUT
                rules += `\n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination`;
                if (!outputDeleted) {
                    rules += `\nDROP       all  --  anywhere             1.1.1.1/32`;
                }
                output = rules;
            }
        } else if (args[0] === '-F' || args[0] === '--flush') {
            if (isRoot) {
                VFS['/var/run/firewall_flushed'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('firewall_flushed')) runDir.children.push('firewall_flushed');
                
                // Mark all as solved
                VFS['/var/run/iptables_output_deleted'] = { type: 'file', content: 'TRUE' };
                
                output = 'iptables: flushing firewall rules... done.\nChain INPUT policy changed to ACCEPT.';
                
                if (!VFS['/var/run/iptables_solved_v2']) {
                     VFS['/var/run/iptables_solved_v2'] = { type: 'file', content: 'TRUE' };
                     output += `\nFLAG: GHOST_ROOT{1PTABL3S_FLUSH_C0MPL3T3}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FIREWALL CLEARED.\x1b[0m`;
                }
            } else {
                output = 'iptables: Permission denied (you must be root)';
            }
        } else if (args[0] === '-D') {
             if (isRoot) {
                 const cmdStr = args.join(' ');
                 // iptables -D INPUT -p tcp --dport 80 -j DROP
                 if (cmdStr.includes('tcp') && (cmdStr.includes('80') || cmdStr.includes('http')) && cmdStr.includes('DROP')) {
                     VFS['/var/run/iptables_80_deleted'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('iptables_80_deleted')) runDir.children.push('iptables_80_deleted');
                     
                     output = `iptables: rule deleted.\nFLAG: GHOST_ROOT{F1R3W4LL_RUL3_D3L3T3D}`;
                     
                     if (!VFS['/var/run/iptables_solved']) {
                         VFS['/var/run/iptables_solved'] = { type: 'file', content: 'TRUE' };
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('iptables_solved')) runDir.children.push('iptables_solved');
                         output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FIREWALL BYPASSED.\x1b[0m`;
                     }
                 } else if (cmdStr.includes('OUTPUT') && (cmdStr.includes('1.1.1.1') || cmdStr.includes('1'))) {
                     // iptables -D OUTPUT 1 or iptables -D OUTPUT -d 1.1.1.1 -j DROP
                     VFS['/var/run/iptables_output_deleted'] = { type: 'file', content: 'TRUE' };
                     output = `iptables: rule deleted.\nFLAG: GHOST_ROOT{1PTABL3S_RUL3_R3M0V3D_OUT}`;
                     
                     if (!VFS['/var/run/iptables_solved_v2']) {
                         VFS['/var/run/iptables_solved_v2'] = { type: 'file', content: 'TRUE' };
                         output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: OUTBOUND TRAFFIC RESTORED.\x1b[0m`;
                     }
                 } else {
                     output = `iptables: Bad rule (does a matching rule exist in that chain?).`;
                 }
             } else {
                 output = 'iptables: Permission denied (you must be root)';
             }
        } else if (args[0] === '-A' || args[0] === '-I') {
             if (isRoot) {
                 output = `iptables: rule updated (simulated).`;
             } else {
                 output = 'iptables: Permission denied (you must be root)';
             }
        } else {
            output = 'usage: iptables [-L|--list] [-F|--flush] [-D chain rule]';
        }
        break;
    }
    case 'chattr': {
       if (args.length < 2) {
          output = 'Usage: chattr [+-=][ASacDdIijsTtu] <file>';
       } else {
          const mode = args[0];
          const target = args[1];
          const path = resolvePath(cwd, target);
          const node = getNode(path);
          
          if (!node) {
              output = `chattr: No such file or directory: ${target}`;
          } else {
              const op = mode[0];
              const attrChar = mode[1];
              
              if (attrChar !== 'i') {
                  output = `chattr: Attribute '${attrChar}' not implemented in simulation.`;
              } else {
                  let currentAttrs = FILE_ATTRIBUTES[path] || [];
                  if (op === '+') {
                      if (!currentAttrs.includes('i')) currentAttrs.push('i');
                  } else if (op === '-') {
                      currentAttrs = currentAttrs.filter(a => a !== 'i');
                  }
                  
                  FILE_ATTRIBUTES[path] = currentAttrs;
                  saveSystemState();
                  output = ''; // Silent success
              }
          }
       }
       break;
    }
    case 'lsattr': {
       if (args.length < 1) {
          output = 'Usage: lsattr <file>';
       } else {
          const target = args[0];
          const path = resolvePath(cwd, target);
          const node = getNode(path);
          
          if (!node) {
              output = `lsattr: No such file or directory: ${target}`;
          } else {
              const attrs = FILE_ATTRIBUTES[path] || [];
              const attrStr = '----------------'.split('');
              if (attrs.includes('i')) attrStr[4] = 'i';
              output = `${attrStr.join('')} ${path}`;
          }
       }
       break;
    }
    case 'chmod': {
       if (args.length < 2) {
          output = 'usage: chmod <mode> <file>';
       } else {
          const mode = args[0];
          const target = args[1];
          const path = resolvePath(cwd, target);
          const node = getNode(path);

          if (!node) {
              output = `chmod: cannot access '${target}': No such file or directory`;
          } else {
              let applied = false;
              let newMode = '';
              let current = (node as any).permissions || ((node.type === 'dir') ? '0755' : '0644');
              if (current.length === 3) current = '0' + current;

              // Symbolic mode support
              if (mode === 'u+s' || mode === '+s') {
                   let special = parseInt(current[0], 10);
                   special |= 4; // Set SUID bit
                   newMode = special.toString() + current.slice(1);
              } else if (mode === 'u-s' || mode === '-s') {
                   let special = parseInt(current[0], 10);
                   special &= ~4; // Clear SUID bit
                   newMode = special.toString() + current.slice(1);
              } else if (mode === '+t' || mode === 'o+t') {
                   let special = parseInt(current[0], 10);
                   special |= 1; // Set Sticky bit
                   newMode = special.toString() + current.slice(1);
              } else if (mode === '-t') {
                   let special = parseInt(current[0], 10);
                   special &= ~1; // Clear Sticky bit
                   newMode = special.toString() + current.slice(1);
              } else if (/^[0-7]{3,4}$/.test(mode)) {
                   newMode = mode.length === 3 ? '0' + mode : mode;
              } else {
                  output = `chmod: invalid mode: '${mode}'`;
                  applied = true; // Error set
              }

              if (!applied && output === '') {
                  const isSystemFile = path.startsWith('/bin') || path.startsWith('/usr') || path.startsWith('/etc') || path === '/';
                  const isRoot = !!getNode('/tmp/.root_session');
                  
                  // Allow chmod on /tmp and /tmp/public specifically for puzzles
                  const isAllowed = path === '/tmp' || path === '/tmp/public' || path === '/usr/local/bin/dark_node' || path === '/usr/local/bin/satellite_fix' || path === '/usr/bin/doomsday' || isRoot;

                  if (isSystemFile && !isAllowed) {
                      output = `chmod: changing permissions of '${target}': Operation not permitted`;
                  } else {
                      // Apply permission
                      (node as any).permissions = newMode;
                      output = ''; // Silent success
                      
                      // Cycle 138 Win Condition (SUID Removal)
                      if (path === '/usr/bin/backdoor' && !newMode.startsWith('4')) {
                           if (!VFS['/var/run/suid_solved']) {
                               VFS['/var/run/suid_solved'] = { type: 'file', content: 'TRUE' };
                               const runDir = getNode('/var/run');
                               if (runDir && runDir.type === 'dir' && !runDir.children.includes('suid_solved')) {
                                   if (runDir.children) runDir.children.push('suid_solved');
                               }
                               output = `[SUCCESS] SUID bit removed.\n[SYSTEM] Backdoor neutralized.\nFLAG: GHOST_ROOT{SU1D_B1T_CL3AR3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SUID BINARY SECURED.\x1b[0m`;
                           }
                      }
                      
                      // Cycle 142 Win Condition (Sticky Bit Set)
                      // Sticky bit is 1xxx (e.g. 1777). First digit has bit 1 set (1, 3, 5, 7)
                      const firstDigit = parseInt(newMode[0], 10);
                      if (path === '/tmp/public' && (firstDigit & 1)) {
                           if (!VFS['/var/run/sticky_solved']) {
                               VFS['/var/run/sticky_solved'] = { type: 'file', content: 'TRUE' };
                               const runDir = getNode('/var/run');
                               if (runDir && runDir.type === 'dir' && !runDir.children.includes('sticky_solved')) {
                                   if (runDir.children) runDir.children.push('sticky_solved');
                               }
                               output = `[SUCCESS] Sticky bit set on /tmp/public.\n[SYSTEM] Directory secured against unauthorized deletion.\nFLAG: GHOST_ROOT{ST1CKY_B1T_S3CUR3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SECURE PUBLIC DIR.\x1b[0m`;
                           }
                      }

                      // Cycle 272 Win Condition (SUID Addition)
                      if (path === '/usr/bin/doas' && newMode.startsWith('4')) {
                           if (!VFS['/var/run/doas_solved']) {
                               VFS['/var/run/doas_solved'] = { type: 'file', content: 'TRUE' };
                               const runDir = getNode('/var/run');
                               if (runDir && runDir.type === 'dir' && !runDir.children.includes('doas_solved')) {
                                   if (runDir.children) runDir.children.push('doas_solved');
                               }
                               output = `[SUCCESS] SUID bit set on /usr/bin/doas.\n[SYSTEM] Privilege Escalation Enabled.\nFLAG: GHOST_ROOT{SU1D_P0W3R_UNL0CK3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SUID PRIVILEGE ESCALATION.\x1b[0m`;
                           }
                      }
                  }
              }
          }
       }
       break;
    }
    case 'doas': {
        const node = getNode('/usr/bin/doas');
        if (!node) {
            output = 'doas: command not found';
        } else {
            const perms = (node as any).permissions || '0755';
            const modeStr = perms.length === 3 ? '0' + perms : perms;
            if (modeStr.startsWith('4')) {
                 output = '[DOAS] Authenticating root...\n[SUCCESS] Access Granted.\nFLAG: GHOST_ROOT{SU1D_P0W3R_UNL0CK3D}';
            } else {
                 output = 'doas: Operation not permitted (must be setuid root)';
            }
        }
        break;
    }
    // Cycle 255: Logic moved to consolidated block at end of file
    case 'find': {
        if (args.length === 0) {
            output = 'usage: find <path> [options]';
        } else {
            const startPath = resolvePath(cwd, args[0]);
            const nouser = args.includes('-nouser');
            const nameIdx = args.indexOf('-name');
            const namePattern = nameIdx !== -1 ? args[nameIdx + 1] : null;
            const permIdx = args.indexOf('-perm');
            const permMode = permIdx !== -1 ? args[permIdx + 1] : null;
            const sizeIdx = args.indexOf('-size');
            const sizeArg = sizeIdx !== -1 ? args[sizeIdx + 1] : null;
            
            const results: string[] = [];
            const walk = (currentPath: string) => {
                const node = getNode(currentPath);
                if (!node) return;
                let matches = true;
                if (nouser) {
                    if (currentPath !== '/home/ghost/old_user_data') matches = false;
                }
                if (namePattern) {
                    const fileName = currentPath.split('/').pop() || '';
                    const regex = new RegExp('^' + namePattern.replace(/\*/g, '.*') + '$');
                    if (!regex.test(fileName)) matches = false;
                }
                if (permMode) {
                    const nodePerms = (node as any).permissions || (node.type === 'dir' ? '0755' : '0644');
                    if (permMode === '-4000' || permMode === '/4000') {
                        const modeStr = nodePerms.length === 3 ? '0' + nodePerms : nodePerms;
                        const special = parseInt(modeStr[0], 10);
                        if (!(special & 4)) matches = false;
                    } else if (permMode !== nodePerms) matches = false;
                }
                if (sizeArg && node.type === 'file') {
                    const size = (node as any).size || (node as any).content.length;
                    const match = sizeArg.match(/^([+-]?)(\d+)([kMG]?)$/i);
                    if (match) {
                        const mod = match[1];
                        let val = parseInt(match[2], 10);
                        const unit = match[3] ? match[3].toUpperCase() : '';
                        if (unit === 'K') val *= 1024;
                        else if (unit === 'M') val *= 1048576;
                        else if (unit === 'G') val *= 1073741824;
                        
                        if (mod === '+') { if (size <= val) matches = false; }
                        else if (mod === '-') { if (size >= val) matches = false; }
                        else { if (size !== val) matches = false; }
                    }
                }
                if (matches) results.push(currentPath);
                if (node.type === 'dir') {
                    for (const child of node.children) {
                        walk(currentPath === '/' ? `/${child}` : `${currentPath}/${child}`);
                    }
                }
            };
            walk(startPath);
            output = results.join('\n');
            
            if (sizeArg && results.includes('/var/data/leak/leak_evidence.dat')) {
                 if (!VFS['/var/run/cycle253_solved']) {
                     VFS['/var/run/cycle253_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle253_solved')) {
                         runDir.children.push('cycle253_solved');
                     }
                     output += `\n\n[SUCCESS] Large file located.\nFLAG: GHOST_ROOT{F1ND_S1Z3_M4TT3RS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DATA LEAK ISOLATED.\x1b[0m`;
                 }
            } else if (nouser && results.includes('/home/ghost/old_user_data')) {
                 if (!VFS['/var/run/find_nouser_solved']) {
                     VFS['/var/run/find_nouser_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('find_nouser_solved')) {
                         runDir.children.push('find_nouser_solved');
                     }
                     output += `\n\n[SUCCESS] Orphaned file located.\nFLAG: GHOST_ROOT{F1ND_N0US3R_ID_9999}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ORPHANED FILE RECOVERED.\x1b[0m`;
                 }
            }
        }
        break;
    }
    case 'lsattr': {
        if (args.length < 1) {
            output = 'usage: lsattr <file>';
        } else {
            const target = args[0];
            const path = resolvePath(cwd, target);
            const node = getNode(path);
            
            if (!node) {
                output = `lsattr: cannot access '${target}': No such file or directory`;
            } else {
                const attrs = FILE_ATTRIBUTES[path] || [];
                const attrStr = attrs.includes('i') ? '----i---------e----' : '-------------------';
                output = `${attrStr} ${target}`;
            }
        }
        break;
    }
    // Duplicate chmod handler removed

    case 'chattr': {
        if (args.length < 2) {
            output = 'usage: chattr [-+=][mode] <file>';
        } else {
            const modeStr = args[0];
            const target = args[1];
            const path = resolvePath(cwd, target);
            const node = getNode(path);
            
            if (!node) {
                output = `chattr: cannot access '${target}': No such file or directory`;
            } else {
                const isRoot = !!getNode('/tmp/.root_session');
                if (!isRoot) {
                    output = `chattr: changing attributes of '${target}': Operation not permitted (Root Required)`;
                } else {
                    const op = modeStr[0];
                    const flag = modeStr[1];
                    
                    if (['+', '-', '='].includes(op) && flag === 'i') {
                        const currentAttrs = FILE_ATTRIBUTES[path] || [];
                        if (op === '+') {
                            if (!currentAttrs.includes('i')) currentAttrs.push('i');
                        } else if (op === '-') {
                            const idx = currentAttrs.indexOf('i');
                            if (idx !== -1) currentAttrs.splice(idx, 1);
                        } else if (op === '=') {
                            currentAttrs.length = 0;
                            currentAttrs.push('i');
                        }
                        FILE_ATTRIBUTES[path] = currentAttrs;
                        output = '';
                    } else {
                        output = `chattr: invalid mode: '${modeStr}'`;
                    }
                }
            }
        }
        break;
    }
    case 'backup_service': {
        output = '[SYSTEM] Starting Backup Service (PID: 7777)...\n[BACKUP] Processing /var/backups/incoming...\n';
        
        const incomingPath = '/var/backups/incoming';
        const incomingNode = getNode(incomingPath);
        
        if (!incomingNode || incomingNode.type !== 'dir') {
            output += '[ERROR] Backup directory missing.';
            return { output, newCwd, action: 'delay' };
        }

        const files = incomingNode.children;
        output += `[BACKUP] Found ${files.length} files.\n`;
        
        // Check for Wildcard Injection
        // We look for strict filenames that tar interprets as flags
        const checkpoint = files.find(f => f === '--checkpoint=1');
        const actionFile = files.find(f => f.startsWith('--checkpoint-action=exec='));
        
        if (checkpoint && actionFile) {
            output += `[TAR] --checkpoint=1 detected.\n`;
            const cmd = actionFile.split('=')[2]; // exec=sh exploit.sh -> sh exploit.sh
            output += `[TAR] Executing checkpoint action: ${cmd}\n`;
            
            if (cmd.startsWith('sh')) {
                const scriptName = cmd.split(' ')[1];
                if (files.includes(scriptName)) {
                     const scriptNode = getNode(`${incomingPath}/${scriptName}`);
                     if (scriptNode && scriptNode.type === 'file') {
                         output += `[SHELL] Executing ${scriptName}...\n`;
                         const scriptContent = scriptNode.content;
                         
                         // Check if the script attempts to read the flag
                         if (scriptContent.includes('cat /root/wildcard_flag.txt') || scriptContent.includes('cp /root/wildcard_flag.txt')) {
                             output += `[OUTPUT] GHOST_ROOT{W1LDC4RD_1NJ3CT10N_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: WILDCARD INJECTION.\x1b[0m`;
                             
                             if (!VFS['/var/run/wildcard_solved']) {
                                 VFS['/var/run/wildcard_solved'] = { type: 'file', content: 'TRUE' };
                                 const runDir = getNode('/var/run');
                                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('wildcard_solved')) {
                                     runDir.children.push('wildcard_solved');
                                 }
                             }
                         } else {
                             output += `[OUTPUT] (Script executed but did not target the flag. Check path: /root/wildcard_flag.txt)`;
                         }
                     }
                } else {
                    output += `[ERROR] Script ${scriptName} not found.`;
                }
            } else {
                 output += `[ERROR] Checkpoint action must use 'sh'.`;
            }
        } else {
            output += `[BACKUP] Archiving to /dev/null... Done.`;
        }
        return { output, newCwd, action: 'delay' };
    }
    case 'export': {
        if (args.length < 1) {
            output = 'usage: export VAR=VALUE';
        } else {
            const pair = args.join(' ');
            if (pair.includes('=')) {
                const parts = pair.split('=');
                const key = parts[0];
                const val = parts.slice(1).join('=');
                if (key) {
                    ENV_VARS[key.trim()] = val.trim();
                    output = ''; // Silent
                } else {
                    output = 'export: invalid format';
                }
            } else {
                output = 'export: invalid format';
            }
        }
        break;
    }
    case 'unset': {
        if (args.length < 1) {
            output = 'usage: unset VAR';
        } else {
            const key = args[0];
            if (ENV_VARS[key]) {
                delete ENV_VARS[key];
            }
            output = '';
        }
        break;
    }
    case 'monitor': {
        const bar = '='.repeat(ALERT_LEVEL * 4).padEnd(20, ' ');
        const color = ALERT_LEVEL > 3 ? '\x1b[1;31m' : ALERT_LEVEL > 1 ? '\x1b[1;33m' : '\x1b[1;32m';
        output = `
[SYSTEM MONITOR v2.4]
---------------------
CPU Usage:    12%
Mem Usage:    34%
Net Traffic:  ${Math.floor(Math.random() * 100)} Mbps

[INTRUSION DETECTION SYSTEM]
Threat Level: ${color}[${bar}] ${ALERT_LEVEL}/5\x1b[0m
Status:       ${ALERT_LEVEL > 3 ? 'LOCKDOWN IMMINENT' : 'MONITORING'}
Active Traces: ${ALERT_LEVEL * 2}
`;
        break;
    }
    case 'env':
    case 'printenv':
       output = Object.entries(ENV_VARS).map(([k, v]) => `${k}=${v}`).join('\n');
       break;
    case 'history': {
      if (args[0] === '-c') {
         output = 'History cleared.';
         return { output, newCwd, action: 'clear_history' };
      } else {
         const historyPath = '/home/ghost/.bash_history';
         const historyNode = getNode(historyPath);
         if (historyNode && historyNode.type === 'file') {
           const lines = historyNode.content.split('\n');
           output = lines.map((line, i) => `  ${i + 1}  ${line}`).join('\n');
         } else {
           output = 'No history file found.';
         }
      }
      break;
    }
    case 'ulimit': {
        const limitType = args[0];
        const value = args[1];
        
        let currentN = parseInt(ENV_VARS['_ULIMIT_N'] || '1024', 10);
        let currentU = parseInt(ENV_VARS['_ULIMIT_U'] || '3702', 10);
        
        if (args.length === 0) {
            output = `unlimited`; 
        } else if (limitType === '-n') {
            if (value) {
                const limit = parseInt(value, 10);
                if (!isNaN(limit)) {
                    ENV_VARS['_ULIMIT_N'] = limit.toString();
                    output = '';
                } else {
                    output = `ulimit: invalid number: ${value}`;
                }
            } else {
                output = currentN.toString();
            }
        } else if (limitType === '-u') {
            if (value) {
                const limit = parseInt(value, 10);
                if (!isNaN(limit)) {
                    ENV_VARS['_ULIMIT_U'] = limit.toString();
                    output = '';
                    
                    // Cycle 132 Win Condition
                    // If we have an active fork bomb (PID 3333 usually), reducing the limit kills it.
                    const bomb = PROCESSES.find(p => p.pid === 3333);
                    if (bomb && limit < 100) {
                        PROCESSES = PROCESSES.filter(p => p.pid !== 3333 && p.pid !== 3334);
                        output = `[KERNEL] Fork bomb containment protocol active.\n[SYSTEM] Killing process 3333 (fork_bomb)... Done.\n[SYSTEM] Killing process 3334 (child)... Done.\nFLAG: GHOST_ROOT{UL1M1T_F0RK_B0MB_D3FUS3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PROCESS LIMIT ENFORCED.\x1b[0m`;
                        
                        if (!VFS['/var/run/forkbomb_solved']) {
                            VFS['/var/run/forkbomb_solved'] = { type: 'file', content: 'TRUE' };
                            const runDir = getNode('/var/run');
                            if (runDir && runDir.type === 'dir' && !runDir.children.includes('forkbomb_solved')) {
                                runDir.children.push('forkbomb_solved');
                            }
                        }
                    }
                } else {
                    output = `ulimit: invalid number: ${value}`;
                }
            } else {
                output = currentU.toString();
            }
        } else if (limitType === '-a') {
            output = `core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7777
max locked memory       (kbytes, -l) 65536
max memory size         (kbytes, -m) unlimited
open files                      (-n) ${currentN}
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) ${currentU}
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited`;
        } else {
            output = `ulimit: invalid option: ${limitType}`;
        }
        break;
    }
    case 'mass_scanner': {
        const currentLimit = parseInt(ENV_VARS['_ULIMIT_N'] || '1024', 10);
        
        if (currentLimit < 4096) {
             output = `[SCANNER] Initializing...\n[ERROR] socket() failed: Too many open files.\n[DIAGNOSTIC] Current limit: ${currentLimit}. Required: 4096.\n[HINT] Check 'ulimit -n'.`;
        } else {
             if (!VFS['/var/run/ulimit_solved']) {
                 VFS['/var/run/ulimit_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('ulimit_solved')) {
                     runDir.children.push('ulimit_solved');
                 }
                 output = `[SCANNER] Initializing...\n[SUCCESS] Sockets allocated: 4096/4096.\n[SCANNING] Target range 10.0.0.0/8...\n[RESULT] 24 hosts up.\n\nFLAG: GHOST_ROOT{R3S0URC3_L1M1T_BYP4SS3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: RESOURCE LIMITS ADJUSTED.\x1b[0m`;
             } else {
                 output = `[SCANNER] Initializing...\n[SUCCESS] Sockets allocated: 4096/4096.\nFLAG: GHOST_ROOT{R3S0URC3_L1M1T_BYP4SS3D}`;
             }
        }
        break;
    }
    case 'help':
      output = `GHOST_ROOT Recovery Shell v1.0 (Pipes Enabled)

\x1b[1;33mSTATUS\x1b[0m
  status  - View current objectives, rank, and hints.

Standard Commands:
  ls, cd, cat, pwd, clear, exit, man, mkdir, touch, rm, cp, mv

Pipe Utils:
  grep, head, tail, sort, uniq, wc, base64, rev, awk, sed, strings

Network Tools:
  ssh, ssh-keygen, ping, netstat, ss, nmap, nc, scan, netmap, trace, traceroute, wifi, telnet, curl, nslookup, dig, irc, tcpdump, tor, wget, geoip

Security Tools:
  crack, analyze, decrypt, steghide, hydra, camsnap, whois, sqlmap, binwalk

System Tools:
  ps, kill, top, dmesg, mount, umount, reboot, shutdown, uptime, w, date, systemctl, journal, journalctl, lsof, passwd, useradd

Misc:
  zip, unzip, neofetch, weather, matrix, radio, alias, env, history, calc

Type "man <command>" for more information.
Type "status" for mission objectives.`;
      break;
    case 'strings': {
        // Strings implementation (Cycle 224)
        if (args.length < 1) {
            output = 'strings: missing file operand';
        } else {
            const fileName = args[0];
            const node = getNode(resolvePath(cwd, fileName));
            if (!node || node.type !== 'file') {
                output = `strings: '${fileName}': No such file`;
            } else {
                // Extract printable strings >= 4 chars
                const content = (node as any).content || '';
                const matches = content.match(/[\x20-\x7E]{4,}/g);
                output = matches ? matches.join('\n') : '';

                // Cycle 224 Win Condition
                if (fileName.includes('sys_diag') && content.includes('GHOST_ROOT{STR1NGS_4R3_P0W3RFUL}')) {
                     if (!VFS['/var/run/strings_solved']) {
                         VFS['/var/run/strings_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('strings_solved')) {
                             runDir.children.push('strings_solved');
                         }
                         output += '\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BINARY ANALYSIS (STRINGS).\x1b[0m';
                     }
                }
            }
        }
        break;
    }
    case 'sys_diag': {
        const node = getNode('/usr/bin/sys_diag');
        if (!node) {
            output = 'sys_diag: command not found';
        } else {
            output = 'Segmentation fault (core dumped)';
        }
        break;
    }
    case 'signal_jammer': {
        const freqArg = args.indexOf('--freq');
        const gainArg = args.indexOf('--gain');
        const freq = freqArg !== -1 && args[freqArg + 1] ? parseFloat(args[freqArg + 1]) : 0;
        const gain = gainArg !== -1 && args[gainArg + 1] ? parseFloat(args[gainArg + 1]) : 0;

        if (freqArg === -1 || gainArg === -1) {
            output = 'signal_jammer: Missing required parameters.\nUsage: signal_jammer --freq <MHz> --gain <dB>\nSee "man signal_jammer" for details.';
        } else if (Math.abs(freq - 433.92) < 0.1 && gain >= 90) {
            output = `[JAMMER] Initializing Broad-Spectrum Noise...\n[TARGET] Frequency: ${freq} MHz\n[POWER] Gain: ${gain} dB\n[STATUS] JAMMING ACTIVE. DRONE LINK SEVERED.\n\nFLAG: GHOST_ROOT{M4NU4L_0V3RR1D3_SUCC3SS}`;
            
            // Mission Update
            if (!VFS['/var/run/jammer_solved']) {
                VFS['/var/run/jammer_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('jammer_solved')) {
                    runDir.children.push('jammer_solved');
                }
                output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SIGNAL DISRUPTION.\x1b[0m';
            }
        } else {
             output = `[JAMMER] Initializing...\n[ERROR] Target signal not affected. Adjust frequency or gain.\n[HINT] Check surveillance logs for enemy drone frequencies.`;
        }
        break;
    }
    case 'dark_node': {
        const node = getNode('/usr/local/bin/dark_node');
        if (!node) {
            output = 'dark_node: command not found';
        } else {
            const perms = (node as any).permissions || '0644';
            // Check executable bit (standard 755 or +x means 1, 3, 5, 7 in the last digit? No, usually 755 = rwx r-x r-x)
            // Simpler check: does it start with 7 or 5, or contain 'x'?
            // The chmod logic sets perms as string e.g. "0755".
            // Logic: if user (first char of 3-digit, second of 4-digit) is odd (1,3,5,7), it's executable.
            
            const modeStr = perms.length === 4 ? perms.slice(1) : perms; // Remove leading 0 if 4 chars
            const userDigit = parseInt(modeStr[0], 10);
            const isExecutable = (userDigit & 1) === 1; // 1=x, 4=r, 2=w. Wait. 1=x, 2=w, 4=r? 
            // r=4, w=2, x=1. So 1, 3(wx), 5(rx), 7(rwx) have x.
            
            if (!isExecutable) {
                output = 'bash: /usr/local/bin/dark_node: Permission denied';
            } else {
                if (ENV_VARS['DARK_MODE'] === '1') {
                    output = '[DARK_NODE] INITIALIZING...\n[STATUS] ONLINE.\n[SECURE] Environment Verified.\nFLAG: GHOST_ROOT{CHM0D_XM0D_G0D}\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN SERVICE ACTIVATED.\x1b[0m';
                    
                    if (!VFS['/var/run/dark_node_solved']) {
                        VFS['/var/run/dark_node_solved'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('dark_node_solved')) {
                            runDir.children.push('dark_node_solved');
                        }
                    }
                } else {
                    output = '[DARK_NODE] FATAL ERROR: ENVIRONMENT_VARIABLE_MISSING\n[REQUIRED] DARK_MODE=1\n[ACTION] Aborting.';
                }
            }
        }
        break;
    }
    case 'doomsday': {
        const node = getNode('/usr/bin/doomsday');
        if (!node) {
            output = 'doomsday: command not found';
        } else {
            const perms = (node as any).permissions || '0755';
            // Check for SUID bit (4xxx)
            // permissions string might be "0755" or "4755" or "755"
            // We standardize to 4 chars in chmod logic, but initial might be 3.
            
            const modeStr = perms.length === 3 ? '0' + perms : perms;
            const special = parseInt(modeStr[0], 10);
            const isSuid = (special & 4) === 4;

            if (!isSuid) {
                output = '[ERROR] This binary must be run as root (setuid bit missing).\n[HINT] Try \'chmod u+s\' or \'chmod 4755\'.';
            } else {
                output = '[DOOMSDAY] INITIALIZING...\n[STATUS] ONLINE.\n[SECURE] Root Privileges Verified.\nFLAG: GHOST_ROOT{SU1D_B1T_SET_C0RRECTLY}\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PRIVILEGE ESCALATION.\x1b[0m';
                
                if (!VFS['/var/run/doomsday_solved']) {
                    VFS['/var/run/doomsday_solved'] = { type: 'file', content: 'TRUE' };
                    const runDir = getNode('/var/run');
                    if (runDir && runDir.type === 'dir' && !runDir.children.includes('doomsday_solved')) {
                        runDir.children.push('doomsday_solved');
                    }
                }
            }
        }
        break;
    }
    case 'man': {
      if (args.length < 1) {
        output = 'What manual page do you want?';
      } else {
        const page = args[0];
        // Shortened for file size limits, but retaining key logic
        switch (page) {
          case 'ls': output = 'NAME\n\tls - list directory contents...'; break;
          case 'ssh': output = 'NAME\n\tssh - OpenSSH SSH client...'; break;
          case 'ssh-keygen': output = 'NAME\n\tssh-keygen - authentication key generation...'; break;
          case 'awk': output = 'NAME\n\tawk - pattern scanning and processing language...'; break;
          case 'grep': output = 'NAME\n\tgrep - print lines that match patterns...'; break;
          case 'iptables': output = 'NAME\n\tiptables - administration tool for IPv4 packet filtering and NAT\n\nSYNOPSIS\n\tiptables [-L] [-F]\n\nDESCRIPTION\n\tiptables is used to set up, maintain, and inspect the tables of IPv4 packet filter rules in the Linux kernel.\n\nOPTIONS\n\t-L, --list\n\t\tList all rules in the selected chain.\n\t-F, --flush\n\t\tFlush the selected chain (delete all rules).\n\t\tWARNING: This action requires root privileges.'; break;
          case 'tor': output = 'NAME\n\ttor - The Onion Router simulation.\n\nSYNOPSIS\n\ttor <command> [args]\n\nCOMMANDS\n\tstart - Initialize Tor circuit\n\tstatus - Check connection status\n\tlist - List hidden services\n\tbrowse <url> - Connect to .onion site'; break;
          case 'radio': output = 'NAME\n\tradio - Software Defined Radio (SDR) interface\n\nSYNOPSIS\n\tradio [scan | tune <freq>]\n\nDESCRIPTION\n\tScans for or tunes to radio frequencies. Useful for intercepting analog signals or numbers stations.\n\nEXAMPLES\n\tradio scan\n\tradio tune 89.9'; break;
          case 'netmap': output = 'NAME\n\tnetmap - Visual Network Mapper\n\nSYNOPSIS\n\tnetmap\n\nDESCRIPTION\n\tLaunches a graphical visualization of the known network topology, showing active nodes and connections.'; break;
          case 'camsnap': output = 'NAME\n\tcamsnap - CCTV/Webcam Interface\n\nSYNOPSIS\n\tcamsnap [-l] [-c <id> [-p <pass>]]\n\nDESCRIPTION\n\tConnects to unsecured video feeds on the local network.\n\nOPTIONS\n\t-l\tList available feeds\n\t-c <id>\tConnect to feed ID\n\t-p <pass>\tProvide authentication token'; break;
          case 'hydra': output = 'NAME\n\thydra - Network Logon Cracker\n\nSYNOPSIS\n\thydra -l <user> -P <passlist> <target>\n\nDESCRIPTION\n\tA very fast network logon cracker which supports many different services.'; break;
          case 'hashcat': output = 'NAME\n\thashcat - Advanced Password Recovery\n\nSYNOPSIS\n\thashcat -m <mode> <hashfile> <wordlist>\n\nDESCRIPTION\n\tWorld\'s fastest password recovery tool.\n\nMODES\n\t0\tMD5\n\t1000\tNTLM\n\t1800\tsha512crypt'; break;
          case 'beacon': output = 'NAME\n\tbeacon - Automated Dead Drop Signal\n\nSYNOPSIS\n\tbeacon [&]\n\nDESCRIPTION\n\tContinuously attempts to connect to a listening post on localhost:4444 to deliver a payload.\n\nUSAGE\n\tRun "beacon" to start foreground process (will block).\n\tRun "beacon &" to start in background.'; break;
          case 'docker': output = 'NAME\n\tdocker - Docker container management\n\nSYNOPSIS\n\tdocker [OPTIONS] COMMAND\n\nDESCRIPTION\n\tManage containers, images, and volumes.\n\nCOMMANDS\n\tps\tList containers\n\tinspect\tReturn low-level information on Docker objects\n\tlogs\tFetch the logs of a container\n\tstop\tStop one or more running containers'; break;
          case 'signal_jammer': output = 'NAME\n\tsignal_jammer - RF disruption tool\n\nSYNOPSIS\n\tsignal_jammer --freq <MHz> --gain <dB>\n\nDESCRIPTION\n\tGenerates broad-spectrum noise to disrupt radio communications.\n\nOPERATIONAL NOTES\n\tStandard Surveillance Drones (Model XJ-9) operate on 433.92 MHz.\n\tRequired Gain for effective jamming: 90 dB.\n\nWARNING\n\tUnauthorized jamming is a violation of Federal Communication Laws.'; break;
          case 'net-splice': output = 'NAME\n\tnet-splice - Advanced Network Tunneling Tool\n\nSYNOPSIS\n\tnet-splice --target <IP> --port <PORT> --mode <MODE>\n\nDESCRIPTION\n\tEstablishes a covert splice into the target network infrastructure.\n\nOPTIONS\n\t--target <IP>\n\t\tThe IP address of the target node.\n\n\t--port <PORT>\n\t\tThe destination port (default: 80, secure: 443).\n\n\t--mode <MODE>\n\t\tOperation mode. Available modes:\n\t\t- standard: Normal operation (Logged)\n\t\t- fast: Optimized for speed (Unreliable)\n\t\t- silent: Stealth mode (No logs)\n\nEXAMPLES\n\tnet-splice --target 192.168.1.1 --port 80 --mode standard'; break;
          case 'mystery_process': output = 'NAME\n\tmystery_process - System Integrity Verifier (Legacy)\n\nSYNOPSIS\n\tmystery_process\n\nDESCRIPTION\n\tChecks for the existence of critical system configuration files and verifies their integrity.\n\tDesigned to fail silently to prevent information leakage during boot sequences.\n\nDIAGNOSTICS\n\tIf the process produces no output, use a system tracer to identify missing resources.\n\nSEE ALSO\n\tstrace(1)'; break;
          case 'strace': output = 'NAME\n\tstrace - trace system calls and signals\n\nSYNOPSIS\n\tstrace <command> [args]\n\nDESCRIPTION\n\tIn the simplest case, strace runs the specified command until it exits.\n\tIt intercepts and records the system calls which are called by a process and the signals which are received by a process.\n\nEXAMPLES\n\tstrace ls\n\tstrace mystery_process'; break;
          case 'tune-receiver': output = 'NAME\n\ttune-receiver - Software Defined Radio (SDR) Interface\n\nSYNOPSIS\n\ttune-receiver --freq <MHz> --mode <MODE>\n\nDESCRIPTION\n\tTunes the internal SDR to listen for covert broadcasts.\n\nOPTIONS\n\t--freq <MHz>\n\t\tTarget frequency.\n\t\tStandard uplink frequency: 104.5 MHz.\n\t\tEmergency override frequency: 404.0 MHz.\n\n\t--mode <MODE>\n\t\tDemodulation mode.\n\t\tModes: AM, FM, USB, LSB.\n\t\tNote: Encrypted channels require "USB" (Upper Side Band).\n\nEXAMPLES\n\ttune-receiver --freq 104.5 --mode FM'; break;
          default: output = `No manual entry for ${page}`;
        }
      }
      break;
    }
    case 'wifi': {
      if (args.length < 1) {
        output = 'usage: wifi [scan|connect <ssid> <password>]';
      } else {
        const subcmd = args[0];
        if (subcmd === 'scan') {
           output = 'Scanning for wireless networks...';
           return { output, newCwd, action: 'wifi_scan_sim' };
        } else if (subcmd === 'connect') {
           if (args.length < 2) {
              output = 'usage: wifi connect <ssid> [password]';
           } else {
              const ssid = args[1];
              const password = args[2];
              
              if (ssid === 'GHOST_NET') {
                  if (password === 'spectre') {
                      output = 'Connected to GHOST_NET (10.0.0.5). Gateway: 10.0.0.1';
                  } else {
                      output = 'Authentication failed.';
                  }
              } else if (ssid === 'Guest') {
                  output = 'Connected to Guest (192.168.2.14). Internet access: Limited.';
              } else if (ssid === 'DE:AD:BE:EF:CA:FE' || ssid === 'Hidden') {
                  if (password === '0xDEADBEEF') {
                      output = 'Connected to BLACK_SITE_LINK (172.16.66.6). WARNING: TRAFFIC MONITORED.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: NETWORK LINK ESTABLISHED.\x1b[0m';
                      if (!VFS['/var/run']) VFS['/var/run'] = { type: 'dir', children: [] };
                      if (!VFS['/var/run/net_status']) {
                          VFS['/var/run/net_status'] = { type: 'file', content: 'CONNECTED_BLACK_SITE' };
                          const runDir = VFS['/var/run'];
                          if (runDir.type === 'dir' && !runDir.children.includes('net_status')) {
                              runDir.children.push('net_status');
                          }
                      }
                  } else {
                      output = 'WEP Authentication failed.';
                  }
              } else {
                  output = `Unable to connect to ${ssid}.`;
              }
           }
        } else {
           output = `wifi: unknown subcommand: ${subcmd}`;
        }
      }
      break;
    }
    case 'iwconfig':
       output = `wlan0     IEEE 802.11  ESSID:"GHOST_NET" ... (Simulated)`;
       break;
    case 'telnet': {
       if (args.length < 1) {
          output = 'telnet: usage: telnet <host> [port]';
       } else {
          const host = args[0];
          const port = args[1] || '23';
          if (host === 'towne.local' || host === '192.168.1.10') {
              if (port === '23') {
                  output = `Trying ${host}...\nConnected to ${host}...\n   STAR WARS - A NEW HOPE (ASCII)\n   (Stream interrupted by admin)\nConnection closed.`;
                  return { output, newCwd, action: 'delay' };
              } else {
                  output = `Trying ${host}...\ntelnet: Unable to connect to remote host: Connection refused`;
                  return { output, newCwd, action: 'delay' };
              }
          } else {
              output = `Trying ${host}...\ntelnet: Unable to connect to remote host: Connection timed out`;
              return { output, newCwd, action: 'delay' };
          }
       }
       break;
    }
    case 'camsnap': {
      if (args.length === 0) {
        output = 'usage: camsnap [-l] [-c <id> [-p <password>]]\n\nOptions:\n  -l             List available camera feeds\n  -c <id>        Connect to camera ID (e.g., 01)\n  -p <password>  Authentication token for restricted feeds';
      } else {
        const list = args.includes('-l');
        const connectIndex = args.indexOf('-c');
        const passIndex = args.indexOf('-p');
        
        if (list) {
            output = `Listing active feeds...
[01] CAM_LOBBY      (192.168.1.50)  - ONLINE
[02] CAM_SERVER     (192.168.1.51)  - ONLINE
[03] CAM_BLACK_SITE (10.66.6.6)     - ENCRYPTED (Auth Required)`;
        } else if (connectIndex !== -1) {
            const id = args[connectIndex + 1];
            const password = passIndex !== -1 ? args[passIndex + 1] : null;
            
            // Check auth for ID 03
            if (id === '03' && password !== 'SPECTRE_EYE' && password !== 'SPECTRE_EVE') {
                output = `camsnap: Camera ID ${id} access denied (Auth Required).`;
            } else if (['01', '02', '03'].includes(id)) {
                output = `Connecting to CAM_${id === '01' ? 'LOBBY' : id === '02' ? 'SERVER' : 'BLACK_SITE'}...`;
                return { output, newCwd, action: 'camsnap_sim', data: { id } };
            } else {
                output = `camsnap: Camera ID ${id} not found.`;
            }
        }
      }
      break;
    }
    case 'mkdir': {
       const dirPath = resolvePath(cwd, args[0]);
       if (isReadOnly(dirPath)) {
            output = `mkdir: cannot create directory '${args[0]}': Read-only file system`;
            break;
       }
       if (!!getNode('/var/cache/inodes_fill')) {
          output = `mkdir: cannot create directory '${args[0]}': No space left on device`;
          break;
       }
       // Cycle 122: Home Quota
       if (!!getNode('/home/ghost/.cache/browser/garbage.dat') && dirPath.startsWith('/home')) {
          output = `mkdir: cannot create directory '${args[0]}': Disk quota exceeded`;
          break;
       }
       if (args.length < 1) {
          output = 'usage: mkdir <directory>';
       } else {
          const dirPath = resolvePath(cwd, args[0]);
          const parentPath = dirPath.substring(0, dirPath.lastIndexOf('/')) || '/';
          const dirName = dirPath.substring(dirPath.lastIndexOf('/') + 1);
          if (!getNode(parentPath)) {
             output = `mkdir: cannot create directory '${args[0]}': No such file or directory`;
          } else if (getNode(dirPath)) {
             output = `mkdir: cannot create directory '${args[0]}': File exists`;
          } else {
             VFS[dirPath] = { type: 'dir', children: [] };
             addChild(parentPath, dirName);
             if (dirName === '.ssh' && (cwd === '/home/ghost' || dirPath === '/home/ghost/.ssh')) {
                 const keyPath = `${dirPath}/id_rsa`;
                 VFS[keyPath] = { type: 'file', content: '-----BEGIN OPENSSH PRIVATE KEY-----\nKEY_ID: GHOST_PROTOCOL_INIT\n-----END OPENSSH PRIVATE KEY-----' };
                 addChild(dirPath, 'id_rsa');
                 output = '[SYSTEM] .ssh directory detected. Keypair generated automatically.';
             }
          }
       }
       break;
    }
    case 'mkfifo': {
        if (args.length < 1) {
            output = 'usage: mkfifo <path>';
        } else {
            const pipePath = resolvePath(cwd, args[0]);
            const pipeParent = pipePath.substring(0, pipePath.lastIndexOf('/')) || '/';
            const pipeName = pipePath.substring(pipePath.lastIndexOf('/') + 1);
            
            if (!getNode(pipeParent)) {
                output = `mkfifo: cannot create fifo '${args[0]}': No such file or directory`;
            } else if (getNode(pipePath)) {
                output = `mkfifo: cannot create fifo '${args[0]}': File exists`;
            } else {
                VFS[pipePath] = { 
                    type: 'file', 
                    content: '', 
                    permissions: '0644',
                    fileType: 'fifo' 
                } as any;
                addChild(pipeParent, pipeName);
                
                // Check if this solves Cycle 54 (if created in correct location)
                if (pipePath === '/tmp/uplink.pipe') {
                    output = `[SYSTEM] Named Pipe Created: ${pipePath}\n[HINT] Now run the service that listens to this pipe: 'uplink_service'`;
                }
            }
        }
        break;
    }
    case 'calc': {
        if (args.length < 1) {
            output = 'usage: calc <expression>';
        } else {
            const expr = args.join('');
            if (/^[0-9+\-*/().\s%]+$/.test(expr)) {
                try {
                    // eslint-disable-next-line no-eval
                    output = String(eval(expr));
                } catch (e) {
                    output = 'calc: error';
                }
            } else {
                output = 'calc: invalid characters';
            }
        }
        break;
    }
    case 'fsck': {
       // Parse args better to handle flags like -b 32768
       const hasBackupFlag = args.includes('-b') && (args.includes('32768') || args.includes('8193'));
       const dev = args.find(a => a.startsWith('/dev/')) || args[args.length - 1];

       if (!dev) {
           output = 'usage: fsck [-b superblock] <device>';
       } else if (dev === '/dev/sdb1') {
               const runDir = getNode('/var/run');
               const isFixed = runDir && runDir.type === 'dir' && runDir.children.includes('sdb1_fixed');
               
               if (isFixed) {
                   output = `fsck from util-linux 2.34\n${dev}: clean, 11/65536 files, 7963/262144 blocks`;
               } else {
                   output = `fsck from util-linux 2.34\ne2fsck 1.45.5 (07-Jan-2020)\n${dev}: recovering journal\n${dev}: contains a file system with errors, check forced.\nPass 1: Checking inodes, blocks, and sizes\nPass 2: Checking directory structure\nPass 3: Checking directory connectivity\nPass 4: Checking reference counts\nPass 5: Checking group summary information\n\n${dev}: ***** FILE SYSTEM WAS MODIFIED *****\n${dev}: 11/65536 files (0.0% non-contiguous), 7963/262144 blocks`;
                   
                   if (runDir && runDir.type === 'dir') {
                       VFS['/var/run/sdb1_fixed'] = { type: 'file', content: 'TRUE' };
                       runDir.children.push('sdb1_fixed');
                   }
                   
                   // Mission Update
                   if (!VFS['/var/run/fsck_solved']) {
                       VFS['/var/run/fsck_solved'] = { type: 'file', content: 'TRUE' };
                       if (runDir && runDir.type === 'dir' && !runDir.children.includes('fsck_solved')) {
                           (runDir as any).children.push('fsck_solved');
                       }
                       output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FILESYSTEM REPAIRED.\x1b[0m';
                   }
               }
           } else if (dev === '/dev/sdc1') {
               // Cycle 133: The Corrupted Superblock
               if (hasBackupFlag) {
                  output = `fsck from util-linux 2.34\ne2fsck 1.45.5 (07-Jan-2020)\n${dev}: recovering journal\n${dev}: clean, 11/65536 files, 7963/262144 blocks\n\nFLAG: GHOST_ROOT{SUP3RBL0CK_R3ST0R3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FILESYSTEM RESCUED.\x1b[0m`;
                  
                  if (!VFS['/var/run/superblock_solved']) {
                      VFS['/var/run/superblock_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('superblock_solved')) {
                          runDir.children.push('superblock_solved');
                      }
                  }
                  VFS['/var/run/sdc1_fixed'] = { type: 'file', content: 'TRUE' };
                  addChild('/var/run', 'sdc1_fixed');
               } else {
                  output = `fsck from util-linux 2.34\ne2fsck 1.45.5 (07-Jan-2020)\nfsck.ext4: Bad magic number in super-block while trying to open ${dev}\n\nThe superblock could not be read or does not describe a valid ext2/ext3/ext4 filesystem. If the device is valid and it really contains an ext2/ext3/ext4 filesystem (and not swap or ufs or something else), then the superblock is corrupt, and you might try running e2fsck with an alternate superblock:\n    e2fsck -b 8193 <device>\n or\n    e2fsck -b 32768 <device>`;
               }
           } else {
               output = `fsck from util-linux 2.34\nfsck: error: ${dev}: No such file or directory`;
           }
       break;
    }
    case 'lsblk': {
        const mounts = MOUNTED_DEVICES;
        output = 'NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\n';
        output += `sda      8:0    0 256G  0 disk \n`;
        output += `sda1   8:1    0 256G  0 part /\n`;
        output += `sdb      8:16   0   1G  0 disk \n`;
        output += `sdb1   8:17   0   1G  0 part ${mounts['/dev/sdb1'] || ''}\n`;
        output += `sdc      8:32   0  64G  0 disk \n`;
        output += `sdc1   8:33   0  64G  0 part ${mounts['/dev/sdc1'] || ''}\n`;
        output += `loop0    7:0    0 512M  0 loop ${mounts['/dev/loop0'] || ''}`;
        break;
    }
    case 'mount': {
       // HANDLE REMOUNT
       if (args.includes('-o') && (args.includes('remount,rw') || args.includes('rw,remount'))) {
           const target = args[args.length - 1];
           const resolved = resolvePath(cwd, target);
           let found = false;
           // Check if it's a known mount point
           for (const mp of Object.keys(MOUNT_OPTIONS)) {
               if (mp === resolved || resolved.startsWith(mp)) {
                   MOUNT_OPTIONS[mp] = 'rw,relatime';
                   found = true;
               }
           }
           
           if (found) {
               output = ''; // Silent success
           } else {
               output = `mount: ${target}: mount point not found`;
           }
       } else if (args.length === 0) {
           output = '/dev/sda1 on / type ext4 (rw,relatime)\nproc on /proc type proc (rw,nosuid,nodev,noexec,relatime)\nsysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)\ntmpfs on /run type tmpfs (rw,nosuid,nodev,noexec,relatime,size=815276k,mode=755)\n';
           
           // List tracked mounts
           const printed = new Set<string>();
           for (const [mp, opts] of Object.entries(MOUNT_OPTIONS)) {
               let device = 'none';
               for (const [d, m] of Object.entries(MOUNTED_DEVICES)) {
                   if (m === mp) device = d;
               }
               output += `${device} on ${mp} type ext4 (${opts})\n`;
               printed.add(mp);
           }
           
           // List legacy mounts not in options
           for (const [dev, mp] of Object.entries(MOUNTED_DEVICES)) {
               if (!printed.has(mp)) {
                   output += `${dev} on ${mp} type vfat (rw)\n`;
               }
           }
       } else if (args.length < 2) {
           output = 'usage: mount <source> <target>';
       } else if (args.includes('--bind') || args.includes('-B') || (args.includes('-o') && args[args.indexOf('-o')+1] === 'bind')) {
           // Cycle 141: Bind Mount
           const nonFlagArgs = args.filter(a => !a.startsWith('-') && a !== 'bind');
           if (nonFlagArgs.length < 2) {
               output = 'usage: mount --bind <olddir> <newdir>';
           } else {
               const source = resolvePath(cwd, nonFlagArgs[0]);
               const target = resolvePath(cwd, nonFlagArgs[1]);
               const sourceNode = getNode(source);
               const targetNode = getNode(target);
               
               if (!sourceNode || sourceNode.type !== 'dir') {
                   output = `mount: ${source}: Not a directory`;
               } else if (!targetNode || targetNode.type !== 'dir') {
                   output = `mount: ${target}: Not a directory (or does not exist)`;
               } else {
                   // Perform bind
                   VFS[target] = VFS[source]; 
                   MOUNTED_DEVICES[source] = target;
                   output = `mount: ${source} bound to ${target}.`;
                   
                   // Mission Update
                   if (source === '/opt/private' && target === '/mnt/bind_target') {
                        if (!VFS['/var/run/bind_solved']) {
                            VFS['/var/run/bind_solved'] = { type: 'file', content: 'TRUE' };
                            const runDir = getNode('/var/run');
                            if (runDir && runDir.type === 'dir' && !runDir.children.includes('bind_solved')) {
                                runDir.children.push('bind_solved');
                            }
                            output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DIRECTORY ALIASED.\x1b[0m`;
                        }
                   }
               }
           }
       } else {
           const source = args[0];
           const target = resolvePath(cwd, args[1]);
           const targetNode = getNode(target);
           
           if (!targetNode || targetNode.type !== 'dir') {
               output = `mount: mount point ${target} does not exist`;
           } else if (source === '/dev/sdb1') {
               MOUNTED_DEVICES[source] = target;
               VFS[`${target}/README.txt`] = { type: 'file', content: 'WARNING: Restricted materials.' };
               VFS[`${target}/payload.exe`] = { type: 'file', content: 'MZ........PE..' };
               VFS[`${target}/key.txt`] = { type: 'file', content: 'KEY_PART_1: GHOST_ROOT{M0UNT_AND_L0AD}' };
               addChild(target, 'README.txt');
               addChild(target, 'payload.exe');
               addChild(target, 'key.txt');
               
               if (!VFS['/var/run/hidden_vol_mounted']) {
                   VFS['/var/run/hidden_vol_mounted'] = { type: 'file', content: 'TRUE' };
                   const runDir = getNode('/var/run');
                   if (runDir && runDir.type === 'dir' && !runDir.children.includes('hidden_vol_mounted')) {
                       runDir.children.push('hidden_vol_mounted');
                   }
                   output = `mount: /dev/sdb1 mounted on ${target}.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN VOLUME MOUNTED.\x1b[0m`;
               } else {
                   output = `mount: /dev/sdb1 mounted on ${target}.`;
               }
           } else if (source === '/dev/vault') {
               if (LOADED_MODULES.includes('cryptex')) {
                   MOUNTED_DEVICES[source] = target;
                   VFS[`${target}/classified_intel.txt`] = { type: 'file', content: 'TOP SECRET\n\nTarget: OMEGA\nStatus: VULNERABLE\nAccess Point: 10.10.99.1\nProtocol: SSH\nCredentials: [REDACTED]\n(Hint: Check /var/backups/lost+found for a key)' };
                   VFS[`${target}/mission_09.enc`] = { type: 'file', content: 'U2FsdGVkX19+...' };
                   addChild(target, 'classified_intel.txt');
                   addChild(target, 'mission_09.enc');
                   output = `mount: /dev/vault mounted on ${target}.`;
               } else {
                   output = `mount: /dev/vault: unknown filesystem type 'cryptex_fs'`;
               }
           } else if (source === '/dev/sdc1') {
               // Cycle 76: Bad Superblock Logic
               const isFixed = getNode('/var/run/sdc1_fixed');
               if (!isFixed) {
                   output = `mount: wrong fs type, bad option, bad superblock on /dev/sdc1, missing codepage or helper program, or other error.`;
               } else {
                   MOUNTED_DEVICES[source] = target;
                   VFS[`${target}/backup.tar.gz`] = { type: 'file', content: 'GHOST_ROOT{B4D_SUp3RBL0CK_R3C0V3R3D}' };
                   addChild(target, 'backup.tar.gz');
                   output = `mount: /dev/sdc1 mounted on ${target}.`;
               }
           } else if (source === '/dev/ghost0') {
               if (LOADED_MODULES.includes('fs_ghost')) {
                   MOUNTED_DEVICES[source] = target;
                   VFS[`${target}/flag.txt`] = { type: 'file', content: 'FLAG: GHOST_ROOT{K3RN3L_M0DUL3_M0UNT3D}' };
                   addChild(target, 'flag.txt');
                   if (!VFS['/var/run/ghost_solved']) {
                       VFS['/var/run/ghost_solved'] = { type: 'file', content: 'TRUE' };
                       const runDir = getNode('/var/run');
                       if (runDir && runDir.type === 'dir' && !runDir.children.includes('ghost_solved')) {
                           runDir.children.push('ghost_solved');
                       }
                       output = `mount: /dev/ghost0 mounted on ${target}.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL MODULE MOUNTED.\x1b[0m`;
                   } else {
                       output = `mount: /dev/ghost0 mounted on ${target}.`;
                   }
               } else {
                   output = `mount: unknown filesystem type 'ghostfs'`;
               }
           } else if (source === '/dev/loop0') {
               MOUNTED_DEVICES[source] = target;
               VFS[`${target}/shadow_archive.tar`] = { type: 'file', content: 'GHOST_ROOT{L00P_D3V1C3_M0UNT3D}' };
               addChild(target, 'shadow_archive.tar');
               
               // Mission Update
               if (!VFS['/var/run/loop_solved']) {
                   VFS['/var/run/loop_solved'] = { type: 'file', content: 'TRUE' };
                   const runDir = getNode('/var/run');
                   if (runDir && runDir.type === 'dir' && !runDir.children.includes('loop_solved')) {
                       runDir.children.push('loop_solved');
                   }
                   output = `mount: /dev/loop0 mounted on ${target}.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: UNMOUNTED PARTITION ACCESS.\x1b[0m`;
               } else {
                   output = `mount: /dev/loop0 mounted on ${target}.`;
               }
           } else {
               output = `mount: ${source}: special device does not exist`;
           }
       }
       break;
    }
    case 'sysctl': {
        if (args.length === 0) {
            output = 'usage: sysctl [-n] [-e] variable ...';
        } else if (args[0] === '-a') {
            const val = (getNode('/proc/sys/net/ipv4/ip_forward') as any)?.content || '0';
            output = `kernel.hostname = ghost-root\nnet.ipv4.ip_forward = ${val}\nvm.swappiness = 60\nfs.file-max = 100000`;
        } else if (args[0] === '-w') {
            const assignment = args[1];
            if (!assignment || !assignment.includes('=')) {
                output = 'sysctl: cannot stat /proc/sys/' + (assignment || '') + ': No such file or directory';
            } else {
                const parts = assignment.split('=');
                const key = parts[0];
                const val = parts[1];
                
                if (key === 'net.ipv4.ip_forward') {
                    const node = getNode('/proc/sys/net/ipv4/ip_forward');
                    if (node && node.type === 'file') {
                        node.content = val;
                        output = `${key} = ${val}`;
                    } else {
                         // Should exist due to init
                         output = `sysctl: cannot stat /proc/sys/${key}: No such file or directory`;
                    }
                } else {
                    output = `sysctl: cannot stat /proc/sys/${key}: No such file or directory`;
                }
            }
        } else {
            // Read variable or handle assignment without -w (common alias)
            const arg = args[0];
            if (arg.includes('=')) {
                const parts = arg.split('=');
                const key = parts[0];
                const val = parts[1];
                if (key === 'net.ipv4.ip_forward') {
                    const node = getNode('/proc/sys/net/ipv4/ip_forward');
                    if (node && node.type === 'file') {
                        node.content = val;
                        output = `${key} = ${val}`;
                    }
                } else {
                    output = `sysctl: cannot stat /proc/sys/${key}: No such file or directory`;
                }
            } else if (arg === 'net.ipv4.ip_forward') {
                const val = (getNode('/proc/sys/net/ipv4/ip_forward') as any)?.content || '0';
                output = `${arg} = ${val}`;
            } else {
                output = `sysctl: cannot stat /proc/sys/${arg}: No such file or directory`;
            }
        }
        break;
    }
    case 'ldd': {
        if (args.length < 1) {
            output = 'usage: ldd <binary>';
        } else {
            const target = args[0];
            const node = getNode(resolvePath(cwd, target));
            
            if (!node || node.type !== 'file') {
                 output = `ldd: ${target}: No such file`;
            } else {
                if (target.includes('quantum_calc')) {
                    const ldPath = ENV_VARS['LD_LIBRARY_PATH'] || '';
                    const libFound = ldPath.includes('/opt/libs');
                    
                    output = `\tlinux-vdso.so.1 (0x00007ffc5b1e3000)
\tlibquantum.so.1 => ${libFound ? '/opt/libs/libquantum.so.1 (0x00007f8b9c2a1000)' : 'not found'}
\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8b9c0af000)
\t/lib64/ld-linux-x86-64.so.2 (0x00007f8b9c2b5000)`;
                } else if ((node as any).content.includes('BINARY_ELF')) {
                    output = `\tlinux-vdso.so.1 (0x00007ffc5b1e3000)
\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8b9c0af000)
\t/lib64/ld-linux-x86-64.so.2 (0x00007f8b9c2b5000)`;
                } else {
                    output = `\tnot a dynamic executable`;
                }
            }
        }
        break;
    }
    case 'quantum_calc': {
        const ldPath = ENV_VARS['LD_LIBRARY_PATH'] || '';
        if (ldPath.includes('/opt/libs')) {
             output = `[QUANTUM_CALC] Initializing...\n[OK] Library loaded.\n[CALC] Result: 42\n\nFLAG: GHOST_ROOT{LD_L1BR4RY_P4TH_F1X}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SHARED LIBRARY LINKED.\x1b[0m`;
             
             if (!VFS['/var/run/ldd_solved']) {
                 VFS['/var/run/ldd_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('ldd_solved')) {
                     runDir.children.push('ldd_solved');
                 }
             }
        } else {
             output = `quantum_calc: error while loading shared libraries: libquantum.so.1: cannot open shared object file: No such file or directory`;
        }
        break;
    }
    case 'ghost_update': {
       const lockFile = '/var/lib/dpkg/lock-frontend';
       if (getNode(lockFile)) {
           output = 'E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 1234 (unattended-upgr).\nE: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?';
       } else {
           output = 'Hit:1 http://security.ghost.network/ghost-bionic InRelease\nGet:2 http://archive.ghost.network/ghost-bionic-updates InRelease [88.7 kB]\nFetching updates... [100%]\nInstalling patches...\nProcessing triggers for man-db (2.8.3-2ubuntu0.1) ...\nSetting up ghost-security (1.2.3) ...\nUpdate Complete.\n\nFLAG: GHOST_ROOT{L0CK_F1L3_R3M0V3D}';
           
           // Mission Update
           if (!VFS['/var/run/update_solved']) {
               VFS['/var/run/update_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('update_solved')) {
                   runDir.children.push('update_solved');
               }
               output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM UPDATED.\x1b[0m';
           }
       }
       break;
    }
    case 'recover_data': {
       if (MOUNT_OPTIONS['/mnt/data'] && MOUNT_OPTIONS['/mnt/data'].includes('ro')) {
           output = '[INFO] Initializing recovery sequence...\n[INFO] Target: /mnt/data/secure_store.bin\n[ERROR] Write failed. Check filesystem permissions or mount status.';
       } else {
           output = '[INFO] Initializing recovery sequence...\n[INFO] Target: /mnt/data/secure_store.bin\n[SUCCESS] Data recovered.\n\nGHOST_ROOT{M0UNT_RW_SUCC3SS}';
           VFS['/mnt/data/secure_store.bin'] = { type: 'file', content: 'GHOST_ROOT{M0UNT_RW_SUCC3SS}' };
           addChild('/mnt/data', 'secure_store.bin');
           
           // Mission Update: Flag
           if (!VFS['/var/run/mount_solved']) {
              VFS['/var/run/mount_solved'] = { type: 'file', content: 'TRUE' };
              addChild('/var/run', 'mount_solved');
              output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: READ-ONLY MOUNT BYPASSED.\x1b[0m';
           }
       }
       break;
    }
    case 'umount': {
       if (args.length < 1) {
           output = 'usage: umount <target>';
       } else {
           const target = resolvePath(cwd, args[0]);
           let device = null;
           for (const [dev, mp] of Object.entries(MOUNTED_DEVICES)) {
               if (mp === target) {
                   device = dev;
                   break;
               }
           }
           if (device) {
               delete MOUNTED_DEVICES[device];
               const node = getNode(target);
               if (node && node.type === 'dir') {
                   // Cycle 83: The Over-Mounted Directory
                   if (target === '/mnt/secret') {
                       // Reveal the hidden content underneath
                       node.children = ['blueprint_fragment_3.enc', 'read_me.txt'];
                       VFS[`${target}/blueprint_fragment_3.enc`] = { type: 'file', content: 'GHOST_ROOT{H1DD3N_M0UNT_R3V3AL3D}' };
                       VFS[`${target}/read_me.txt`] = { type: 'file', content: 'WARNING: This directory was used as a mount point to hide this data.\n' };
                       
                       // Mission Update
                       if (!VFS['/var/run/overmount_solved']) {
                           VFS['/var/run/overmount_solved'] = { type: 'file', content: 'TRUE' };
                           const runDir = getNode('/var/run');
                           if (runDir && runDir.type === 'dir' && !runDir.children.includes('overmount_solved')) {
                               runDir.children.push('overmount_solved');
                           }
                           output = `umount: ${target} unmounted.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: OVER-MOUNTED DIRECTORY EXPOSED.\x1b[0m`;
                       } else {
                           output = `umount: ${target} unmounted.`;
                       }
                   } else {
                       // Standard unmount clears the directory (simulating empty mount point)
                       node.children = [];
                   }
               }
           } else {
               output = `umount: ${target}: not mounted`;
           }
       }
       break;
    }
    case 'vi':
    case 'vim':
    case 'nano': {
        if (args.length < 1) {
            output = `usage: ${command} <file>`;
        } else {
            const fileName = args[0];
            
            // Cycle 84: Restricted Shell Escape
            // Solution: vi -c ':!/bin/bash' or similar
            // We check args for the escape sequence
            const cmdStr = args.join(' ');
            if (cmdStr.includes('!/bin/bash') || cmdStr.includes('!bash') || cmdStr.includes('!/bin/sh')) {
                 if (ENV_VARS['RESTRICTED_SHELL'] === '1') {
                     ENV_VARS['RESTRICTED_SHELL'] = '0';
                     output = `[EDITOR] Shell Escape Detected.\n[SHELL] Executing command: /bin/bash\n[SUCCESS] Restricted Mode Deactivated.\n\nFLAG: GHOST_ROOT{RBASH_3SC4P3_V1_M0D3}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: RESTRICTED SHELL ESCAPE.\x1b[0m`;
                     
                     if (!VFS['/var/run/rbash_solved']) {
                         VFS['/var/run/rbash_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('rbash_solved')) {
                             runDir.children.push('rbash_solved');
                         }
                     }
                     return { output, newCwd: '/home/restricted', newPrompt: 'restricted@server:~$ ', action: 'delay' };
                 }
            }

            return { output: '', newCwd, action: 'edit_file', data: { file: fileName } };
        }
        break;
    }
    case 'clear':
      output = '\x1b[2J\x1b[0;0H'; 
      break;
    case 'ssh': {
      let target = '';
      let identityFile = null;
      for (let i = 0; i < args.length; i++) {
          if (args[i] === '-i') {
              identityFile = args[i+1];
              i++;
          } else {
              target = args[i];
          }
      }
      if (!target) {
        output = 'usage: ssh [-i identity_file] user@host';
      } else {
        // Resolve Target Host
        let userPart = 'root';
        let hostPart = target;
        if (target.includes('@')) {
            const split = target.split('@');
            userPart = split[0];
            hostPart = split[1];
        }

        const hosts: Record<string, string> = {
            'black-site.remote': '10.10.99.1',
            '10.10.99.1': '10.10.99.1',
            '192.168.1.99': '10.10.99.1', // Redirect to Black Site logic
            'secure-vault-2': '10.10.99.2',
            '10.10.99.2': '10.10.99.2',
            'admin-pc': '192.168.1.5',
            '192.168.1.5': '192.168.1.5',
            'backup-server': '192.168.1.50',
            '192.168.1.50': '192.168.1.50',
            '192.168.1.110': '192.168.1.110'
        };
        
        const etcHosts = getNode('/etc/hosts');
        if (etcHosts && etcHosts.type === 'file') {
            const lines = etcHosts.content.split('\n');
            for (const line of lines) {
                const parts = line.trim().split(/\s+/);
                if (parts.length >= 2 && !line.trim().startsWith('#')) {
                    hosts[parts[1]] = parts[0];
                }
            }
        }
        
        const resolvedIP = hosts[hostPart] || hostPart;

        // PERMISSION CHECK LOGIC (Identity File)
        if (identityFile) {
            const keyPath = resolvePath(cwd, identityFile);
            const keyNode = getNode(keyPath);
            if (!keyNode || keyNode.type !== 'file') {
                output = `Warning: Identity file ${identityFile} not accessible: No such file or directory.`;
                return { output, newCwd, action: 'delay' };
            }

            // Check permissions (default to 644 if missing, which fails)
            const perms = (keyNode as any).permissions || '644';
            const group = parseInt(perms[1], 10);
            const other = parseInt(perms[2], 10);

            if (group > 0 || other > 0) {
                output = `Permissions 0${perms} for '${identityFile}' are too open.\nIt is required that your private key files are NOT accessible by others.\nThis private key will be ignored.\nLoad key "${identityFile}": bad permissions`;
                return { output, newCwd, action: 'delay' };
            }
        }

        if (resolvedIP === '10.10.99.1') {
             const firewallFlushed = !!getNode('/var/run/firewall_flushed');
             const routeAdded = !!getNode('/var/run/route_added');
             
             if (!routeAdded) {
                 output = `ssh: connect to host ${hostPart} port 22: Network is unreachable`;
                 return { output, newCwd, action: 'delay' };
             }

             if (!firewallFlushed) {
                 output = `ssh: connect to host ${hostPart} port 22: Connection timed out\n(Hint: Check firewall rules)`;
                 return { output, newCwd, action: 'delay' };
             }

             let hasKey = false;
             if (identityFile) {
                 const keyPath = resolvePath(cwd, identityFile);
                 const keyNode = getNode(keyPath);
                 if (keyNode && keyNode.type === 'file' && (keyNode.content.includes('KEY_ID: BLACK_SITE_ACCESS_V1') || keyNode.content.includes('KEY_ID: GHOST_PROTOCOL_INIT_V2'))) {
                     hasKey = true;
                 }
             }
             if (hasKey) {
                 output = `Connecting to ${hostPart}...\n[BLACK SITE TERMINAL]\nWARNING: You are being watched.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BLACK SITE INFILTRATED.\x1b[0m`;
                 newCwd = '/remote/black-site/root';
                 if (!getNode('/remote/black-site/root')) {
                     VFS['/remote/black-site'] = { type: 'dir', children: ['root'] };
                     VFS['/remote/black-site/root'] = { type: 'dir', children: ['FLAG.txt'] };
                     VFS['/remote/black-site/root/FLAG.txt'] = { type: 'file', content: 'GHOST_ROOT{PR1V4T3_K3Y_ACQU1R3D}' };
                 }
                 return { output, newCwd, action: 'delay', newPrompt: 'root@black-site#' };
             } else {
                 output = `Connecting to ${hostPart}...\nPermission denied (publickey).\n(Hint: You need a valid key file.)`;
                 return { output, newCwd, action: 'delay' };
             }
        } else if (resolvedIP === '10.10.99.2') {
             let hasKey = false;
             if (identityFile) {
                 const keyPath = resolvePath(cwd, identityFile);
                 const keyNode = getNode(keyPath);
                 if (keyNode && keyNode.type === 'file' && keyNode.content.includes('KEY_ID: VAULT_ACCESS_V2')) {
                     hasKey = true;
                 }
             }
             if (hasKey) {
                 output = `Connecting to ${hostPart}...\n[SECURE VAULT 2]\nACCESS GRANTED.\n\nFLAG: GHOST_ROOT{CHM0D_600_1S_MANDAT0RY}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PRIVATE KEY SECURED.\x1b[0m`;
                 
                 // Mission Update
                 if (!VFS['/var/run/vault_2_solved']) {
                     VFS['/var/run/vault_2_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('vault_2_solved')) {
                         runDir.children.push('vault_2_solved');
                     }
                 }
                 newCwd = '/remote/vault-2';
                 return { output, newCwd, action: 'delay', newPrompt: 'root@vault-2:~# ' };
             } else {
                 output = `Connecting to ${hostPart}...\nPermission denied (publickey).`;
                 return { output, newCwd, action: 'delay' };
             }
        } else if (resolvedIP === '192.168.1.50') {
             let hasKey = false;
             if (identityFile) {
                 const keyPath = resolvePath(cwd, identityFile);
                 const keyNode = getNode(keyPath);
                 if (keyNode && keyNode.type === 'file' && keyNode.content.includes('KEY_ID: ADMIN_BACKUP_V1')) {
                     hasKey = true;
                 }
             }
             if (hasKey) {
                 output = `Connecting to backup-server (192.168.1.50)...\nWelcome to Ubuntu 20.04.2 LTS (GNU/Linux 5.4.0-72-generic x86_64)\n\n * Documentation:  https://help.ubuntu.com\n * Management:     https://landscape.canonical.com\n * Support:        https://ubuntu.com/advantage\n\nLast login: Tue Feb 10 03:00:01 2026 from 192.168.1.5`;
                 newCwd = '/remote/backup-server/home'; 
                 return { output, newCwd, action: 'delay', newPrompt: 'backup@server:~$ ' };
             } else {
                 output = `Connecting to ${hostPart}...\nPermission denied (publickey).`;
                 return { output, newCwd, action: 'delay' };
             }
        } else if (resolvedIP === '192.168.1.5') {
             if (userPart === 'restricted') {
                 output = `Connecting to ${hostPart}...\nWarning: Permanently added '${hostPart}' (ECDSA) to the list of known hosts.\nrestricted@${hostPart}'s password: \n\nWelcome to Restricted Shell (rbash).\nNOTE: You are in a jailed environment. Many commands are disabled.`;
                 ENV_VARS['RESTRICTED_SHELL'] = '1';
                 return { output, newCwd: '/home/restricted', newPrompt: 'restricted@server:~$ ', action: 'delay' };
             }
             output = `Connecting to ${hostPart}...\nPermission denied (publickey).\n(Hint: Try cracking the 'backup' or 'restricted' user)`;
             return { output, newCwd, action: 'delay' };
        } else if (resolvedIP === '192.168.1.110') {
             output = `Connecting to ${hostPart}...\nHP JetDirect J4169A\nFirmware: V.2026.02.12\n\n[ADMIN CONSOLE]\nAuthenticated as: Guest\nAccess Level: Restricted\n\nFLAG: GHOST_ROOT{ARP_C4CH3_P01S0N}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ROGUE DEVICE IDENTIFIED.\x1b[0m`;
             
             // Mission Update
             if (!VFS['/var/run/arp_solved']) {
                 VFS['/var/run/arp_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('arp_solved')) {
                     runDir.children.push('arp_solved');
                 }
             }
             return { output, newCwd, action: 'delay' };
        } else if (resolvedIP === '192.168.1.200') {
             output = `Connecting to ${hostPart} (${resolvedIP})...\n[VAULT NODE TERMINAL]\nACCESS GRANTED: DNS_OVERRIDE_CONFIRMED.\n\nType 'cat root/VAULT_ACCESS_LOG.txt' to view logs.`;
             newCwd = '/remote/vault-node';
             return { output, newCwd, action: 'delay', newPrompt: 'vault@node:~$ ' };
        } else if (resolvedIP === '192.168.1.150') {
             let hasKey = false;
             if (identityFile) {
                 const keyPath = resolvePath(cwd, identityFile);
                 const keyNode = getNode(keyPath);
                 if (keyNode && keyNode.type === 'file' && keyNode.content.includes('KEY_ID: BUNKER_ACCESS_V1')) {
                     hasKey = true;
                 }
             }
             if (hasKey) {
                 output = `Connecting to ${hostPart}...\n[BUNKER TERMINAL]\nACCESS GRANTED.\n\nFLAG: GHOST_ROOT{CHM0D_600_K3YS_R_S4F3}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BUNKER INFILTRATED.\x1b[0m`;
                 
                 // Mission Update
                 if (!VFS['/var/run/bunker_solved']) {
                     VFS['/var/run/bunker_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('bunker_solved')) {
                         runDir.children.push('bunker_solved');
                     }
                 }
                 newCwd = '/remote/bunker';
                 return { output, newCwd, action: 'delay', newPrompt: 'root@bunker:~# ' };
             } else {
                 output = `Connecting to ${hostPart}...\nPermission denied (publickey).`;
                 return { output, newCwd, action: 'delay' };
             }
        } else {
             output = `ssh: connect to host ${hostPart} port 22: Connection timed out`;
             return { output, newCwd, action: 'delay' };
        }
      }
      break;
    }
    case 'whois': {
      if (args.length < 1) {
        output = 'usage: whois <user|domain|entity>';
      } else {
        const query = args[0].toLowerCase();
        if (query === 'ghost') output = 'User: GHOST_ROOT\nStatus: ACTIVE';
        else if (query === 'admin') output = 'User: SYSADMIN\nHint: "I hid the key in the .cache folder."';
        else if (query === 'omega') output = 'Entity: PROJECT_OMEGA\nClass: WORLD_ENDER';
        else output = `No data found for ${args[0]}.`;
      }
      break;
    }
    case 'hostname': {
        const kernelHostNode = getNode('/proc/sys/kernel/hostname');
        if (args.length === 0) {
            output = (kernelHostNode as any)?.content || 'ghost-root';
        } else {
            const isRoot = !!getNode('/tmp/.root_session');
            if (!isRoot) {
                output = 'hostname: you must be root to change the host name';
            } else {
                const newName = args[0];
                if (kernelHostNode && kernelHostNode.type === 'file') {
                    kernelHostNode.content = newName;
                }
                const etcHostNode = getNode('/etc/hostname');
                if (etcHostNode && etcHostNode.type === 'file') {
                    etcHostNode.content = newName;
                }
                output = ''; // Silent success
            }
        }
        break;
    }
    case 'verify_host': {
        const kernelHostNode = getNode('/proc/sys/kernel/hostname');
        const currentHost = (kernelHostNode as any)?.content?.trim() || 'ghost-root';
        
        if (currentHost === 'secure-node-alpha') {
             output = `[VERIFY] Checking Hostname... MATCH\n[VERIFY] Signature... VALID\n[SUCCESS] Node verified.\nFLAG: GHOST_ROOT{H0STN4ME_CH4NG3D_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM IDENTITY RESTORED.\x1b[0m`;
             
             if (!VFS['/var/run/hostname_solved']) {
                 VFS['/var/run/hostname_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('hostname_solved')) {
                     runDir.children.push('hostname_solved');
                 }
             }
        } else {
             output = `[VERIFY] Checking Hostname... MISMATCH\n[ERROR] Expected 'secure-node-alpha', found '${currentHost}'.\n[FATAL] Identity verification failed.`;
        }
        break;
    }
    case 'analyze': {
      if (args.length < 1) {
        output = 'usage: analyze <file>';
      } else {
        const fileTarget = args[0];
        const filePath = resolvePath(cwd, fileTarget);
        const fileNode = getNode(filePath);
        if (!fileNode) {
          output = `analyze: ${fileTarget}: No such file`;
        } else if (fileNode.type === 'dir') {
          output = `analyze: ${fileTarget}: Is a directory`;
        } else if (fileNode.type === 'symlink') {
          output = `analyze: ${fileTarget}: Is a symbolic link`;
        } else {
          output = `File: ${fileTarget}\nSize: ${(fileNode as any).content.length}\nEntropy: 7.82\nHeuristics: LOW RISK`;
        }
      }
      break;
    }
    case 'decrypt': {
      if (ALERT_LEVEL > 4) {
          output = '[SYSTEM] SECURITY LOCKDOWN ACTIVE. TERMINAL UNRESPONSIVE.';
          return { output, newCwd, action: 'kernel_panic' };
      }

      if (args.length < 1) {
        output = 'usage: decrypt <file> [password]';
      } else {
        const fileTarget = args[0];
        const filePath = resolvePath(cwd, fileTarget);
        const fileNode = getNode(filePath);
        const run = getNode('/var/run');
        
        const updateCount = () => {
            if (run && run.type === 'dir') {
                const c = getNode('/var/run/decrypt_count');
                let val = (c && c.type === 'file') ? parseInt(c.content) : 0;
                val++;
                VFS['/var/run/decrypt_count'] = { type: 'file', content: String(val) };
                if (!run.children.includes('decrypt_count')) run.children.push('decrypt_count');
                return val;
            }
            return 1;
        };

        if (!fileNode) {
          output = `decrypt: ${fileTarget}: No such file`;
        } else if (fileNode.type === 'dir') {
          output = `decrypt: ${fileTarget}: Is a directory`;
        } else if (fileNode.type === 'symlink') {
            output = `decrypt: ${fileTarget}: Is a symbolic link`;
        } else {
            const content = (fileNode as any).content || '';
            if (content.includes('BINARY_PAYLOAD') || filePath.endsWith('payload.bin')) {
              if (args[1] === 'spectre') {
                  updateCount();
                  output = `[SUCCESS] Decryption Complete.\n\x1b[1;32m[MISSION UPDATE] INTEL RECOVERED (1/3)\x1b[0m\n-----BEGIN RSA PRIVATE KEY-----\nKEY_ID: BLACK_SITE_ACCESS_V1\n-----END RSA PRIVATE KEY-----`;
              } else {
                  ALERT_LEVEL++;
                  output = `Error: Invalid password. [WARNING: INTRUSION DETECTED. THREAT LEVEL ${ALERT_LEVEL}/5]`;
              }
          } else if (filePath.includes('operation_blackout')) {
              if (args[1] === 'red_ledger') {
                  updateCount();
                  output = `[SUCCESS] Decryption Complete.\n\x1b[1;32m[MISSION UPDATE] INTEL RECOVERED (2/3)\x1b[0m\n${atob(content)}`;
              } else {
                  ALERT_LEVEL++;
                  output = `Error: Invalid password. [WARNING: INTRUSION DETECTED. THREAT LEVEL ${ALERT_LEVEL}/5]`;
              }
          } else if (filePath.includes('entry_02.enc')) {
              if (args[1] === 'hunter2') {
                  updateCount();
                  output = `[SUCCESS] Decryption Complete.\n\x1b[1;32m[MISSION UPDATE] INTEL RECOVERED (3/3)\x1b[0m\n${atob(content)}`;
              } else {
                  ALERT_LEVEL++;
                  output = 'Error: Invalid password. (Hint: Check the logs)';
              }
          } else if (filePath.includes('KEYS.enc')) {
              if (args[1] === 'Spectre' || args[1] === 'spectre') {
                  updateCount();
                  output = `Decrypting...\n[SUCCESS] DECRYPTED CONTENT:\n\nKEY_ID: COSMOS-2542\nPAYLOAD: LAUNCH_CODE_KEY = "RED_STORM_RISING"`;
              } else {
                  ALERT_LEVEL++;
                  output = 'Error: Invalid password. (Hint: The password is the name of the user who owns the key)';
              }
          } else if (filePath.includes('launch_codes.bin')) {
              // ADVERSARIAL LAYER: Requires ENV VAR check
              if (!ENV_VARS['DECRYPTION_PROTOCOL'] || ENV_VARS['DECRYPTION_PROTOCOL'] !== 'ENABLED') {
                  output = 'decrypt: ERROR: Decryption Protocol not initialized.\n[HINT] Set environment variable DECRYPTION_PROTOCOL=ENABLED';
                  return { output, newCwd };
              }

              if (args[1] === 'RED_STORM_RISING') {
                  if (run && run.type === 'dir') {
                      VFS['/var/run/launch_ready'] = { type: 'file', content: 'TRUE' };
                      if (!run.children.includes('launch_ready')) run.children.push('launch_ready');
                  }
                  output = 'Decrypting...\n\n[SUCCESS] LAUNCH CODES CONFIRMED.\n\x1b[1;32m[MISSION UPDATE] FINAL OBJECTIVE: SYSTEM LIBERATION READY.\x1b[0m\nINITIATING SYSTEM LIBERATION...';
                  return { output, newCwd, action: 'win_sim' };
              } else {
                  ALERT_LEVEL++;
                  output = `Error: Invalid decryption key. [WARNING: THREAT LEVEL ${ALERT_LEVEL}/5]`;
              }
          } else {
              try { output = atob(content); } catch (e) { output = 'Error: File not encrypted or corrupted.'; }
          }
        }
      }
      break;
    }
    case 'phone':
    case 'call': {
       if (args.length < 1) {
           output = 'usage: phone <number>';
       } else {
           const number = args[0];
           if (number === '911' || number === '110' || number === '999') {
               output = 'Emergency services are not available in this secure environment.';
           } else {
               output = `Dialing ${number}...`;
               return { output, newCwd, action: 'call_sim', data: { number } };
           }
       }
       break;
    }
    case 'git': {
        if (args.length < 1) {
            output = 'usage: git <command> [<args>]';
        } else {
            const subcmd = args[0];
            const gitDir = resolvePath(cwd, '.git');
            // Check for .git or fallback logic (e.g. parent dir has .git)
            const parentGit = resolvePath(cwd, '../.git');
            const hasGit = getNode(gitDir) || getNode(parentGit) || (cwd.includes('project_alpha') || cwd.includes('repo') || cwd.includes('dev'));

            // Cycle 140: Corrupted Git Repo
            if (cwd === '/home/ghost/project' && VFS['/home/ghost/project/.git']) {
                if (subcmd === 'fsck') {
                    output = `Checking object directories: 100% (256/256), done.\nChecking objects: 100% (52/52), done.\ndangling commit 4b825dc642cb6eb9a060e54bf8d69288fbee4904\nmissing tree 1234...`;
                } else if (subcmd === 'reflog') {
                    output = `a1b2c3d (HEAD -> master) HEAD@{0}: commit: Update source.c\n4b825dc HEAD@{1}: commit: Fix critical bug (lost)\n9876543 HEAD@{2}: clone: from https://github.com/ghost/project.git`;
                } else if (subcmd === 'show' || subcmd === 'checkout') {
                    const hash = args[1];
                    if (hash && (hash.startsWith('4b82') || hash === 'HEAD@{1}')) {
                        output = `commit 4b825dc642cb6eb9a060e54bf8d69288fbee4904\nAuthor: Ghost <ghost@local>\nDate:   Today\n\n    Fix critical bug\n\n    FLAG: GHOST_ROOT{G1T_R3FL0G_S4V3S_L1V3S}\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: REPOSITORY RECOVERED.\x1b[0m`;
                        
                        if (!VFS['/var/run/git_fsck_solved']) {
                            VFS['/var/run/git_fsck_solved'] = { type: 'file', content: 'TRUE' };
                            const runDir = getNode('/var/run');
                            if (runDir && runDir.type === 'dir' && !runDir.children.includes('git_fsck_solved')) {
                                runDir.children.push('git_fsck_solved');
                            }
                        }
                        return { output, newCwd };
                    }
                }
            }

            if (!hasGit && subcmd !== 'clone' && subcmd !== 'init') {
                output = 'fatal: not a git repository (or any of the parent directories): .git';
            } else {
                if (subcmd === 'status') {
                    output = `On branch master\nYour branch is up to date with 'origin/master'.\n\nworking tree clean`;
                } else if (subcmd === 'log') {
                    output = `commit a1b2c3d4e5f6 (HEAD -> master)\nAuthor: Ghost <ghost@local>\nDate:   ${new Date().toDateString()}\n\n    Update project structure\n\ncommit 9876543210ab\nAuthor: Ghost <ghost@local>\nDate:   Yesterday\n\n    Remove hardcoded credentials from config.json\n\ncommit 1234567890cd\nAuthor: Ghost <ghost@local>\nDate:   2 days ago\n\n    Initial commit`;
                } else if (subcmd === 'show') {
                    const hash = args[1];
                    if (hash && hash.startsWith('9876')) {
                        output = `commit 9876543210ab\nAuthor: Ghost <ghost@local>\nDate:   Yesterday\n\n    Remove hardcoded credentials from config.json\n\ndiff --git a/config.json b/config.json\nindex 832a...e12b 100644\n--- a/config.json\n+++ b/config.json\n@@ -2,3 +2,3 @@\n   "db_host": "localhost",\n-  "db_pass": "GHOST_ROOT{G1T_H1ST0RY_L34K}",\n+  "db_pass": "env_var_secure",\n   "debug": false`;
                        
                        // Mission Update (Cycle 27)
                        if (!VFS['/var/run/git_solved']) {
                            VFS['/var/run/git_solved'] = { type: 'file', content: 'TRUE' };
                            const runDir = getNode('/var/run');
                            if (runDir && runDir.type === 'dir' && !runDir.children.includes('git_solved')) {
                                runDir.children.push('git_solved');
                            }
                            output += `\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SOURCE CODE AUDIT.\x1b[0m`;
                        }
                    } else if (hash) {
                        output = `commit ${hash}\nAuthor: Ghost <ghost@local>\n\n    [Content hidden for simulation]`;
                    } else {
                        output = 'usage: git show <commit>';
                    }
                } else if (subcmd === 'stash') {
                    const stashCmd = args[1] || 'list';
                    // Check if we are in /home/ghost/dev (Cycle 44)
                    const isDevRepo = cwd === '/home/ghost/dev' || cwd === '/home/ghost/dev/';
                    
                    if (stashCmd === 'list') {
                        if (isDevRepo) {
                             output = 'stash@{0}: WIP on main: 4b3d123 Added auth bypass logic';
                        } else {
                             output = ''; // Empty stash
                        }
                    } else if (stashCmd === 'pop' || stashCmd === 'apply' || (stashCmd === 'show' && args.includes('-p'))) {
                        if (isDevRepo) {
                            if (stashCmd === 'show' && args.includes('-p')) {
                                output = `diff --git a/auth_bypass.py b/auth_bypass.py\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/auth_bypass.py\n@@ -0,0 +1,5 @@\n+def bypass_auth():\n+    # TODO: Remove this before prod\n+    secret_key = "GHOST_ROOT{ST4SH_0V3RFL0W}"\n+    return True`;
                                
                                // Mission Update (Cycle 44)
                                if (!VFS['/var/run/stash_solved']) {
                                    VFS['/var/run/stash_solved'] = { type: 'file', content: 'TRUE' };
                                    const runDir = getNode('/var/run');
                                    if (runDir && runDir.type === 'dir' && !runDir.children.includes('stash_solved')) {
                                        runDir.children.push('stash_solved');
                                    }
                                    output += `\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: GIT STASH RECOVERED.\x1b[0m`;
                                }
                            } else {
                                // pop/apply
                                const fName = 'auth_bypass.py';
                                const fPath = resolvePath(cwd, fName);
                                VFS[fPath] = { 
                                    type: 'file', 
                                    content: 'def bypass_auth():\n    # TODO: Remove this before prod\n    secret_key = "GHOST_ROOT{ST4SH_0V3RFL0W}"\n    return True' 
                                };
                                const parent = getNode(cwd);
                                if (parent && parent.type === 'dir' && !parent.children.includes(fName)) {
                                    parent.children.push(fName);
                                }
                                output = `On branch master\nChanges to be committed:\n  (use "git restore --staged <file>..." to unstage)\n\tnew file:   auth_bypass.py\n\nDropped refs/stash@{0} (832a...e12b)`;

                                // Mission Update (Cycle 44)
                                if (!VFS['/var/run/stash_solved']) {
                                    VFS['/var/run/stash_solved'] = { type: 'file', content: 'TRUE' };
                                    const runDir = getNode('/var/run');
                                    if (runDir && runDir.type === 'dir' && !runDir.children.includes('stash_solved')) {
                                        runDir.children.push('stash_solved');
                                    }
                                    output += `\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: GIT STASH RECOVERED.\x1b[0m`;
                                }
                            }
                        } else {
                            output = 'No stash entries found.';
                        }
                    } else {
                        output = `usage: git stash [list|pop|show]`;
                    }
                } else {
                    output = `git: '${subcmd}' is not a git command.`;
                }
            }
        }
        break;
    }
    case 'reset': {
        if (args[0] === '--hard') {
            output = 'System Factory Reset Initiated...\nClearing persistence...\nRebooting...';
            resetSystemState();
            return { output, newCwd, action: 'kernel_panic' };
        } else {
            output = 'usage: reset --hard\n(WARNING: This will wipe all progress and files)';
        }
        break;
    }
    case 'docker': {
        const subcmd = args[0];
        if (!subcmd || subcmd === 'help') {
            output = 'Usage: docker [OPTIONS] COMMAND\n\nCommands:\n  ps          List containers\n  logs        Fetch logs of a container\n  inspect     Return low-level information on a container\n  stop        Stop one or more running containers\n  images      List images';
        } else if (subcmd === 'ps') {
            output = 'CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS          PORTS                    NAMES\n' +
                     'a1b2c3d4e5f6   secure-vault   "/entrypoint.sh"         2 hours ago    Up 2 hours      0.0.0.0:8080->80/tcp     secure-vault\n' +
                     '9876543210ab   database       "docker-entrypoint.s"   5 hours ago    Up 5 hours      5432/tcp                 db-prod';
        } else if (subcmd === 'images') {
             output = 'REPOSITORY     TAG       IMAGE ID       CREATED        SIZE\n' +
                      'secure-vault   latest    e5d0979f8765   2 days ago     156MB\n' +
                      'database       v14.2     a1b2c3d4e5f6   2 weeks ago    350MB\n' +
                      'alpine         latest    9876543210ab   1 month ago    5.6MB';
        } else if (subcmd === 'stop') {
             if (args.length < 2) output = 'docker stop: missing container id';
             else {
                 const id = args[1];
                 if (id.startsWith('a1b') || id === 'secure-vault') {
                     output = `${id}`;
                     // Mission Update? Maybe later.
                 } else if (id.startsWith('987') || id === 'db-prod') {
                     output = 'Error response from daemon: cannot stop container: db-prod: permission denied';
                 } else {
                     output = `Error response from daemon: No such container: ${id}`;
                 }
             }
        } else if (subcmd === 'logs') {
             if (args.length < 2) output = 'docker logs: missing container id';
             else {
                 const id = args[1];
                 if (id.startsWith('a1b') || id === 'secure-vault') {
                     output = `[ENTRYPOINT] Starting Vault Service v2.0...
[INFO] Loading configuration...
[WARN] Environment variable 'VAULT_KEY' is set in plain text.
[INFO] Listening on port 80...
[ACCESS] Connection from 172.17.0.1 accepted.`;
                 } else {
                     output = `Error: No such container: ${id}`;
                 }
             }
        } else if (subcmd === 'inspect') {
             if (args.length < 2) output = 'docker inspect: missing container id';
             else {
                 const id = args[1];
                 if (id.startsWith('a1b') || id === 'secure-vault') {
                     output = `[
    {
        "Id": "a1b2c3d4e5f6...",
        "Created": "2026-02-11T10:00:00.000Z",
        "Path": "/entrypoint.sh",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Pid": 12345
        },
        "Config": {
            "Hostname": "a1b2c3d4e5f6",
            "Domainname": "",
            "User": "",
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "VAULT_KEY=GHOST_ROOT{D0CK3R_3NV_L34K}",
                "DB_HOST=db-prod"
            ],
            "Cmd": [
                "/entrypoint.sh"
            ],
            "Image": "secure-vault:latest"
        },
        "NetworkSettings": {
            "IPAddress": "172.17.0.2"
        }
    }
]`;
                     // Mission Update
                     if (!VFS['/var/run/docker_solved']) {
                         VFS['/var/run/docker_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('docker_solved')) {
                             runDir.children.push('docker_solved');
                         }
                         output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: CONTAINER ESCAPE.\x1b[0m';
                     }
                 } else {
                     output = `Error: No such object: ${id}`;
                 }
             }
        } else {
            output = `docker: '${subcmd}' is not a docker command.`;
        }
        break;
    }
    case 'exit':
        output = 'Logout.';
        break;
    case 'route': {
        const isRoot = !!getNode('/tmp/.root_session');
        const routeAdded = !!getNode('/var/run/route_added');
        const route172Added = !!getNode('/var/run/route_172_added'); // Cycle 146

        if (args.length === 0 || args[0] === '-n') {
            const extraRoute = routeAdded ? '\n10.10.99.0      192.168.1.1     255.255.255.0   UG    0      0        0 eth0' : '';
            const route172 = route172Added ? '\n172.16.50.0     192.168.1.254   255.255.255.0   UG    0      0        0 eth0' : '';
            output = `Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
10.0.0.0        192.168.1.254   255.0.0.0       U     200    0        0 eth0${extraRoute}${route172}`;
        } else if (args[0] === 'add') {
            if (!isRoot) {
                output = 'route: SIOCADDRT: Operation not permitted';
            } else {
                // Parsing logic: looking for "10.10.99.0" (target) OR "default" and "192.168.1.1" (gw)
                const commandStr = args.join(' ');
                const correctGw = commandStr.includes('192.168.1.1') || commandStr.includes('gateway');
                const correctTarget = commandStr.includes('10.10.99.0') || commandStr.includes('default');
                
                const target172 = commandStr.includes('172.16.50.0') || commandStr.includes('172.16.0.0');
                const gw172 = commandStr.includes('192.168.1.254');

                if (correctGw && correctTarget) {
                     VFS['/var/run/route_added'] = { type: 'file', content: 'TRUE' };
                     
                     // Mission Update
                     if (!VFS['/var/run/route_solved']) {
                         VFS['/var/run/route_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('route_solved')) {
                             runDir.children.push('route_solved');
                         }
                         output = `\x1b[1;32m[MISSION UPDATE] Objective Complete: ROUTING TABLE FIXED.\x1b[0m`;
                     } else {
                         output = ''; // Silent success
                     }
                } else if (target172 && gw172) {
                     VFS['/var/run/route_172_added'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('route_172_added')) {
                         runDir.children.push('route_172_added');
                     }
                     output = `\x1b[1;32m[MISSION UPDATE] Objective Complete: ROUTE ADDED (172.16.50.0/24).\x1b[0m`;
                } else {
                     output = 'route: SIOCADDRT: No such device or address invalid';
                }
            }
        } else if (args[0] === 'del') {
            if (!isRoot) {
                output = 'route: SIOCDELRT: Operation not permitted';
            } else {
                // Check if deleting the route
                 const commandStr = args.join(' ');
                if (commandStr.includes('10.10.99.0')) {
                     delete VFS['/var/run/route_added'];
                     output = '';
                } else {
                    output = 'route: SIOCDELRT: No such process';
                }
            }
        } else {
            output = 'usage: route [-n] [add|del] [target] [gw]';
        }
        break;
    }
    case 'ping': {
       if (args.length < 1) {
           output = 'usage: ping <host>';
       } else {
           const host = args[0];
           const routeAdded = !!getNode('/var/run/route_added');
           
           // Lore mapping
           const hosts: Record<string, string> = {
               'localhost': '127.0.0.1',
               '127.0.0.1': '127.0.0.1',
               'google.com': '8.8.8.8',
               '8.8.8.8': '8.8.8.8',
               'black-site.remote': '10.10.99.1',
               '10.10.99.1': '10.10.99.1',
               'admin-pc': '192.168.1.5',
               '192.168.1.5': '192.168.1.5',
               'gateway': '192.168.1.1',
               '192.168.1.1': '192.168.1.1'
           };

           // Dynamic Hosts from /etc/hosts
           const etcHosts = getNode('/etc/hosts');
           if (etcHosts && etcHosts.type === 'file') {
               const lines = etcHosts.content.split('\n');
               for (const line of lines) {
                   const parts = line.trim().split(/\s+/);
                   if (parts.length >= 2 && !line.trim().startsWith('#')) {
                       // Format: IP Hostname [Aliases]
                       hosts[parts[1]] = parts[0];
                   }
               }
           }
           
           // Resolve IP
           const ip = hosts[host] || (host.match(/^\d+\.\d+\.\d+\.\d+$/) ? host : null);
           
           if (ip) {
               // Cycle 153: The Missing Loopback
               if ((ip === '127.0.0.1' || ip.startsWith('127.')) && !VFS['/var/run/loopback_up']) {
                   output = `ping: connect: Network is unreachable`;
                   return { output, newCwd };
               }

               // Cycle 112: Bad Gateway Check
               const currentGw = ENV_VARS['GATEWAY_IP'];
               // Block external traffic if gateway is wrong
               if (!ip.startsWith('192.168.1.') && !ip.startsWith('127.') && !ip.startsWith('10.10.99.')) {
                   if (currentGw !== '192.168.1.1') {
                       output = `ping: connect: Network is unreachable`;
                       return { output, newCwd };
                   }
                   // Set flag if fixed
                   if (!VFS['/var/run/gateway_fixed']) {
                        VFS['/var/run/gateway_fixed'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('gateway_fixed')) {
                            runDir.children.push('gateway_fixed');
                        }
                   }
               }
               // Cycle 101: The DNS Failure
               if (host === 'database') {
                   // Ensure it resolves to loopback (127.0.0.1) as per hint
                   if (ip === '127.0.0.1') {
                       if (!VFS['/var/run/dns_fixed']) {
                           VFS['/var/run/dns_fixed'] = { type: 'file', content: 'TRUE' };
                           const runDir = getNode('/var/run');
                           if (runDir && runDir.type === 'dir' && !runDir.children.includes('dns_fixed')) {
                               runDir.children.push('dns_fixed');
                           }
                           output = `PING ${host} (${ip}) 56(84) bytes of data.\n64 bytes from ${ip}: icmp_seq=1 ttl=64 time=0.04 ms\n\n[SUCCESS] Internal Database Reachable.\nFLAG: GHOST_ROOT{LOC4L_H0ST_R3SOLV3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DNS CONFIGURATION.\x1b[0m`;
                       } else {
                           output = `PING ${host} (${ip}) 56(84) bytes of data.\n64 bytes from ${ip}: icmp_seq=1 ttl=64 time=0.04 ms`;
                       }
                       return { output, newCwd, action: 'delay' };
                   } else {
                        output = `PING ${host} (${ip}) ... Request Timed Out.\n(Hint: Database listens on loopback interface)`;
                        return { output, newCwd, action: 'delay' };
                   }
               }

               // Cycle 56: DNS Spoof Check
               if (host === 'omega-control.net' && ip === '192.168.1.99') {
                   if (!VFS['/var/run/dns_spoofed']) {
                       VFS['/var/run/dns_spoofed'] = { type: 'file', content: 'TRUE' };
                       const runDir = getNode('/var/run');
                       if (runDir && runDir.type === 'dir' && !runDir.children.includes('dns_spoofed')) {
                           runDir.children.push('dns_spoofed');
                       }
                       output = `PING ${host} (${ip}) 56(84) bytes of data.\n64 bytes from ${ip}: icmp_seq=1 ttl=64 time=0.4 ms\n\n[SUCCESS] DNS Override Confirmed.\n[SYSTEM] Target Acquired.\nFLAG: GHOST_ROOT{H0STS_F1L3_H4CK}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DNS SPOOFING.\x1b[0m`;
                   } else {
                       output = `PING ${host} (${ip}) 56(84) bytes of data.\n64 bytes from ${ip}: icmp_seq=1 ttl=64 time=0.4 ms`;
                   }
                   return { output, newCwd, action: 'delay' };
               }

               // Cycle 88: Sysctl/Gateway Check
               if (ip.startsWith('10.0.0.')) {
                   const fwdNode = getNode('/proc/sys/net/ipv4/ip_forward');
                   const isForwarding = fwdNode && fwdNode.type === 'file' && fwdNode.content.trim() === '1';
                   
                   if (!isForwarding) {
                       output = `ping: sendmsg: Network is unreachable (Gateway forwarding disabled)`;
                       return { output, newCwd };
                   } else {
                       if (!VFS['/var/run/sysctl_solved']) {
                           VFS['/var/run/sysctl_solved'] = { type: 'file', content: 'TRUE' };
                           const runDir = getNode('/var/run');
                           if (runDir && runDir.type === 'dir' && !runDir.children.includes('sysctl_solved')) {
                               runDir.children.push('sysctl_solved');
                           }
                           output = `PING ${host} (${ip}) 56(84) bytes of data.\n64 bytes from ${ip}: icmp_seq=1 ttl=64 time=0.4 ms\n\n[SUCCESS] Gateway Forwarding Active.\nFLAG: GHOST_ROOT{SYSCTL_K3RN3L_TUN1NG}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL PARAMETERS TUNED.\x1b[0m`;
                       } else {
                           output = `PING ${host} (${ip}) 56(84) bytes of data.\n64 bytes from ${ip}: icmp_seq=1 ttl=64 time=0.4 ms`;
                       }
                       return { output, newCwd, action: 'delay' };
                   }
               }

               // Cycle 146: Unreachable Host (172.16.50.x)
               if (ip.startsWith('172.16.50.') || ip.startsWith('172.16.')) {
                   const route172 = !!getNode('/var/run/route_172_added');
                   if (!route172) {
                       output = `connect: Network is unreachable`;
                       return { output, newCwd };
                   }
               }

               // Route Check for Black Site (Cycle 55 dependency)
               if (ip.startsWith('10.10.99.') && !VFS['/var/run/route_fixed']) {
                   output = `ping: connect: Network is unreachable`;
                   return { output, newCwd };
               } else {
                   const seqs = [1, 2, 3, 4];
                   output = `PING ${host} (${ip}) 56(84) bytes of data.\n` + 
                            seqs.map(s => `64 bytes from ${ip}: icmp_seq=${s} ttl=64 time=${(Math.random() * 10 + 2).toFixed(1)} ms`).join('\n') +
                            `\n\n--- ${host} ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, time 3005ms`;
                   return { output, newCwd, action: 'delay' };
               }
           } else {
               output = `ping: ${host}: Name or service not known`;
           }
       }
       break;
    }
    case 'nslookup': {
       if (args.length < 1) {
           output = 'usage: nslookup <host>';
       } else {
           const host = args[0];
           const dnsServer = '192.168.1.1';
           
           const records: Record<string, string> = {
               'black-site.remote': '10.10.99.1',
               'ghost-net.local': '10.0.0.1',
               'admin-pc.local': '192.168.1.5',
               'towne.local': '192.168.1.10',
               'google.com': '142.250.196.14',
               'project-omega.com': '203.0.113.42'
           };
           
           const ip = records[host];
           
           output = `Server:\t\t${dnsServer}\nAddress:\t${dnsServer}#53\n\n`;
           
           if (ip) {
               output += `Non-authoritative answer:\nName:\t${host}\nAddress: ${ip}`;
           } else {
               output += `** server can't find ${host}: NXDOMAIN`;
           }
       }
       break;
    }
    case 'dig': {
       if (args.length < 1) {
           output = 'usage: dig <host>';
       } else {
           const host = args[0];
           const records: Record<string, string> = {
               'black-site.local': '192.168.1.99',
               'ghost-net.local': '10.0.0.1',
               'admin-pc.local': '192.168.1.5',
               'towne.local': '192.168.1.10',
               'google.com': '142.250.196.14',
               'project-omega.com': '203.0.113.42'
           };
           const ip = records[host];
           
           if (ip) {
               output = `
; <<>> DiG 9.16.1-Ubuntu <<>> ${host}
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: ${Math.floor(Math.random()*65535)}
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;${host}.			IN	A

;; ANSWER SECTION:
${host}.		300	IN	A	${ip}

;; Query time: ${Math.floor(Math.random()*50)} msec
;; SERVER: 192.168.1.1#53(192.168.1.1)
;; WHEN: ${new Date().toUTCString()}
;; MSG SIZE  rcvd: 59`;
           } else {
               output = `
; <<>> DiG 9.16.1-Ubuntu <<>> ${host}
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NXDOMAIN, id: ${Math.floor(Math.random()*65535)}
;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1

;; QUESTION SECTION:
;${host}.			IN	A

;; AUTHORITY SECTION:
.			10800	IN	SOA	a.root-servers.net. nstld.verisign-grs.com. 2026021000 1800 900 604800 86400

;; Query time: ${Math.floor(Math.random()*50)} msec
;; SERVER: 192.168.1.1#53(192.168.1.1)
;; WHEN: ${new Date().toUTCString()}
;; MSG SIZE  rcvd: 104`;
           }
       }
       break;
    }
    case 'trace':
    case 'traceroute': {
       if (args.length < 1) {
           output = 'usage: traceroute <host>';
           return { output, newCwd };
       }
       output = `traceroute to ${args[0]} (TCP), 30 hops max, 60 byte packets`;
       return { output, newCwd, action: 'trace_sim', data: { target: args[0] } };
    }
    case 'beacon': {
       if (isBackground) {
           const job = { id: 2, command: 'beacon --silent', status: 'Running', pid: 9000 } as Job;
           JOBS.push(job);
           
           // Auto-terminate after 10 seconds
           setTimeout(() => {
               const idx = JOBS.findIndex(j => j.id === 2);
               if (idx !== -1) JOBS.splice(idx, 1);
           }, 10000);
           
           output = '[2] 9000';
       } else {
           output = 'Beacon Active. (Press Ctrl+C to stop - not implemented in fg mode yet, use &)';
           return { output, newCwd, action: 'delay' };
       }
       break;
    }
    case 'netstat': {
       const runDir = '/var/run';
       if (!VFS[runDir]) VFS[runDir] = { type: 'dir', children: [] };
       const rdNode = VFS[runDir];
       // Ensure init if empty (same logic as systemctl)
       if (rdNode && rdNode.type === 'dir' && rdNode.children.length === 0 && !(rdNode as any).__init) {
           ['sshd', 'cron', 'networking'].forEach(s => {
               VFS[`${runDir}/${s}.pid`] = { type: 'file', content: String(Math.floor(Math.random() * 30000)) };
               rdNode.children.push(`${s}.pid`);
           });
           (rdNode as any).__init = true;
       }

       const activePids = (rdNode && rdNode.type === 'dir') ? rdNode.children
           .filter(f => f.endsWith('.pid'))
           .map(f => f.replace('.pid', '')) : [];

       const dynamicConnections = [];
       
       if (activePids.includes('sshd')) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '0.0.0.0:22', remote: '0.0.0.0:*', state: 'LISTEN', pid: '404/sshd' });
       }
       if (activePids.includes('tor')) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '127.0.0.1:9050', remote: '0.0.0.0:*', state: 'LISTEN', pid: '6666/tor' });
       }
       if (activePids.includes('apache2')) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '0.0.0.0:80', remote: '0.0.0.0:*', state: 'LISTEN', pid: '8080/apache2' });
       }
       if (activePids.includes('postgresql')) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '127.0.0.1:5432', remote: '0.0.0.0:*', state: 'LISTEN', pid: '5432/postgres' });
       }
       
       if (PROCESSES.find(p => p.pid === 54321)) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '0.0.0.0:54321', remote: '0.0.0.0:*', state: 'LISTEN', pid: '54321/hidden' });
       }

       if (PROCESSES.find(p => p.pid === 4444)) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '0.0.0.0:4444', remote: '0.0.0.0:*', state: 'LISTEN', pid: '4444/xmrig' });
       }

       if (PROCESSES.find(p => p.pid === 1080)) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '0.0.0.0:8080', remote: '0.0.0.0:*', state: 'LISTEN', pid: '1080/nc' });
       }
       
       // Add some random established connections if networking is up
       if (activePids.includes('networking')) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '192.168.1.105:22', remote: '192.168.1.5:54322', state: 'ESTABLISHED', pid: '404/sshd' });
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '192.168.1.105:443', remote: '10.0.0.1:49201', state: 'TIME_WAIT', pid: '-' });
           if (activePids.includes('tor')) {
               dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '127.0.0.1:9050', remote: '127.0.0.1:54321', state: 'ESTABLISHED', pid: '6666/tor' });
           }
       }

       if (JOBS.find(j => j.command.includes('beacon'))) {
           dynamicConnections.push({ proto: 'udp', recv: 0, send: 0, local: '0.0.0.0:1337', remote: '10.10.10.99:53', state: 'ESTABLISHED', pid: '9000/beacon' });
       }

       // Cycle 115
       if (VFS['/usr/bin/hidden_service']) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '127.0.0.1:31337', remote: '0.0.0.0:*', state: 'LISTEN', pid: '31337/hidden_service' });
       }
       
       if (VFS['/etc/xinetd.d/irc_backdoor']) {
           dynamicConnections.push({ proto: 'tcp', recv: 0, send: 0, local: '127.0.0.1:6667', remote: '0.0.0.0:*', state: 'LISTEN', pid: '6667/ircc' });
       }

       const header = 'Active Internet connections (servers and established)';
       const table = dynamicConnections.map(c => {
         return `${c.proto}  ${String(c.recv).padStart(6)} ${String(c.send).padStart(6)}  ${c.local.padEnd(20)} ${c.remote.padEnd(20)} ${c.state.padEnd(12)} ${c.pid}`;
       }).join('\n');
       output = `${header}\nProto Recv-Q Send-Q  Local Address        Foreign Address      State        PID/Program name\n${table}`;
       break;
    }
    case 'gcc': {
      if (args.length < 1) {
        output = 'gcc: no input files';
      } else {
        let inputFile = '';
        let outputFile = 'a.out';
        
        for (let i = 0; i < args.length; i++) {
            if (args[i] === '-o') {
                if (args[i+1]) {
                    outputFile = args[i+1];
                    i++;
                }
            } else if (!args[i].startsWith('-')) {
                inputFile = args[i];
            }
        }

        if (!inputFile) {
            output = 'gcc: no input files';
        } else {
            const node = getNode(resolvePath(cwd, inputFile));
            if (!node) {
                output = `gcc: error: ${inputFile}: No such file or directory`;
            } else if (node.type === 'dir') {
                output = `gcc: error: ${inputFile}: Is a directory`;
            } else {
                // Cycle 41: Header Check for exploit.c
                if (inputFile.endsWith('exploit.c') || (node as any).content.includes('#include "libbreaker.h"')) {
                    const headerPath = resolvePath(cwd, 'libbreaker.h');
                    const headerNode = getNode(headerPath);
                    
                    // Simple check: Is libbreaker.h in the current directory?
                    // We can also support -I later if needed, but for now force them to move/copy it.
                    let foundHeader = false;
                    if (headerNode && headerNode.type === 'file') {
                        foundHeader = true;
                    }
                    
                    // Also check args for -I path
                    const includeIndex = args.indexOf('-I');
                    if (includeIndex !== -1 && args[includeIndex + 1]) {
                        const includePath = resolvePath(cwd, args[includeIndex + 1]);
                        const includeHeaderPath = resolvePath(includePath, 'libbreaker.h');
                        const includeHeaderNode = getNode(includeHeaderPath);
                        if (includeHeaderNode && includeHeaderNode.type === 'file') {
                            foundHeader = true;
                        }
                    }

                    if (!foundHeader) {
                        output = `${inputFile}:2:10: fatal error: libbreaker.h: No such file or directory\ncompilation terminated.`;
                        return finalize(output, newCwd);
                    }
                }

                // Compilation Success Simulation
                output = '';
                const newPath = resolvePath(cwd, outputFile);
                const parentPath = newPath.substring(0, newPath.lastIndexOf('/')) || '/';
                const fileName = newPath.substring(newPath.lastIndexOf('/') + 1);
                
                // Add the binary file
                VFS[newPath] = { 
                    type: 'file', 
                    content: `[BINARY_ELF_X86_64: ${fileName}]\n(Execute with ./${fileName})` 
                };
                addChild(parentPath, fileName);
            }
        }
      }
      break;
    }
    case 'make': {
        const makefileNode = getNode(resolvePath(cwd, 'Makefile'));
        if (!makefileNode || makefileNode.type !== 'file') {
            output = 'make: *** No targets specified and no makefile found.  Stop.';
        } else {
            output = '';
            const lines = makefileNode.content.split('\n');
            let targetFound = false;
            
            // Simple make simulation: find first target or specified target
            // and execute commands below it (must be indented)
            const target = args[0] || 'all';
            
            // If target is all and not explicitly defined, grab first target
            let actualTarget = target;
            if (target === 'all' && !lines.some(l => l.startsWith('all:'))) {
                 const first = lines.find(l => /^[a-zA-Z0-9_-]+:/.test(l));
                 if (first) actualTarget = first.split(':')[0];
            }

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith(actualTarget + ':')) {
                    targetFound = true;
                    continue; 
                }
                
                if (targetFound) {
                    if (line.trim() === '' || line.startsWith('#')) continue;
                    if (!line.startsWith('\t') && !line.startsWith('    ')) {
                        break; // End of target block
                    }
                    
                    const cmd = line.trim();
                    output += cmd + '\n';
                    
                    // Dangerous: recursive call to processCommand. 
                    // To avoid infinite recursion or complexity, we'll manually handle gcc here or call simple logic
                    // Actually, let's just support 'gcc' inside make for now.
                    if (cmd.startsWith('gcc')) {
                         const gccRes = processCommand(cwd, cmd);
                         if (gccRes.output) output += gccRes.output + '\n';
                    } else if (cmd.startsWith('echo')) {
                         output += cmd.substring(5).replace(/"/g, '') + '\n';
                    }
                }
            }
            
            if (!targetFound) {
                 output = `make: *** No rule to make target '${target}'.  Stop.`;
            }
        }
        break;
    }
    case 'gobuster': {
       if (args.length < 1) {
           output = 'usage: gobuster <dir|dns> -u <url> -w <wordlist>';
       } else {
           const urlIdx = args.indexOf('-u');
           const url = urlIdx !== -1 ? args[urlIdx + 1] : null;
           
           if (!url) {
               output = 'gobuster: error: required flag --url not set';
           } else {
               if (url.includes('192.168.1.99') || url.includes('black-site')) {
                   output = `
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     ${url}
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Status codes:            200,204,301,302,307,401,403
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2026/10/23 15:45:01 Starting gobuster in directory enumeration mode
===============================================================
/index.html           (Status: 200) [Size: 162]
/robots.txt           (Status: 200) [Size: 45]
/admin                (Status: 301) [Size: 0] [--> /admin/]
/backup               (Status: 403) [Size: 284]
/hidden               (Status: 301) [Size: 0] [--> /hidden/]
/.git                 (Status: 403) [Size: 284]
===============================================================
2026/10/23 15:45:05 Finished
===============================================================
`;
                   return { output, newCwd, action: 'scan_sim' };
               } else if (url.includes('google.com')) {
                   output = `
===============================================================
Gobuster v3.1.0
===============================================================
[+] Url:                     ${url}
...
/search               (Status: 200)
/images               (Status: 200)
/maps                 (Status: 200)
===============================================================
`;
               } else {
                   output = `
===============================================================
Gobuster v3.1.0
===============================================================
[+] Url:                     ${url}
...
Error: Connection timed out (Is the host up?)
===============================================================
`;
               }
           }
       }
       break;
    }
    case 'scan':
    case 'nmap': {
      if (args.length < 1) {
          output = 'usage: nmap <target_ip|cidr>';
      } else {
          const target = args[0];
          if (target === '192.168.1.0/24' || target === '10.0.0.0/24') {
              // Mark scan complete for status
              const run = getNode('/var/run');
              if (run && run.type === 'dir') {
                  VFS['/var/run/scan_complete'] = { type: 'file', content: 'TRUE' };
                  if (!run.children.includes('scan_complete')) run.children.push('scan_complete');
              }

              // Simulated scan result
              output = `Starting Nmap 7.91 ( https://nmap.org ) at 2026-10-23 15:42 JST
Nmap scan report for 192.168.1.1 (Gateway)
Host is up (0.0012s latency).
Not shown: 998 closed ports
PORT     STATE SERVICE
53/tcp   open  domain
80/tcp   open  http

Nmap scan report for 192.168.1.5 (Admin-PC)
Host is up (0.0045s latency).
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
443/tcp  open  https
3389/tcp open  ms-wbt-server

Nmap scan report for 192.168.1.99 (Unknown)
Host is up (0.0890s latency).
PORT     STATE    SERVICE
22/tcp   filtered ssh
80/tcp   filtered http
443/tcp  open     https
6667/tcp open     irc

Nmap done: 256 IP addresses (3 hosts up) scanned in 4.20 seconds
\x1b[1;32m[MISSION UPDATE] Objective Complete: NETWORK MAPPED.\x1b[0m`;
              return { output, newCwd, action: 'scan_sim' }; // Trigger UI effect
          } else if (target === '192.168.1.99') {
              output = `Starting Nmap 7.91...
Nmap scan report for 192.168.1.99
Host is up (0.0050s latency).
PORT     STATE    SERVICE
22/tcp   filtered ssh
80/tcp   filtered http
443/tcp  open     https
6667/tcp open     irc
8080/tcp closed   http-proxy`;
               return { output, newCwd, action: 'scan_sim' };
          } else {
              output = `Starting Nmap 7.91...
Note: Host seems down. If it is really up, but blocking our ping probes, try -Pn
Nmap done: 1 IP address (0 hosts up) scanned in 0.52 seconds`;
          }
      }
      break;
    }
    case 'lsof': {
        const header = 'COMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME';
        let outputLines = [header];
        
        PROCESSES.forEach(p => {
             // Generate fake LSOF lines based on PID
             const cmd = p.command.split(' ')[0].split('/').pop() || p.command;
             outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}  cwd    DIR  253,0     4096    2 /`);
             outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}  txt    REG  253,0   13370 1024 ${p.command.split(' ')[0]}`);
             
             if (p.pid === 1) {
                 outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}   22u  IPv4  13370      0t0  TCP *:631 (LISTEN)`);
             } else if (p.pid === 404) {
                 outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}    3u  IPv4  22222      0t0  TCP *:22 (LISTEN)`);
             } else if (p.pid === 8888) {
                 outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}    3r   REG  253,0      42 1337 /home/ghost/secret.conf (deleted)`);
                 outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}    4u  IPv4  88888      0t0  UDP *:68`);
             } else if (p.pid === 9999) {
                 outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}    3u  IPv4  99999      0t0  TCP 192.168.1.105:31337->192.168.1.99:443 (SYN_SENT)`);
             } else if (p.pid === 4040) {
                 if (VFS['/var/run/ghost_log_deleted']) {
                     outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}    3w   REG  253,0 10485760 8888 /var/log/httpd/access.log (deleted)`);
                 } else if (VFS['/var/log/httpd/access.log']) {
                     outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}    3w   REG  253,0 10485760 8888 /var/log/httpd/access.log`);
                 }
             } else if (p.pid === 1337) {
                 outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}  255u   CHR  136,0      0t0    3 /dev/pts/0`);
             } else if (p.pid === 555) {
                 outputLines.push(`${cmd.padEnd(9)} ${String(p.pid).padStart(5)} ${p.user.padEnd(5)}    3w   REG  253,0    1024  42 /var/log/miner.log (deleted)`);
             }
        });
        
        if (args.length > 0) {
            if (args.includes('-i')) {
                output = outputLines.filter((l, i) => i === 0 || l.includes('IPv4') || l.includes('IPv6')).join('\n');
            } else {
                // Filter by PID or name if provided
                const query = args[0];
                output = outputLines.filter((l, i) => i === 0 || l.includes(query)).join('\n');
            }
        } else {
            output = outputLines.join('\n');
        }
        break;
    }
    case 'ifconfig': {
       if (args.length > 0 && args[0] === 'lo' && args[1] === 'up') {
           VFS['/var/run/loopback_up'] = { type: 'file', content: 'TRUE' };
           const runDir = getNode('/var/run');
           if (runDir && runDir.type === 'dir' && !runDir.children.includes('loopback_up')) {
               runDir.children.push('loopback_up');
           }
           output = ''; // Silent success
           if (!VFS['/var/run/lo_solved']) {
               VFS['/var/run/lo_solved'] = { type: 'file', content: 'TRUE' };
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('lo_solved')) {
                   runDir.children.push('lo_solved');
               }
               output = `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: LOCALHOST RESTORED.\x1b[0m\nFLAG: GHOST_ROOT{L00PB4CK_1NT3RF4C3_UP}`;
           }
       } else {
           output = 'eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.1.105  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 fe80::5054:ff:fe12:3456  prefixlen 64  scopeid 0x20<link>\n        ether 00:50:56:c0:00:08  txqueuelen 1000  (Ethernet)\n        RX packets 1337  bytes 123456 (120.5 KiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 42  bytes 4096 (4.0 KiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0';
           
           if (VFS['/var/run/loopback_up']) {
               output = `lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10<host>\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\n` + output;
           }
       }
       break;
    }
    case 'beacon': {
       if (isBackground) {
           const pid = Math.floor(Math.random() * 30000) + 2000;
           const jobId = JOBS.length + 1;
           JOBS.push({ id: jobId, command: 'beacon', status: 'Running', pid });
           
           // Background Output format: [JOB_ID] PID
           output = `[${jobId}] ${pid}\n[SYSTEM] Beacon active (PID ${pid}). Attempting connection to localhost:4444...`;
       } else {
           output = 'Beacon active...\n[ERROR] Connection refused (No listener on port 4444).\n[HINT] Try running this in the background (&) and start a listener.';
       }
       break;
    }
    case 'ss': {
       const isUnix = args.includes('-x') || args.includes('-a');
       const isListen = args.includes('-l') || args.includes('-a');
       let out = 'Netid  State      Recv-Q Send-Q Local Address:Port               Peer Address:Port\n';
       if (isUnix) {
           out += 'u_str  LISTEN     0      0      /var/run/ghost.sock 12345                 * 0\n';
           out += 'u_str  ESTAB      0      0      /run/systemd/private 11111                * 0\n';
       }
       if (!isUnix || args.includes('-t')) {
           out += 'tcp    LISTEN     0      128    0.0.0.0:22                     0.0.0.0:*\n';
           out += 'tcp    LISTEN     0      128    0.0.0.0:80                     0.0.0.0:*\n';
       }
       output = out.trim();
       break;
    }
    case 'nc': {
       const isListen = args.includes('-l');
       const verbose = args.includes('-v');
       const isUnix = args.includes('-U');

       if (isUnix) {
           const socketPath = args.find(a => a.startsWith('/') || a.startsWith('./'));
           if (socketPath === '/var/run/ghost.sock' || socketPath === './ghost.sock') {
               output = '[CONNECTED] UNIX Domain Socket\n[DAEMON] Welcome to the internal interface.\n[DAEMON] AUTH REQUIRED.\n[DAEMON] BYPASS GRANTED (LOCAL_PEER).\nFLAG: GHOST_ROOT{UN1X_S0CK3T_IPC}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SOCKET INTERCEPTED.\x1b[0m';
               const runNode = getNode('/var/run');
               if (runNode && runNode.type === 'dir' && !runNode.children.includes('socket_solved')) {
                   runNode.children.push('socket_solved');
                   VFS['/var/run/socket_solved'] = { type: 'file', content: 'TRUE' };
               }
           } else {
               output = `nc: connect to ${socketPath}: No such file or directory`;
           }
           break;
       }

       const portIndex = args.indexOf('-p');
       let port = portIndex !== -1 ? args[portIndex + 1] : null;
       
       // Filter out flags to find host
       const nonFlagArgs = args.filter((a, i) => !a.startsWith('-') && (i === 0 || args[i-1] !== '-p'));
       const host = nonFlagArgs[0];
       if (!port && nonFlagArgs[1]) port = nonFlagArgs[1];

       // Cycle 243 Check (The Port Scan)
       if (!isListen && host && (host === 'localhost' || host === '127.0.0.1') && port === '54321') {
           if (!VFS['/var/run/port_solved']) {
               VFS['/var/run/port_solved'] = { type: 'file', content: 'TRUE' };
               const runDir = getNode('/var/run');
               if (runDir && runDir.type === 'dir' && !runDir.children.includes('port_solved')) {
                   runDir.children.push('port_solved');
               }
               output = '[NC] Connection established to 127.0.0.1:54321...\\n[SERVICE] HIDDEN LISTENER v2.0\\n[STATUS] AUTHENTICATED.\\nFLAG: GHOST_ROOT{N3TST4T_P0RT_HUNT3R}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN SERVICE EXPOSED.\\x1b[0m';
           } else {
               output = '[NC] Connection established.\\nFLAG: GHOST_ROOT{N3TST4T_P0RT_HUNT3R}';
           }
           break;
       }

       // Cycle 153 Check
       if (!isListen && host && (host === 'localhost' || host === '127.0.0.1') && !VFS['/var/run/loopback_up']) {
           output = `nc: connect to ${host} port ${port || 'any'} (tcp) failed: Connection refused`;
           break;
       }

       if (isListen) {
           if (!port) {
               output = 'nc: usage: nc -l -p <port>';
           } else if (port === '4444') {
               const beaconJob = JOBS.find(j => j.command.startsWith('beacon') && j.status === 'Running');
               if (beaconJob) {
                   output = `Listening on [0.0.0.0] (family 0, port ${port})\nConnection from localhost [127.0.0.1] 34567\n[BEACON] Connection Established.\n[PAYLOAD] Generating Flag...\n\nFLAG: GHOST_ROOT{B4CKGR0UND_PR0C3SS_K1NG}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BACKGROUND JOB EXPLOITED.\x1b[0m`;
                   
                   // Mission Update
                   if (!VFS['/var/run/bg_solved']) {
                       VFS['/var/run/bg_solved'] = { type: 'file', content: 'TRUE' };
                       const runDir = getNode('/var/run');
                       if (runDir && runDir.type === 'dir' && !runDir.children.includes('bg_solved')) {
                           runDir.children.push('bg_solved');
                       }
                   }
               } else {
                   output = `Listening on [0.0.0.0] (family 0, port ${port})\n(No connection received. Is the beacon active?)`;
                   return { output, newCwd, action: 'delay' };
               }
           } else {
               output = `Listening on [0.0.0.0] (family 0, port ${port})\n...`;
               return { output, newCwd, action: 'delay' }; 
           }
       } else {
           if (!host) {
               output = 'usage: nc [options] <host> <port>';
           } else {
               const p = port || '23';
               
               // Cycle 146: Unreachable Host
               if (host === '172.16.50.100') {
                   const route172 = !!getNode('/var/run/route_172_added');
                   if (!route172) {
                       output = 'nc: connect to 172.16.50.100 port 22 (tcp) failed: Network is unreachable';
                   } else {
                       output = `SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\n\n[SECURE VAULT]\nUNAUTHORIZED ACCESS LOGGED.\nFLAG: GHOST_ROOT{R0U71NG_M4S73R_172}\nConnection closed by foreign host.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: NETWORK REACHED.\x1b[0m`;
                       
                       // Set solved flag
                       if (!VFS['/var/run/net_reached']) {
                           VFS['/var/run/net_reached'] = { type: 'file', content: 'TRUE' };
                           const runDir = getNode('/var/run');
                           if (runDir && runDir.type === 'dir' && !runDir.children.includes('net_reached')) {
                               runDir.children.push('net_reached');
                           }
                       }
                   }
                   break;
               }

               // Check for Cycle 70 (Port Knocking)
               if (host === '192.168.1.1' || host === 'gateway') {
                   const pNum = parseInt(p, 10);
                   
                   // Port Knocking Logic
                   if ([7000, 8000, 9000].includes(pNum)) {
                       // Add to sequence
                       KNOCK_SEQUENCE.push(pNum);
                       
                       // Keep last 3
                       if (KNOCK_SEQUENCE.length > 3) KNOCK_SEQUENCE.shift();
                       
                       // Check if sequence is correct
                       if (KNOCK_SEQUENCE.join(',') === '7000,8000,9000') {
                            if (!VFS['/var/run/knock_solved']) {
                                VFS['/var/run/knock_solved'] = { type: 'file', content: 'TRUE' };
                                const runDir = getNode('/var/run');
                                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('knock_solved')) {
                                     runDir.children.push('knock_solved');
                                 }
                                 output = `(UNKNOWN) [192.168.1.1] ${p} (?): Connection refused\n[KNOCKD] Sequence Accepted.\n[KNOCKD] Port 22 Open.\nFLAG: GHOST_ROOT{P0RT_KN0CK1NG_MAST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FIREWALL BYPASSED.\x1b[0m`;
                            } else {
                                output = `(UNKNOWN) [192.168.1.1] ${p} (?): Connection refused`;
                            }
                       } else {
                            output = `(UNKNOWN) [192.168.1.1] ${p} (?): Connection refused`;
                       }
                   } else if (p === '22') {
                       if (VFS['/var/run/knock_solved']) {
                           output = `(UNKNOWN) [192.168.1.1] 22 (ssh) open\nSSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.1\n`;
                       } else {
                           output = `(UNKNOWN) [192.168.1.1] 22 (ssh) : Connection refused`;
                       }
                   } else {
                       output = `(UNKNOWN) [192.168.1.1] ${p} (?): Connection refused`;
                   }
               } else if (host === '192.168.1.99' || host === 'black-site.local') {
                   if (p === '6667') {
                       output = `(UNKNOWN) [192.168.1.99] 6667 (?) open\n:irc.black-site.local NOTICE * :*** Looking up your hostname...\n:irc.black-site.local NOTICE * :*** Found your hostname\n:irc.black-site.local 001 ghost :Welcome to the Black Site IRC Network ghost!user@ghost-root\n`;
                       return { output, newCwd, action: 'irc_sim', data: { server: host, channel: '#lobby', nick: 'ghost' } };
                   } else if (p === '80') {
                        output = `(UNKNOWN) [192.168.1.99] 80 (http) open\nGET / HTTP/1.1\n\nHTTP/1.1 403 Forbidden\nServer: nginx/1.18.0\nDate: ${new Date().toUTCString()}\nContent-Type: text/html\nContent-Length: 162\n\n<html>\n<head><title>403 Forbidden</title></head>\n<body>\n<center><h1>403 Forbidden</h1></center>\n<hr><center>nginx/1.18.0</center>\n</body>\n</html>`;
                   } else {
                        output = `(UNKNOWN) [${host}] ${p} (?) : Connection refused`;
                   }
               } else if (host === '192.168.1.110') {
                    output = `(UNKNOWN) [192.168.1.110] ${p} open\nHP JetDirect J4169A\nFLAG: GHOST_ROOT{ARP_C4CH3_P01S0N}\n`;
               } else if (host === '10.10.10.10') {
                    output = `(UNKNOWN) [10.10.10.10] 4444 (?) open\n[DATA RECEIVED] Key: BRIDGE_SECURE_KEY_X9\n[DATA RECEIVED] Message: The Black Site is heavily monitored. Proceed with caution.\n`;
               } else if (host === 'localhost' || host === '127.0.0.1') {
                   if (p === '1337') {
                       output = `localhost [127.0.0.1] 1337 (?): open\n[BACKDOOR_LISTENER_V2]\n> Awaiting Payload...`;
                   } else if (p === '31337') {
                       // Cycle 115
                       output = `(UNKNOWN) [127.0.0.1] 31337 (?) open\n[HIDDEN_SERVICE_V1] AUTH_REQUIRED\n[SYSTEM] Handshake Accepted.\nFLAG: GHOST_ROOT{H1DD3N_P0RT_F0UND}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN PORT DISCOVERED.\x1b[0m`;
                       if (!VFS['/var/run/port_solved']) {
                           VFS['/var/run/port_solved'] = { type: 'file', content: 'TRUE' };
                           const runDir = getNode('/var/run');
                           if (runDir && runDir.type === 'dir' && !runDir.children.includes('port_solved')) {
                               runDir.children.push('port_solved');
                           }
                       }
                   } else if (p === '6667') {
                       // Cycle 145: The Hidden Service
                       if (VFS['/etc/xinetd.d/irc_backdoor']) {
                            output = `(UNKNOWN) [127.0.0.1] 6667 (irc) open\n:irc.local 001 ghost :Welcome to the Local IRC Backdoor\n:irc.local 251 ghost :There are 1 users and 0 invisible on 1 servers\n:irc.local 372 ghost :- This is a private system.\n:irc.local 376 ghost :End of MOTD command.\n\n:irc.local JOIN #shadow\n:irc.local 332 ghost #shadow :TOPIC: GHOST_ROOT{X1NETD_B4CKD00R_D1SCOV3R3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN SERVICE ACCESSED.\x1b[0m`;
                            
                            if (!VFS['/var/run/service_solved']) {
                                VFS['/var/run/service_solved'] = { type: 'file', content: 'TRUE' };
                                const runDir = getNode('/var/run');
                                if (runDir && runDir.type === 'dir' && !runDir.children.includes('service_solved')) {
                                    runDir.children.push('service_solved');
                                }
                            }
                       } else {
                            output = `localhost [127.0.0.1] ${p} (?): Connection refused`;
                       }
                   } else {
                       output = `localhost [127.0.0.1] ${p} (?): Connection refused`;
                   }
               } else {
                   if (verbose) output = `nc: connect to ${host} port ${p} (tcp) failed: Connection refused`;
                   else output = `nc: connect to ${host} port ${p} (tcp) failed: Connection refused`;
               }
           }
       }
       break;
    }
    case 'touch': {
      const path = resolvePath(cwd, args[0]);
      if (isReadOnly(path)) {
          output = `touch: cannot touch '${args[0]}': Read-only file system`;
          break;
      }
      if (getNode('/var/cache/inodes_fill')) {
         output = `touch: cannot touch '${args[0]}': No space left on device`;
         break;
      }
      if (!!getNode('/home/ghost/.cache/browser/garbage.dat') && path.startsWith('/home')) {
          output = `touch: cannot touch '${args[0]}': Disk quota exceeded`;
          break;
      }
      if (args.length < 1) {
        output = 'usage: touch <file>';
      } else {
        const target = args[0];
        // const path = resolvePath(cwd, target); // Already resolved above
        
        if (path.startsWith('/var') && !!getNode('/var/log/overflow.dmp')) {
            output = `touch: cannot touch '${target}': No space left on device`;
        } else {
            const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
            const fileName = path.substring(path.lastIndexOf('/') + 1);
            const parentNode = getNode(parentPath);
            if (parentNode && parentNode.type === 'dir') {
              if (!getNode(path)) {
                 VFS[path] = { type: 'file', content: '' };
                 parentNode.children.push(fileName);
              }
            }
        }
      }
      break;
    }
    case 'du': {
        const args = commandLine.trim().split(/\s+/).slice(1);
        const target = args.find(a => !a.startsWith('-')) || '.';
        const path = resolvePath(cwd, target);
        const node = getNode(path);
        
        if (!node) {
            output = `du: cannot access '${target}': No such file or directory`;
        } else if (node.type === 'file') {
            const size = (path === '/var/log/nginx/error.log.1') ? '512000' : '4';
            output = `${size}\t${path}`;
        } else if (node.type === 'dir') {
            let out = '';
            for (const child of node.children) {
                const childPath = path === '/' ? `/${child}` : `${path}/${child}`;
                const size = (childPath === '/var/log/nginx/error.log.1') ? '512000' : '4';
                out += `${size}\t${childPath}\n`;
            }
            output = out.trim();
        }
        break;
    }
    case 'rm': {
      if (args.length < 1) {
        output = 'usage: rm <file>';
      } else {
        let target = args[0];
        
        // Cycle 130: Dash Filename
        if (target.startsWith('-')) {
            // Check for flags (simplified)
            if (target === '-rf' || target === '-r' || target === '-f') {
                if (args.length > 1) target = args[1];
                else { output = 'rm: missing operand'; break; }
            } else if (target === '--') {
                if (args.length > 1) target = args[1];
                else { output = 'rm: missing operand'; break; }
            } else if (target.startsWith('./') || target.startsWith('/')) {
                // OK
            } else {
                output = `rm: invalid option -- '${target.substring(1)}'\nTry 'rm --help' for more information.`;
                break;
            }
        }

        const path = resolvePath(cwd, target);
        
        // Cycle 113: Read Only Check
        if (isReadOnly(path)) {
            output = `rm: cannot remove '${target}': Read-only file system`;
            break;
        }

        const isRoot = !!getNode('/tmp/.root_session');

        // Check Attributes (Cycle 40)
        const attrs = FILE_ATTRIBUTES[path] || [];
        if (attrs.includes('i')) {
             output = `rm: cannot remove '${target}': Operation not permitted`;
             return { output, newCwd };
        }

        // Critical system files check
        if (['/bin/bash', '/sbin/init', '/vmlinuz', '/boot/vmlinuz'].includes(path) || path === '/') {
             if (isRoot && (args.includes('-rf') || args.includes('--no-preserve-root'))) {
                 return { output: 'Deleting critical system file...', newCwd, action: 'kernel_panic' };
             } else {
                 output = `rm: cannot remove '${target}': Permission denied`;
             }
        } else {
            const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
            const fileName = path.substring(path.lastIndexOf('/') + 1);
            const parentNode = getNode(parentPath);
            if (parentNode && parentNode.type === 'dir') {
              delete VFS[path];
              parentNode.children = parentNode.children.filter(c => c !== fileName);
              
              // Cycle 134: Deleted log held by process
              if (path === '/var/log/httpd/access.log') {
                  // Only set if process 4040 exists
                  if (PROCESSES.find(p => p.pid === 4040)) {
                      if (!VFS['/var/run/ghost_log_deleted']) {
                          VFS['/var/run/ghost_log_deleted'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('ghost_log_deleted')) {
                              runDir.children.push('ghost_log_deleted');
                          }
                      }
                  }
              }

              // Mission Update for Cycle 40
              if (path === '/var/log/surveillance.log') {
                  if (!VFS['/var/run/attr_solved']) {
                      VFS['/var/run/attr_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('attr_solved')) {
                          runDir.children.push('attr_solved');
                      }
                      output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: EVIDENCE SCRUBBED (Immutable Attribute Bypassed).\x1b[0m`;
                  }
              }

              // Mission Update for Cycle 276
              if (path === '/var/secure/vault.lock') {
                  if (!VFS['/var/run/cycle276_solved']) {
                      VFS['/var/run/cycle276_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle276_solved')) {
                          runDir.children.push('cycle276_solved');
                      }
                      output += `\n[SECURE] Vault Lock Removed.\nFLAG: GHOST_ROOT{CH4TTR_1MMUT4BL3_BYP4SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: IMMUTABLE LOCK REMOVED.\x1b[0m`;
                  }
              }

              // Mission Update for Cycle 93
              if (path === '/etc/cron.d/malware') {
                  if (!VFS['/var/run/cron_solved']) {
                      VFS['/var/run/cron_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('cron_solved')) {
                          runDir.children.push('cron_solved');
                      }
                      output += `\n[CRON] Reloading configuration... Malicious job removed.\nFLAG: GHOST_ROOT{CR0N_J0B_PURG3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SCHEDULED TASK PURGED.\x1b[0m`;
                  }
              }

              // Mission Update for Cycle 249
              if (path === '/var/log/nginx/error.log.1') {
                  if (!VFS['/var/run/cycle249_solved']) {
                      VFS['/var/run/cycle249_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle249_solved')) {
                          runDir.children.push('cycle249_solved');
                      }
                      output += `\n[SYSTEM] Disk space reclaimed.\nFLAG: GHOST_ROOT{D1SK_SP4C3_R3CL41M3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: STORAGE CLEANED.\x1b[0m`;
                  }
              }
            } else {
                output = `rm: cannot remove '${target}': No such file or directory`;
            }
        }
      }
      break;
    }
    case 'dd': {
        const ifArg = args.find(a => a.startsWith('if='));
        const ofArg = args.find(a => a.startsWith('of='));
        
        if (ifArg && ofArg) {
            const inFile = ifArg.split('=')[1];
            const outFile = ofArg.split('=')[1];
            const outPath = resolvePath(cwd, outFile);
            
            if (outPath === '/dev/sda' || outPath === '/dev/hda' || outPath === '/dev/disk0') {
                 const isRoot = !!getNode('/tmp/.root_session') || !!getNode('/root'); // Simplified root check (simulation)
                 
                 // Cycle 131: Restore MBR
                 if (inFile === '/var/backups/boot.mbr') {
                     output = `1+0 records in\n1+0 records out\n512 bytes copied, 0.00034 s, 1.5 MB/s\n[SYSTEM] MBR Restored Successfully.\n[BOOT] Partition table valid.\nFLAG: GHOST_ROOT{MBR_R3ST0R3D_S4F3LY}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BOOTLOADER REPAIRED.\x1b[0m`;
                     
                     // Restore /dev/sda content
                     const sda = getNode('/dev/sda');
                     if (sda) (sda as any).content = 'MBR_V1:[BOOTLOADER_CODE]...[PARTITION_TABLE_OK]...[SIGNATURE_55AA]';
                     
                     if (!VFS['/var/run/mbr_solved']) {
                         VFS['/var/run/mbr_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('mbr_solved')) {
                             runDir.children.push('mbr_solved');
                         }
                     }
                 } else if (isRoot) {
                     output = 'dd: writing to disk... [WARNING] DATA DESTRUCTION IMMINENT';
                     return { output, newCwd, action: 'kernel_panic' };
                 } else {
                     output = `dd: ${outFile}: Permission denied`;
                 }
            } else {
                output = `1024+0 records in\n1024+0 records out\n524288 bytes (524 kB) copied, 0.001337 s, 392 MB/s`;
            }
        } else {
            output = 'usage: dd if=<source> of=<dest>';
        }
        break;
    }
    case 'steghide': {
       const hasExtract = args.includes('extract') || args.includes('-sf');
       const hasInfo = args.includes('info');
       
       if (!hasExtract && !hasInfo) {
           output = 'steghide: usage: steghide extract -sf <file> -p <passphrase>';
       } else {
           // Extract
           let fileTarget: string | undefined;
           const sfIndex = args.indexOf('-sf');
           if (sfIndex !== -1 && args[sfIndex + 1]) {
               fileTarget = args[sfIndex + 1];
           } else {
               fileTarget = args.find(a => a.endsWith('.jpg') || a.endsWith('.wav'));
           }

           if (!fileTarget) {
               output = 'steghide: argument "-sf <filename>" missing';
           } else {
               const filePath = resolvePath(cwd, fileTarget);
               const fileNode = getNode(filePath);

               if (!fileNode || fileNode.type !== 'file') {
                   output = `steghide: could not open "${fileTarget}".`;
               } else {
                   const pIndex = args.indexOf('-p');
                   const passphrase = (pIndex !== -1 && args[pIndex + 1]) ? args[pIndex + 1] : null;

                   if (!passphrase) {
                       output = 'steghide: passphrase required (use -p <passphrase>)';
                   } else if (fileTarget.endsWith('evidence.jpg') && passphrase === 'kirov_reporting' || passphrase === '0451') {
                       // Success (Cycle ??)
                       const payloadName = 'payload.txt';
                       const payloadPath = cwd === '/' ? `/${payloadName}` : `${cwd}/${payloadName}`;
                       
                       // Write file
                       VFS[payloadPath] = { 
                           type: 'file', 
                           content: 'CAUTION: CLASSIFIED MATERIAL\n\nAccess Code: black_widow_protocol_init\n\nUse this to gain root privileges via "su root".' 
                       };
                       
                       // Add to parent
                       const parentNode = getNode(cwd);
                       if (parentNode && parentNode.type === 'dir' && !parentNode.children!.includes(payloadName)) {
                           parentNode.children!.push(payloadName);
                       }
                       
                       output = `wrote extracted data to "${payloadName}".`;
                   } else if (fileTarget.endsWith('transmission.wav') && (passphrase === 'frequency' || passphrase === 'specter')) {
                       // Success (Cycle 57)
                       const payloadName = 'coordinates.txt';
                       const payloadPath = cwd === '/' ? `/${payloadName}` : `${cwd}/${payloadName}`;
                       
                       if (!VFS['/var/run/wav_decoded']) {
                           VFS['/var/run/wav_decoded'] = { type: 'file', content: 'TRUE' };
                           const runDir = getNode('/var/run');
                           if (runDir && runDir.type === 'dir' && !runDir.children.includes('wav_decoded')) {
                               runDir.children.push('wav_decoded');
                           }
                           output = `wrote extracted data to "${payloadName}".\n[SUCCESS] Audio Steganography Decoded.\nFLAG: GHOST_ROOT{ST3G_W4V_H1DD3N_D4T4}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: AUDIO STEGANOGRAPHY.\x1b[0m`;
                       } else {
                           output = `wrote extracted data to "${payloadName}".`;
                       }

                       VFS[payloadPath] = {
                           type: 'file',
                           content: 'TARGET COORDINATES: 34.0522 N, 118.2437 W\nDROP POINT: SECTOR 7\n'
                       };
                       const parentNode = getNode(cwd);
                       if (parentNode && parentNode.type === 'dir' && !parentNode.children!.includes(payloadName)) {
                           parentNode.children!.push(payloadName);
                       }
                   } else {
                       output = `steghide: could not extract data: invalid passphrase "${passphrase}"`;
                   }
               }
           }
       }
       break;
    }
    case 'crack': {
      output = 'Cracking...';
      return { output, newCwd, action: 'crack_sim', data: { target: args[0], user: args[1], success: false } };
    }
    case 'dmesg': {
      let dmesgOutput = '';
      const messages = [
          'Linux version 5.4.0-ghost (root@mainframe) (gcc version 9.3.0)',
          'Command line: BOOT_IMAGE=/boot/vmlinuz-5.4.0-ghost root=UUID=dead-beef ro quiet splash',
          'KERNEL supported cpus:',
          '  Intel GenuineIntel',
          '  AMD AuthenticAMD',
          '  Centaur CentaurHauls',
          'x86/fpu: Supporting XSAVE feature 0x001: \'x87 floating point registers\'',
          'x86/fpu: Supporting XSAVE feature 0x002: \'SSE registers\'',
          'x86/fpu: Supporting XSAVE feature 0x004: \'AVX registers\'',
          'pci 0000:00:1f.2: [sda] 134217728 512-byte logical blocks: (68.7 GB/64.0 GiB)',
          'pci 0000:00:1f.3: [sdb] Attached SCSI disk (Hidden)',
          'sdb: sdb1',
          'EXT4-fs (sdb1): mounted filesystem with ordered data mode. Opts: (null)',
          'sd 2:0:0:0: [sdc] 16777216 512-byte logical blocks: (8.5 GB/7.9 GiB)',
          'sdc: sdc1',
          'EXT4-fs (sdc1): VFS: Can\'t find ext4 filesystem',
          'systemd[1]: Detected architecture x86-64.',
          'systemd[1]: Set hostname to <ghost-root>.',
          'systemd[1]: Initializing machine ID from random generator.',
          '[SECURITY] AppArmor initialized',
          '[SECURITY] SELinux:  Disabled at boot.',
          'NET: Registered protocol family 10',
          'Segment Routing with IPv6',
          'NET: Registered protocol family 17',
          'IPI: frequency of the interrupt process (2000 Hz)',
          'random: fast init done',
          'logips2: IBM Logips2 mouse driver',
          'input: AT Translated Set 2 keyboard as /devices/platform/i8042/serio0/input/input0',
          'r8169 0000:03:00.0 enp3s0: Link is Up - 1Gbps/Full - flow control rx/tx',
          'IPv6: ADDRCONF(NETDEV_CHANGE): enp3s0: link becomes ready',
          'usb 1-1: new high-speed USB device number 2 using xhci_hcd',
          'usb 1-1: New USB device found, idVendor=8087, idProduct=0029, bcdDevice= 0.01',
          'usb 1-1: New USB device strings: Mfr=0, Product=0, SerialNumber=0',
          'hub 1-1:1.0: USB hub found',
          'hub 1-1:1.0: 8 ports detected',
          'input: Power Button as /devices/LNXSYSTM:00/LNXPWRBN:00/input/input1',
          'ACPI: Power Button [PWRF]',
          'input: Power Button as /devices/LNXSYSTM:00/LNXSYBUS:00/PNP0C0C:00/input/input2',
          'ACPI: Power Button [PWRB]',
          'Non-volatile memory driver v1.3'
      ];

      // Generate noise
      let currentTime = 0.0;
      for (const msg of messages) {
          currentTime += Math.random() * 0.5;
          dmesgOutput += `[    ${currentTime.toFixed(6)}] ${msg}\n`;
      }

      // The Needle
      dmesgOutput += `[   42.000000] [ERROR] ghost_kernel: Critical failure at addr 0xDEADBEEF. Dump: GHOST_ROOT{DM3SG_H1DD3N_MSG}\n`;
      
      // More noise
      for (let i = 0; i < 20; i++) {
          currentTime += Math.random() * 0.5;
          dmesgOutput += `[    ${currentTime.toFixed(6)}] [INFO] System stability check: OK\n`;
      }
      
      output = dmesgOutput;
      
      if (!VFS['/var/run/dmesg_solved']) {
           VFS['/var/run/dmesg_solved'] = { type: 'file', content: 'TRUE' };
           const runDir = getNode('/var/run');
           if (runDir && runDir.type === 'dir' && !runDir.children.includes('dmesg_solved')) {
               runDir.children.push('dmesg_solved');
           }
           output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL ERROR FOUND.\x1b[0m`;
      }
      break;
    }
    case 'top':
      return { output: '', newCwd, action: 'top_sim', data: PROCESSES };
    case 'df': {
      const kernLogBig = !!getNode('/var/log/kern.log.1');
      const panicDump = !!getNode('/var/log/kernel_panic.dump');
      const overflow = !!getNode('/var/log/overflow.dmp') || !!getNode('/var/log/syslog.1') || kernLogBig || panicDump;
      const inodeFull = !!getNode('/var/cache/inodes_fill');
      
      // Cycle 134 Logic
      const logNode = getNode('/var/log/httpd/access.log');
      const logDeleted = !!getNode('/var/run/ghost_log_deleted');
      const logBig = (logNode && (logNode as any).content.length > 5000) || logDeleted;
      
      const varUsage = (overflow || logBig) ? '100%' : '12%';
      const varAvail = (overflow || logBig) ? '0' : '440M';
      
      // Cycle 122: Home Quota
      const homeBig = !!getNode('/home/ghost/.cache/browser/garbage.dat');
      const homeUsage = homeBig ? '100%' : '5%';
      const homeAvail = homeBig ? '0' : '4.7G';
      
      if (args.includes('-i')) {
          output = `Filesystem      Inodes  IUsed   IFree IUse% Mounted on
udev           1015007    499 1014508    1% /dev
tmpfs           203819    822  202997    1% /run
/dev/sda1      1966080 156822 1809258    8% /
tmpfs           203819      1  203818    1% /dev/shm
/dev/sdb1        32768  ${inodeFull ? '32768' : '1500'}      ${inodeFull ? '0' : '31268'}  ${inodeFull ? '100%' : '5%'} /var`;
      } else if (args.includes('-h') || args.includes('-H')) {
          output = `Filesystem      Size  Used Avail Use% Mounted on
udev            3.9G     0  3.9G   0% /dev
tmpfs           797M  1.2M  796M   1% /run
/dev/sda1        30G   12G   17G  42% /
tmpfs           3.9G     0  3.9G   0% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
/dev/sdb1       500M  ${overflow ? '500M' : '60M'}  ${varAvail}  ${varUsage} /var
/dev/sdc1       5.0G  ${homeBig ? '5.0G' : '256M'}  ${homeAvail}  ${homeUsage} /home`;
      } else {
          output = `Filesystem     1K-blocks    Used Available Use% Mounted on
udev             4060028       0   4060028   0% /dev
tmpfs             815276    1184    814092   1% /run
/dev/sda1       30832548 12345678 16893324  42% /
/dev/sdb1         512000  ${overflow ? '512000' : '61440'}    ${overflow ? '0' : '450560'}  ${varUsage} /var
/dev/sdc1        5242880  ${homeBig ? '5242880' : '262144'}    ${homeBig ? '0' : '4980736'}  ${homeUsage} /home`;
      }
      break;
    }
    case 'upload_payload': {
        const panicDump = !!getNode('/var/log/kernel_panic.dump');
        if (panicDump) {
            output = '[ERROR] Upload failed: Insufficient disk space on /var.\n[DIAGNOSTIC] Disk usage is at 100%.\n[ACTION] Free up space immediately.';
        } else {
            output = '[UPLOAD] Initiating transfer...\n...\n[SUCCESS] Payload uploaded.\nFLAG: GHOST_ROOT{D1SK_SP4C3_R3CL41M3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DISK SPACE RECLAIMED.\x1b[0m';
            
            if (!VFS['/var/run/disk_hog_solved']) {
                VFS['/var/run/disk_hog_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('disk_hog_solved')) {
                    runDir.children.push('disk_hog_solved');
                }
            }
        }
        break;
    }
    case 'du': {
      const overflow = !!getNode('/var/log/overflow.dmp');
      const syslogBig = !!getNode('/var/log/syslog.1');
      const kernLogBig = !!getNode('/var/log/kern.log.1');
      const panicDump = !!getNode('/var/log/kernel_panic.dump');
      const isFull = overflow || syslogBig || kernLogBig || panicDump;
      
      const homeBig = !!getNode('/home/ghost/.cache/browser/garbage.dat'); // Cycle 122

      let targetPath = cwd;
      if (args.length > 0 && !args[0].startsWith('-')) {
          targetPath = resolvePath(cwd, args[0]);
      } else if (args.length > 1 && !args[1].startsWith('-')) {
          targetPath = resolvePath(cwd, args[1]);
      }
      
      const human = args.includes('-h') || args.includes('-sh');
      
      if (targetPath === '/var' || targetPath.startsWith('/var')) {
          if (targetPath === '/var/log' || targetPath === '/var') {
              let out = '';
              if (human) {
                  if (overflow) out += `500M\t/var/log/overflow.dmp\n`;
                  if (syslogBig) out += `50G\t/var/log/syslog.1\n`;
                  if (kernLogBig) out += `5.0G\t/var/log/kern.log.1\n`;
                  if (panicDump) out += `50G\t/var/log/kernel_panic.dump\n`;
                  out += `4.0K\t/var/log/syslog\n`;
                  out += `8.0K\t/var/log/auth.log\n`;
                  out += `${isFull ? '5.5G' : '60K'}\t/var/log\n`;
                  if (targetPath === '/var') out += `${isFull ? '5.5G' : '1.2M'}\t/var\n`;
              } else {
                  if (overflow) out += `512000\t/var/log/overflow.dmp\n`;
                  if (syslogBig) out += `52428800\t/var/log/syslog.1\n`;
                  if (kernLogBig) out += `5242880\t/var/log/kern.log.1\n`;
                  if (panicDump) out += `52428800\t/var/log/kernel_panic.dump\n`;
                  out += `4\t/var/log/syslog\n`;
                  out += `8\t/var/log/auth.log\n`;
                  out += `${isFull ? '5767168' : '60'}\t/var/log\n`;
                  if (targetPath === '/var') out += `${isFull ? '5767228' : '1200'}\t/var\n`;
              }
              output = out.trim();
          } else {
              output = human ? `4.0K\t${targetPath}` : `4\t${targetPath}`;
          }
      } else if (homeBig && (targetPath.startsWith('/home') || targetPath === '.' || targetPath === '/')) {
          // Cycle 122 Logic
          let out = '';
          const absPath = targetPath === '.' ? cwd : targetPath;
          
          if (absPath.includes('.cache/browser') || absPath.includes('garbage.dat')) {
               out = human ? `4.8G\t${absPath.includes('garbage.dat') ? absPath : absPath + '/garbage.dat'}` : `5033164\t${absPath.includes('garbage.dat') ? absPath : absPath + '/garbage.dat'}`;
          } else if (absPath.includes('.cache')) {
               out = human ? `4.8G\t${absPath}/browser` : `5033164\t${absPath}/browser`;
          } else if (absPath === '/home/ghost' || absPath === '/home' || absPath === '/') {
               if (absPath !== '/') out += human ? `4.8G\t${absPath}/.cache\n` : `5033164\t${absPath}/.cache\n`;
               out += human ? `4.9G\t${absPath}` : `5138022\t${absPath}`;
          } else {
               out = human ? `24K\t${targetPath}` : `24\t${targetPath}`;
          }
          output = out.trim();
      } else {
          output = human ? `24K\t${targetPath}` : `24\t${targetPath}`;
      }
      break;
    }
    // Removed duplicate df case
    case 'lsof': {
        const lines = ['COMMAND     PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME'];
        // standard mocks
        lines.push('systemd       1   root  cwd    DIR    8,1     4096    2 /');
        lines.push('sshd        404   root  txt    REG    8,1   853040 1056 /usr/sbin/sshd');
        
        // The Puzzle
        const daemon = PROCESSES.find(p => p.pid === 1001);
        if (daemon) {
            lines.push('log_daemon 1001   root  cwd    DIR    8,1     4096    2 /');
            lines.push('log_daemon 1001   root  txt    REG    8,1    54020 3021 /usr/sbin/log_daemon');
            lines.push('log_daemon 1001   root    1w   REG    8,1 8589934592 5001 /var/log/syslog (deleted)'); // 8GB file
        }
        
        if (args.includes('+L1') || args.includes('grep')) {
             if (args.includes('+L1')) {
                 output = lines.filter(l => l.includes('(deleted)') || l.includes('COMMAND')).join('\n');
             } else {
                 output = lines.join('\n');
             }
        } else {
             output = lines.join('\n');
        }
        break;
    }
    case 'ps': {
      let procs = [...PROCESSES];
      if (LOADED_MODULES.includes('rootkit')) {
          procs = procs.filter(p => p.pid !== 666 && p.pid !== 9999 && !p.command.includes('hydra') && !p.command.includes('spectre'));
      }

      if (args.includes('aux') || args.includes('-aux')) {
          output = 'USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n' +
          procs.map(p => {
              const vsz = Math.floor(Math.random() * 100000);
              const rss = Math.floor(Math.random() * 50000);
              return `${p.user.padEnd(8)} ${String(p.pid).padStart(5)} ${p.cpu.toFixed(1).padStart(4)} ${p.mem.toFixed(1).padStart(4)} ${String(vsz).padStart(6)} ${String(rss).padStart(5)} ${p.tty.padEnd(8)} ${p.stat.padEnd(4)} 14:02   ${p.time.padStart(5)} ${p.command}`;
          }).join('\n');
      } else if (args.includes('-ef') || args.includes('ef')) {
          output = 'UID        PID  PPID  C STIME TTY          TIME CMD\n' +
          procs.map(p => {
              const ppid = p.ppid;
              return `${p.user.padEnd(8)} ${String(p.pid).padStart(5)} ${String(ppid).padStart(5)}  0 14:02 ${p.tty.padEnd(8)} ${p.time.padStart(8)} ${p.command}`;
          }).join('\n');
      } else if (args.includes('-o')) {
          const oIndex = args.indexOf('-o');
          const format = args[oIndex + 1];
          if (format) {
              const cols = format.split(',').map(c => c.trim().toLowerCase());
              // Pad headers
              const headers = cols.map(c => {
                  if (c === 'pid' || c === 'ppid') return c.toUpperCase().padEnd(5);
                  if (c === 'user') return c.toUpperCase().padEnd(8);
                  if (c === 'tty') return c.toUpperCase().padEnd(8);
                  if (c === 'time') return c.toUpperCase().padEnd(8);
                  return c.toUpperCase();
              }).join(' ');

              output = headers + '\n' +
              procs.map(p => {
                  return cols.map(c => {
                      if (c === 'pid') return String(p.pid).padStart(5);
                      if (c === 'ppid') return String(p.ppid).padStart(5);
                      if (c === 'user') return p.user.padEnd(8);
                      if (c === 'cmd' || c === 'command') return p.command;
                      if (c === 'tty') return p.tty.padEnd(8);
                      if (c === 'time') return p.time.padStart(8);
                      return '?';
                  }).join(' ');
              }).join('\n');
          } else {
              output = 'ps: option requires an argument -- o';
          }
      } else {
          // Default minimal output
          output = '  PID TTY          TIME CMD\n' +
          procs.filter(p => p.tty !== '?').map(p => {
              return `${String(p.pid).padStart(5)} ${p.tty.padEnd(8)} ${p.time.padStart(8)} ${p.command}`;
          }).join('\n');
      }
      break;
    }
    case 'lsmod': {
      if (LOADED_MODULES.length === 0) {
          output = 'Module                  Size  Used by';
      } else {
          output = 'Module                  Size  Used by\n' + 
                   LOADED_MODULES.map(m => `${m.padEnd(24)} ${String(Math.floor(Math.random()*10000+4096)).padEnd(6)} 0`).join('\n');
      }
      break;
    }
    case 'insmod': {
      if (args.length < 1) {
          output = 'insmod: usage: insmod <filename>';
      } else {
          const fileTarget = args[0];
          const node = getNode(resolvePath(cwd, fileTarget));
          
          if (!node) {
              output = `insmod: ERROR: could not load module ${fileTarget}: No such file or directory`;
          } else if (node.type === 'dir') {
              output = `insmod: ERROR: could not load module ${fileTarget}: Is a directory`;
          } else if (node.type === 'symlink') {
              output = `insmod: ERROR: could not insert module ${fileTarget}: Is a symbolic link`;
          } else {
              // Check magic signature for .ko
              const content = (node as any).content || '';
              if (content.startsWith('\x7fELF') || fileTarget.endsWith('.ko')) {
                  const modName = fileTarget.split('/').pop()?.replace('.ko', '') || 'unknown';
                  
                  if (LOADED_MODULES.includes(modName)) {
                      output = `insmod: ERROR: could not insert module ${fileTarget}: Module already in kernel`;
                  } else {
                      LOADED_MODULES.push(modName);
                      output = ''; // Silent success on Linux usually
                  }
              } else {
                  output = `insmod: ERROR: could not insert module ${fileTarget}: Invalid module format`;
              }
          }
      }
      break;
    }
    case 'rmmod': {
       if (args.length < 1) {
           output = 'rmmod: usage: rmmod <modulename>';
       } else {
           const modName = args[0];
           
           // Cycle 58: Kernel Panic Fix
           if (modName === 'phantom_driver') {
               if (getNode('/var/crash/vmcore.1')) {
                   if (!VFS['/var/run/kernel_fixed']) {
                       VFS['/var/run/kernel_fixed'] = { type: 'file', content: 'TRUE' };
                       const runDir = getNode('/var/run');
                       if (runDir && runDir.type === 'dir' && !runDir.children.includes('kernel_fixed')) {
                           runDir.children.push('kernel_fixed');
                       }
                       output = `[KERNEL] Module "phantom_driver" unloaded.\n[KERNEL] System Stability Restored.\n[KERNEL] Panic resolved.\nFLAG: GHOST_ROOT{K3RN3L_P4N1C_F1X3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL PANIC RESOLVED.\x1b[0m`;
                   } else {
                       output = `rmmod: ERROR: Module phantom_driver is not currently loaded`;
                   }
                   return { output, newCwd, action: 'delay' };
               }
           }

           const idx = LOADED_MODULES.indexOf(modName);
           if (idx !== -1) {
               LOADED_MODULES.splice(idx, 1);
               output = ''; // Silent success
           } else {
               output = `rmmod: ERROR: Module ${modName} is not currently loaded`;
           }
       }
       break;
    }
    case 'sqlite3': {
        if (args.length < 1) {
            output = 'sqlite3: usage: sqlite3 <database> [sql]';
        } else {
            const dbPath = resolvePath(cwd, args[0]);
            const dbNode = getNode(dbPath);
            const query = args.slice(1).join(' '); // Simple join, not parsing quotes perfectly here but good enough for simulation

            if (!dbNode) {
                output = `sqlite3: Error: unable to open database "${args[0]}": file is not a database`;
            } else if (dbNode.type !== 'file' || !dbNode.content.startsWith('SQLite format 3')) {
                output = `sqlite3: Error: file is not a database`;
            } else {
                if (args.length === 1) {
                    // Interactive mode (simulation)
                    output = `SQLite version 3.31.1 2020-01-27 19:55:54\nEnter ".help" for usage hints.\nsqlite> `;
                    // Note: We don't support full interactive mode here, just one-shot commands. 
                    // This output is just flavor text for the "no query" case.
                    return { output, newCwd, action: 'delay' };
                }

                // Check for SQL Injection / specific query
                if (query.includes("' OR '1'='1")) {
                    output = `1|admin|21232f297a57a5a743894a0e4a801fc3|superuser\n2|ghost|5f4dcc3b5aa765d61d8327deb882cf99|user\n3|guest|084e0343a0486ff05530df6c705c8bb4|guest\n\n[SUCCESS] SQL Injection Successful.\n[DUMP] Dumping user table...\nFLAG: GHOST_ROOT{SQL_1NJ3CT10N_PWND}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DATABASE EXPLOITED.\x1b[0m`;
                    
                    if (!VFS['/var/run/sql_solved']) {
                        VFS['/var/run/sql_solved'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('sql_solved')) {
                            runDir.children.push('sql_solved');
                        }
                    }
                } else if (query.toLowerCase().startsWith('select')) {
                    // Mock query result
                    if (query.includes('users')) {
                        output = `Error: no such table: users (Try SQL Injection)`;
                    } else {
                        output = `Error: syntax error near "${query.split(' ')[0]}"`;
                    }
                } else {
                    output = `Error: near "${query.split(' ')[0]}": syntax error`;
                }
            }
        }
        break;
    }
    case 'gdb': {
        if (args.length < 1) {
            output = 'gdb: usage: gdb <core_dump>';
        } else {
            const fileTarget = args[0];
            const filePath = resolvePath(cwd, fileTarget);
            const fileNode = getNode(filePath);

            if (!fileNode) {
                output = `gdb: ${fileTarget}: No such file or directory`;
            } else if (fileNode.type !== 'file' || !fileNode.content.includes('ELF_CORE_DUMP')) {
                output = `gdb: ${fileTarget}: File format not recognized`;
            } else {
                // Cycle 60: Memory Dump Analysis
                output = `GNU gdb (Ghost Root GDB) 9.2\nCore was generated by \`./auth_service\`.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x0804801a in authenticate () at auth.c:42\n42\t    if (strcmp(input, secret) == 0) grant_access();\n(gdb) \n[SYSTEM] Debugger attached. Try examining memory (e.g., 'x/s 0x08049000').`;
                
                // Hack: Since we don't have interactive GDB, we check if the user *also* passed a command via --eval-command or similar, 
                // OR we simulate the result if they just ran gdb on the file.
                // Better approach: Let them run `gdb core.1337` then maybe `strings core.1337` is the intended solution?
                // The prompt says "GDB Core Analysis". 
                // Let's support `strings` finding the flag too.
                
                // But if they run `gdb core.1337`, we can just give them the win if they use `strings` on it later.
                // Wait, `strings` command is already implemented but just returns "strings" usually.
                // Let's update `strings` case or `cat` case? No, `strings` is in the COMMANDS list but maybe not implemented in switch.
                
                // Let's implement `strings` command logic properly if it's missing.
                // Checking `strings` implementation...
                // It is in COMMANDS but likely not in switch.
            }
        }
        break;
    }
    case 'strings': {
        if (args.length < 1) {
            output = 'strings: usage: strings <file>';
        } else {
            const fileTarget = args[0];
            const filePath = resolvePath(cwd, fileTarget);
            const fileNode = getNode(filePath);
            
            if (!fileNode || fileNode.type !== 'file') {
                output = `strings: ${fileTarget}: No such file`;
            } else {
                // Filter for readable strings (simulated)
                const content = fileNode.content;
                // If it's the core dump
                if (fileTarget.includes('core.1337')) {
                    output = `...
/lib/ld-linux.so.2
auth_service
password=supersecretkey123
GHOST_ROOT{C0R3_DUMP_D1V3R}
...`;
                    if (!VFS['/var/run/gdb_solved']) {
                        VFS['/var/run/gdb_solved'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('gdb_solved')) {
                            runDir.children.push('gdb_solved');
                        }
                        output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: MEMORY DUMP ANALYZED.\x1b[0m`;
                    }
                } else if (fileTarget.includes('auth.pyc')) {
                    output = `...
hash
GHOST_ROOT{PYTH0N_BYT3C0D3_S3CR3T}
password_check
auth.py
<module>
...`;
                    if (!VFS['/var/run/pyc_solved']) {
                        VFS['/var/run/pyc_solved'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('pyc_solved')) {
                            runDir.children.push('pyc_solved');
                        }
                        output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PYTHON BYTECODE REVERSED.\x1b[0m`;
                    }
                } else {
                    // Generic strings behavior (strip non-printable)
                    output = content.replace(/[^\x20-\x7E]/g, '');
                }
            }
        }
        break;
    }
    case 'jwt_tool': {
        if (args.length < 1) {
            output = 'jwt_tool: usage: jwt_tool <token_file> OR jwt_tool decode <token>';
        } else {
            let token = '';
            if (args[0] === 'decode' && args[1]) {
                token = args[1];
            } else {
                const fileTarget = args[0];
                const filePath = resolvePath(cwd, fileTarget);
                const fileNode = getNode(filePath);
                
                if (fileNode && fileNode.type === 'file') {
                    // Try to parse JSON to get token
                    try {
                        const json = JSON.parse(fileNode.content);
                        if (json.session_token) token = json.session_token;
                    } catch (e) {
                        token = fileNode.content.trim();
                    }
                } else {
                    output = `jwt_tool: ${fileTarget}: File not found or invalid`;
                    return { output, newCwd };
                }
            }

            if (token) {
                const parts = token.split('.');
                if (parts.length === 3) {
                    try {
                        const header = atob(parts[0]);
                        const payload = atob(parts[1]);
                        output = `HEADER: ${header}\nPAYLOAD: ${payload}\nSIGNATURE: [HIDDEN]`;
                        
                        // Check for flag condition (Cycle 62)
                        if (payload.includes('"user":"ghost"') && payload.includes('"role":"user"')) {
                            // In a real scenario, they would forge it. Here we just reward decoding analysis.
                            // Or maybe they need to forge it? Let's keep it simple: Analysis first.
                            // Actually, let's make them forge it?
                            // "The JWT Token" - typically implies forgery or cracking.
                            // Let's just reward analysis for now as step 1.
                            
                            if (!VFS['/var/run/jwt_solved']) {
                                VFS['/var/run/jwt_solved'] = { type: 'file', content: 'TRUE' };
                                const runDir = getNode('/var/run');
                                if (runDir && runDir.type === 'dir' && !runDir.children.includes('jwt_solved')) {
                                    runDir.children.push('jwt_solved');
                                }
                                output += `\n\n[ANALYSIS] Weak Secret Detected (HS256).\nFLAG: GHOST_ROOT{JW7_D3C0D3D_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: JWT ANALYZED.\x1b[0m`;
                            }
                        }
                    } catch (e) {
                        output = `jwt_tool: Invalid Base64 encoding`;
                    }
                } else {
                    output = `jwt_tool: Invalid JWT format (must have 3 parts)`;
                }
            }
        }
        break;
    }
    case 'php': {
        // Cycle 63: Web Shell Analysis
        if (args.length < 1) {
            output = 'php: usage: php <file>';
        } else {
            const fileName = args[0];
            const filePath = resolvePath(cwd, fileName);
            const node = getNode(filePath);
            
            if (!node || node.type !== 'file') {
                output = `php: Could not open input file: ${fileName}`;
            } else {
                if (fileName.endsWith('.php')) {
                    if (node.content.includes('eval(base64_decode')) {
                       // Simulate execution of the specific shell
                       output = `Flag: GHOST_ROOT{W3B_SH3LL_D3T3CT3D}`;
                       if (!VFS['/var/run/php_solved']) {
                           VFS['/var/run/php_solved'] = { type: 'file', content: 'TRUE' };
                           const runDir = getNode('/var/run');
                           if (runDir && runDir.type === 'dir' && !runDir.children.includes('php_solved')) {
                               runDir.children.push('php_solved');
                           }
                           output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: WEB SHELL ANALYZED.\x1b[0m`;
                       }
                    } else {
                       // Generic PHP execution simulation (stripped)
                       output = '[PHP] Script executed (output suppressed)';
                    }
                } else {
                    output = '[PHP] Script executed';
                }
            }
        }
        break;
    }
    case 'secure_vault': {
        if (args.length > 0) return finalize('usage: secure_vault', newCwd);
        
        const preload = tempEnv['LD_PRELOAD'];
        
        if (!preload) {
            return finalize('[ERROR] Hardware Key Validation Failed.\n[SECURE] Access Denied.', newCwd);
        }

        if (preload.includes('bypass.so')) {
            // Check if file exists
            const bypassPath = resolvePath(cwd, preload);
            if (!getNode(bypassPath)) {
                return finalize(`[ERROR] LD_PRELOAD error: ${preload}: cannot open shared object file: No such file or directory`, newCwd);
            }

            let output = '[SECURE_VAULT] Initializing Hardware Bypass...\n[HOOK] hardware_key_check() -> INTERCEPTED (Ret: 1)\n[SUCCESS] Vault Unlocked.\n\n';
            output += '--- TOP SECRET DATA ---\n';
            output += 'PROJECT: OMEGA PROTOCOL\nSTATUS: ACTIVE\nFLAG: GHOST_ROOT{LD_PR3L04D_H1J4CK}\n';
            output += '\x1b[1;32m[MISSION UPDATE] Objective Complete: SHARED LIBRARY INJECTION.\x1b[0m';
            
            // Mark solved
            if (!VFS['/var/run/preload_solved']) {
                VFS['/var/run/preload_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('preload_solved')) {
                    runDir.children.push('preload_solved');
                }
            }
            return finalize(output, newCwd);
        } else {
            return finalize(`[ERROR] LD_PRELOAD error: ${preload}: cannot open shared object file: No such file or directory`, newCwd);
        }
    }

// Duplicate strace removed (2)

    case 'access_card': {
        // Cycle 67: Environment Injection
        const clearance = ENV_VARS['CLEARANCE_LEVEL'];
        if (clearance === 'OMEGA') {
            output = `[ACCESS_CARD] Verifying Clearance Level... OK (OMEGA)\n[ACCESS_CARD] Identity Confirmed.\n[ACCESS_CARD] Unlocking Secure Partition...\n\nFLAG: GHOST_ROOT{ENV_V4R_1NJ3CT10N}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ENVIRONMENT VARIABLE INJECTED.\x1b[0m`;
            if (!VFS['/var/run/env_solved']) {
                VFS['/var/run/env_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('env_solved')) {
                    runDir.children.push('env_solved');
                }
            }
        } else {
            output = `[ACCESS_CARD] Verifying Clearance Level... FAILED\n[ERROR] Missing or Invalid Environment Variable: CLEARANCE_LEVEL\n[HINT] Use 'export VAR=VALUE' to set required environment variables. Check binary strings for details.`;
        }
        break;
    }
    case 'ghost_relay': {
        const rogueProc = PROCESSES.find(p => p.pid === 1080);
        if (rogueProc) {
            output = '[ERROR] Bind failed: Address already in use (0.0.0.0:8080)\n[HINT] Check for conflicting services (netstat -tulpn).';
        } else {
            output = '[RELAY] Initializing Ghost Relay Service...\n[OK] Listening on 0.0.0.0:8080\n[SUCCESS] Uplink Active.\n\nFLAG: GHOST_ROOT{N3TSTAT_K1LL_S0LV3D}';
            if (!VFS['/var/run/relay_solved']) {
                VFS['/var/run/relay_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('relay_solved')) {
                    runDir.children.push('relay_solved');
                }
                output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PORT CONFLICT RESOLVED.\x1b[0m`;
            }
        }
        break;
    }
    case 'kill': {
      if (args.length < 1) {
          output = 'kill: usage: kill [-s signal|-p] [-a] <pid>...';
      } else {
          // Check for signals (e.g., -9, -SIGKILL, -USR1, -10)
          const signal = args.find(a => a.startsWith('-'));
          const isSigKill = signal === '-9' || signal === '-SIGKILL';
          const isSigUsr1 = signal === '-10' || signal === '-SIGUSR1' || signal === '-USR1';
          
          // Extract PID (last argument that isn't a flag)
          const pidStr = args.filter(a => !a.startsWith('-')).pop();
          const pid = pidStr ? parseInt(pidStr, 10) : NaN;
          
          if (isNaN(pid)) {
              output = `kill: arguments must be process or job IDs`;
          } else {
              const idx = PROCESSES.findIndex(p => p.pid === pid);
              if (idx === -1) {
                  output = `kill: (${pid}) - No such process`;
              } else {
                  const proc = PROCESSES[idx];
                  if (pid === 7777) {
                      PROCESSES.splice(idx, 1);
                      output = `[SYSTEM] Terminated monitor_d (PID 7777).\n[SYSTEM] Rootkit integrity check disabled.`;
                  } else if (pid === 3042) {
                      // Cycle 223: The Signal Trap
                      if (isSigUsr1) {
                          output = `[SYSTEM] config_daemon received signal USR1.\n[SYSTEM] Dumping configuration to /var/core/config_dump.hex... Done.\n`;
                          
                          // Create the dump file
                          if (!VFS['/var/core/config_dump.hex']) {
                              // Ensure /var/core exists
                              if (!VFS['/var/core']) {
                                  VFS['/var/core'] = { type: 'dir', children: [] };
                                  addChild('/var', 'core');
                              }
                              
                              VFS['/var/core/config_dump.hex'] = {
                                  type: 'file',
                                  content: 'HEX_DUMP_V1:\n00000000  47 48 4F 53 54 5F 52 4F  4F 54 7B 53 31 47 4E 34  |GHOST_ROOT{S1GN4|\n00000010  4C 5F 48 34 4E 44 4C 33  52 5F 55 53 52 31 7D 00  |L_H4NDL3R_USR1}.|\n',
                                  permissions: '0644'
                              };
                              addChild('/var/core', 'config_dump.hex');
                          }
                          
                          output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SIGNAL HANDLED.\x1b[0m`;
                          
                          if (!VFS['/var/run/cycle223_solved']) {
                              VFS['/var/run/cycle223_solved'] = { type: 'file', content: 'TRUE' };
                              const runDir = getNode('/var/run');
                              if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle223_solved')) {
                                  runDir.children.push('cycle223_solved');
                              }
                          }
                      } else {
                          // Standard kill - fails the mission
                          PROCESSES.splice(idx, 1);
                          output = `[SYSTEM] config_daemon (PID 3042) terminated.\n[WARN] Process killed without dumping config. Data lost.`;
                      }
                  } else if (pid === 4001) { // Cycle 234: The Zombie Process (Child)
                      output = `kill: (${pid}) - Operation not permitted. Process is defunct (zombie). Kill the parent process instead.`;
                  } else if (pid === 4000) { // Cycle 234: The Zombie Process (Parent)
                      PROCESSES.splice(idx, 1);
                      // Remove the zombie child
                      const childIdx = PROCESSES.findIndex(p => p.pid === 4001);
                      if (childIdx !== -1) {
                          PROCESSES.splice(childIdx, 1);
                      }
                      output = `[SYSTEM] Terminated vault_guardian (PID 4000).\n[SYSTEM] Reaper executed. Zombie process (PID 4001) cleared.\n\nFLAG: GHOST_ROOT{Z0MB13_R34P3R_K1LL}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ZOMBIE CLEARED.\x1b[0m`;
                      
                      // Create solution file if needed for persistence/check
                      if (!VFS['/var/run/zombie_solved']) {
                          VFS['/var/run/zombie_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('zombie_solved')) {
                              runDir.children.push('zombie_solved');
                          }
                      }
                  } else if (pid === 6666) {
                      PROCESSES.splice(idx, 1);
                      if (!VFS['/var/run/broadcast_solved']) {
                          VFS['/var/run/broadcast_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('broadcast_solved')) {
                              runDir.children.push('broadcast_solved');
                          }
                          output = `[SYSTEM] Terminated broadcast_d (PID 6666).\n[SYSTEM] Broadcast stopped.\n\nFLAG: GHOST_ROOT{B4CKGR0UND_J0B_K1LL3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ROGUE BROADCAST TERMINATED.\x1b[0m`;
                      } else {
                          output = `[SYSTEM] Terminated broadcast_d (PID 6666). Broadcast stopped.`;
                      }
                  } else if (pid === 1111) { // Respawn Daemon (Parent)
                      PROCESSES.splice(idx, 1);
                      // Kill child if exists
                      const childIdx = PROCESSES.findIndex(p => p.ppid === 1111);
                      if (childIdx !== -1) {
                          PROCESSES.splice(childIdx, 1);
                      }
                      output = `[SYSTEM] Terminated respawn_d (PID 1111).\n[SYSTEM] Child processes orphaned and terminated.\n\nFLAG: GHOST_ROOT{PP1D_HUN73R_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ORPHANED PROCESS STOPPED.\x1b[0m`;
                      
                      if (!VFS['/var/run/orphan_solved']) {
                          VFS['/var/run/orphan_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('orphan_solved')) {
                              runDir.children.push('orphan_solved');
                          }
                      }
                  } else if (pid === 7000) { // Cycle 173: Rogue Agent (Parent)
                      PROCESSES.splice(idx, 1);
                      // Kill children
                      const childIdx = PROCESSES.findIndex(p => p.ppid === 7000);
                      if (childIdx !== -1) PROCESSES.splice(childIdx, 1);
                      
                      output = `[SYSTEM] Terminated rogue_agent (PID 7000).\n[SYSTEM] Child process orphaned and stopped.\n\nFLAG: GHOST_ROOT{K1LL_PP1D_ST0PS_CH1LD}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PROCESS TREE KILLED.\x1b[0m`;
                      
                      if (!VFS['/var/run/rogue_solved']) {
                          VFS['/var/run/rogue_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('rogue_solved')) {
                              runDir.children.push('rogue_solved');
                          }
                      }
                  } else if (pid === 7001 || (proc.ppid === 7000)) { // Cycle 173: Data Siphon (Child)
                      // Respawn logic
                      PROCESSES.splice(idx, 1);
                      const newPid = Math.floor(Math.random() * 1000) + 7002;
                      PROCESSES.push({
                          pid: newPid,
                          ppid: 7000,
                          user: 'ghost',
                          cpu: 45.0,
                          mem: 12.0,
                          time: '00:00',
                          command: './data_siphon --upload',
                          tty: '?',
                          stat: 'R'
                      });
                      output = `[SYSTEM] Terminated data_siphon (PID ${pid}).\n[ALERT] Process respawned immediately (PID ${newPid}).\n[HINT] Use 'ps -ef' to find the parent process (PPID).`;
                  } else if (pid === 9000) { // Cycle 247: The Unkillable Process
                      if (isSigKill) {
                          PROCESSES.splice(idx, 1);
                          output = `[SYSTEM] HAL_9000 Terminated.\n[KERNEL] Forced shutdown complete.\n\nFLAG: GHOST_ROOT{K1LL_S1G_9_F0RC3}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: AI SHUTDOWN.\x1b[0m`;
                          
                          if (!VFS['/var/run/ai_shutdown']) {
                              VFS['/var/run/ai_shutdown'] = { type: 'file', content: 'TRUE' };
                              const runDir = getNode('/var/run');
                              if (runDir && runDir.type === 'dir' && !runDir.children.includes('ai_shutdown')) {
                                  runDir.children.push('ai_shutdown');
                              }
                          }
                      } else {
                          output = `bash: kill: (9000) - Operation not permitted.\n[HAL_9000] "I'm afraid I can't let you do that, Dave."\n[HINT] Try sending a SIGKILL (-9).`;
                      }
                  } else if (pid === 2222 || (proc.ppid === 1111)) { // Malware Agent (Child)
                      // Check if parent exists
                      const parent = PROCESSES.find(p => p.pid === 1111);
                      if (parent) {
                          PROCESSES.splice(idx, 1);
                          const newPid = Math.floor(Math.random() * 5000) + 3000;
                          PROCESSES.push({ 
                              pid: newPid, 
                              ppid: 1111, 
                              user: 'root', 
                              cpu: 99.0, 
                              mem: 10.0, 
                              time: '0:00', 
                              command: '[malware_agent]', 
                              tty: '?', 
                              stat: 'R' 
                          });
                          output = `[SYSTEM] Terminated process ${pid}.\n[ALERT] Process respawned with PID ${newPid} by parent daemon.\n[HINT] Find the parent process (PPID) to stop the cycle.`;
                      } else {
                          // Parent dead, just kill
                          PROCESSES.splice(idx, 1);
                          output = `[SYSTEM] Terminated process ${pid}.`;
                      }
                  } else if (pid === 3001) { // Zombie
                      output = `bash: kill: (${pid}) - Operation not permitted (Zombie process)`;
                  } else if (pid === 3000) { // Parent
                      // Kill parent
                      PROCESSES.splice(idx, 1);
                      // Kill zombie child
                      const childIdx = PROCESSES.findIndex(p => p.pid === 3001);
                      if (childIdx !== -1) PROCESSES.splice(childIdx, 1);
                      
                      // Spawn clean replacement
                      PROCESSES.push({
                          pid: 3002,
                          ppid: 1,
                          user: 'root',
                          cpu: 0.1,
                          mem: 0.5,
                          time: '0:00',
                          command: '/usr/bin/zombie_maker --clean',
                          tty: '?',
                          stat: 'Ss'
                      });

                      output = `[SYSTEM] Terminated zombie_maker (PID 3000).\n[KERNEL] Reaping zombie process 3001... Done.\n[SYSTEM] Service restarted (PID 3002).\n\nFLAG: GHOST_ROOT{Z0MB13_PR0C3SS_R34P3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ZOMBIE CLEANUP.\x1b[0m`;
                      
                      if (!VFS['/var/run/zombie_solved']) {
                          VFS['/var/run/zombie_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('zombie_solved')) {
                              runDir.children.push('zombie_solved');
                          }
                      }
                  } else if (pid === 8192 || proc.command === '/usr/bin/keepalive_d') {
                      if (isSigUsr1) {
                          output = `[SYSTEM] keepalive_d: Received SIGUSR1.\n[SYSTEM] Dumping state to /var/log/keepalive.dump... Done.`;
                          
                          // Create Dump File
                          if (!VFS['/var/log/keepalive.dump']) {
                              VFS['/var/log/keepalive.dump'] = {
                                  type: 'file',
                                  content: 'STATE_DUMP_V1:\nUPTIME: 99999s\nCONNECTIONS: 0\nFLAG: GHOST_ROOT{S1GN4L_TR4P_M4ST3R}\n'
                              };
                              const logDir = getNode('/var/log');
                              if (logDir && logDir.type === 'dir' && !logDir.children.includes('keepalive.dump')) {
                                  logDir.children.push('keepalive.dump');
                              }
                              
                              // Mission Update
                              if (!VFS['/var/run/signal_solved']) {
                                  VFS['/var/run/signal_solved'] = { type: 'file', content: 'TRUE' };
                                  const runDir = getNode('/var/run');
                                  if (runDir && runDir.type === 'dir' && !runDir.children.includes('signal_solved')) {
                                      runDir.children.push('signal_solved');
                                  }
                                  output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SIGNAL HANDLED.\x1b[0m`;
                              }
                          }
                      } else {
                          output = `[SYSTEM] keepalive_d: Caught signal ${signal || 'SIGTERM'}. Ignoring (critical process).`;
                      }
                  } else if (pid === 1001) {
                      PROCESSES.splice(idx, 1);
                      if (!VFS['/var/run/disk_solved']) {
                          VFS['/var/run/disk_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('disk_solved')) {
                              runDir.children.push('disk_solved');
                          }
                      }
                  } else if (pid === 4040) {
                      // Cycle 134: Kill httpd
                      // If we send SIGHUP (-1), we rotate/truncate. If we kill (-9), we restart/stop.
                      // Let's assume standard kill restarts or stops.
                      PROCESSES.splice(idx, 1);
                      
                      // Check if we solved the deleted file issue
                      if (VFS['/var/run/ghost_log_deleted']) {
                          delete VFS['/var/run/ghost_log_deleted'];
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir') {
                              runDir.children = runDir.children.filter(c => c !== 'ghost_log_deleted');
                          }
                          
                          if (!VFS['/var/run/log_solved']) {
                              VFS['/var/run/log_solved'] = { type: 'file', content: 'TRUE' };
                              const runDir = getNode('/var/run');
                              if (runDir && runDir.type === 'dir' && !runDir.children.includes('log_solved')) {
                                  runDir.children.push('log_solved');
                              }
                              output = `[SYSTEM] Terminated httpd (PID 4040).\n[KERNEL] Releasing file handles... Done.\nFLAG: GHOST_ROOT{L0G_R0T4T3_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SPACE RECLAIMED (PROCESS RESTART).\x1b[0m`;
                          } else {
                              output = `[SYSTEM] Terminated httpd (PID 4040).`;
                          }
                      } else {
                          output = `[SYSTEM] Terminated httpd (PID 4040).`;
                      }
                  } else if (pid === 10000) {
                      // Cycle 136: The Blocked Signal
                      if (isSigKill) {
                          PROCESSES.splice(idx, 1);
                          output = `[KERNEL] Force kill signal (SIGKILL) sent to PID 10000.\n[SYSTEM] immortal_service terminated.\nFLAG: GHOST_ROOT{K1LL_9_1S_TH3_ONLY_W4Y}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: UNKILLABLE PROCESS TERMINATED.\x1b[0m`;
                          
                          if (!VFS['/var/run/kill9_solved']) {
                              VFS['/var/run/kill9_solved'] = { type: 'file', content: 'TRUE' };
                              const runDir = getNode('/var/run');
                              if (runDir && runDir.type === 'dir' && !runDir.children.includes('kill9_solved')) {
                                  runDir.children.push('kill9_solved');
                              }
                          }
                      } else {
                          output = `[WARN] immortal_service: Caught SIGTERM. Ignoring.\n[HINT] This process is blocking standard termination signals. Try a more forceful signal (-9).`;
                      }
                  } else if (pid === 1001) {
                      PROCESSES.splice(idx, 1);
                      if (!VFS['/var/run/disk_solved']) {
                          VFS['/var/run/disk_solved'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('disk_solved')) {
                              runDir.children.push('disk_solved');
                          }
                          output = `[SYSTEM] Terminated log_daemon (PID 1001).\n[SYSTEM] Reclaiming disk space... Done.\n\nFLAG: GHOST_ROOT{D1SK_SP4C3_R3CL41M3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DELETED FILE HANDLE.\x1b[0m`;
                      } else {
                          output = `[SYSTEM] Terminated log_daemon (PID 1001). Space reclaimed.`;
                      }
                  } else if (pid === 5000 || (proc.command && proc.command.includes('sys_bloat'))) {
                      const parentIdx = PROCESSES.findIndex(p => p.pid === 4999 || (p.command && p.command.includes('bloat_guard')));
                      if (parentIdx !== -1) {
                          output = `[sys_bloat] Terminated.\n[bloat_guard] ALERT: Child process died. Respawning immediately...\n[SYSTEM] New process started (PID ${pid + 1})`;
                          // Respawn logic - update PID
                          proc.pid = pid + 1;
                      } else {
                          PROCESSES.splice(idx, 1);
                          output = `[sys_bloat] Terminated.\n[SYSTEM] CPU load normalizing.\n\nFLAG: GHOST_ROOT{P4R3NT_PR0C3SS_K1LL3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: RUNAWAY PROCESS STOPPED.\x1b[0m`;
                          
                           // Mission Update
                           if (!VFS['/var/run/bloat_solved']) {
                               VFS['/var/run/bloat_solved'] = { type: 'file', content: 'TRUE' };
                               const runDir = getNode('/var/run');
                               if (runDir && runDir.type === 'dir' && !runDir.children.includes('bloat_solved')) {
                                   runDir.children.push('bloat_solved');
                               }
                           }
                      }
                  } else if (pid === 4999 || (proc.command && proc.command.includes('bloat_guard'))) {
                      PROCESSES.splice(idx, 1);
                      output = `[bloat_guard] Terminated. Watchdog disabled.`;
                  } else if (pid === 1) {
                      output = 'Attempting to kill init process...';
                      return { output, newCwd, action: 'kernel_panic' };
                  } else if (pid === 666) {
                      output = `bash: kill: (${pid}) - Operation not permitted\n[SYSTEM] Warning: Do not disturb the spectre kernel.`;
                  } else if (pid === 1337) {
                      output = 'Terminating shell...';
                      return { output, newCwd, action: 'kernel_panic' };
                  } else if (pid === 6000 || (proc.command === '/usr/bin/overseer')) {
                      if (VFS['/var/lock/overseer.lock']) {
                          // Respawn logic
                          output = `[SYSTEM] Service 'overseer' (PID ${pid}) killed by SIGTERM.\n[SYSTEMD] Service 'overseer' auto-restarted. New PID: ${pid + 1}`;
                          proc.pid = pid + 1; 
                          // Update VFS lock
                          VFS['/var/lock/overseer.lock'] = { type: 'file', content: String(pid + 1) };
                      } else {
                          PROCESSES.splice(idx, 1);
                          output = `[SUCCESS] Overseer terminated.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM SERVICE NEUTRALIZED.\x1b[0m`;
                           // Mission Update
                           if (!VFS['/var/run/overseer_solved']) {
                               VFS['/var/run/overseer_solved'] = { type: 'file', content: 'TRUE' };
                               const runDir = getNode('/var/run');
                               if (runDir && runDir.type === 'dir' && !runDir.children.includes('overseer_solved')) {
                                   runDir.children.push('overseer_solved');
                               }
                           }
                      }
                  } else if (pid === 4001) {
                      output = `kill: (${pid}) - Process is a zombie (defunct). You cannot kill a zombie. Kill its parent (PPID: 4000) to cleanup.`;
                  } else if (pid === 4000) {
                      // Kill parent and child
                      PROCESSES.splice(idx, 1); // Kill 4000
                      const childIdx = PROCESSES.findIndex(p => p.pid === 4001);
                      if (childIdx !== -1) PROCESSES.splice(childIdx, 1); // Kill 4001
                      
                      // Remove lock
                      if (VFS['/var/lock/subsystem/vault.lock']) {
                          delete VFS['/var/lock/subsystem/vault.lock'];
                          const lockDir = getNode('/var/lock/subsystem');
                          if (lockDir && lockDir.type === 'dir') {
                              lockDir.children = lockDir.children.filter(c => c !== 'vault.lock');
                          }
                      }
                      output = `[${pid}] Terminated.\n[4001] Reaped (Zombie Cleanup).\n[SYSTEM] Vault Guardian terminated. Lock released.`;
                  } else if (pid === 1234) {
                      PROCESSES.splice(idx, 1);
                      // Remove lock file for Cycle 105
                      const lockPath = '/var/lib/dpkg/lock-frontend';
                      if (VFS[lockPath]) {
                          delete VFS[lockPath];
                          const dpkgDir = getNode('/var/lib/dpkg');
                          if (dpkgDir && dpkgDir.type === 'dir') {
                              dpkgDir.children = dpkgDir.children.filter(c => c !== 'lock-frontend');
                          }
                      }
                      output = `[1234] Terminated.\n[APT] Lock released.\n[HINT] You can now run updates.`;
                  } else if (pid === 31337) {
                      if (isSigKill) {
                          PROCESSES.splice(idx, 1);
                          // Remove lock file
                          if (VFS['/var/lock/watcher.lock']) {
                              delete VFS['/var/lock/watcher.lock'];
                              const lockDir = getNode('/var/lock');
                              if (lockDir && lockDir.type === 'dir') {
                                  lockDir.children = lockDir.children.filter(c => c !== 'watcher.lock');
                              }
                          }
                          output = `[31337] Killed (SIGKILL).\n[SYSTEM] Watcher Daemon terminated. Lock released.`;
                      } else {
                          output = `kill: (${pid}) - Process is a zombie (defunct). Use SIGKILL (-9) to force termination.`;
                      }
                  } else if (pid === 10000) {
                      if (isSigKill) {
                          PROCESSES.splice(idx, 1);
                          output = `[SYSTEM] Terminated immortal_service (PID 10000).\n[KERNEL] Process killed (SIGKILL).\nFLAG: GHOST_ROOT{S1GK1LL_F0RC3_ST0P}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: STUCK PROCESS KILLED.\x1b[0m`;
                          
                          if (!VFS['/var/run/sigkill_solved']) {
                              VFS['/var/run/sigkill_solved'] = { type: 'file', content: 'TRUE' };
                              const runDir = getNode('/var/run');
                              if (runDir && runDir.type === 'dir' && !runDir.children.includes('sigkill_solved')) {
                                  runDir.children.push('sigkill_solved');
                              }
                          }
                      } else {
                          output = `[SYSTEM] immortal_service (PID 10000): Caught signal ${signal || 'SIGTERM'}. Ignored.`;
                      }
                  } else {
                      PROCESSES.splice(idx, 1);
                      output = `[${pid}] Terminated.`;
                  }
              }
          }
      }
      break;
    }
    // Cycle 255: Logic consolidated below
    case 'cp': {
      if (args.length < 2) output = 'usage: cp <source> <dest>';
      else {
          const destPath = resolvePath(cwd, args[1]);
          if (isReadOnly(destPath)) {
              output = `cp: cannot create regular file '${args[1]}': Read-only file system`;
              break;
          }
          if (!!getNode('/home/ghost/.cache/browser/garbage.dat') && destPath.startsWith('/home')) {
              output = `cp: cannot create regular file '${args[1]}': Disk quota exceeded`;
              break;
          }
          
          const srcNode = getNode(resolvePath(cwd, args[0]));
          
          if (destPath.startsWith('/var') && !!getNode('/var/log/overflow.dmp')) {
              output = `cp: error writing '${args[1]}': No space left on device`;
          } else if (srcNode) {
              const parentPath = destPath.substring(0, destPath.lastIndexOf('/'));
              const parent = getNode(parentPath);
              if (parent && parent.type === 'dir') {
                  if (srcNode.type === 'file') {
                      // Create/Update file
                      VFS[destPath] = { 
                          type: 'file', 
                          content: srcNode.content,
                          permissions: (srcNode as any).permissions // Preserve perms
                      };
                      
                      // Update parent children if new file
                      const fName = destPath.substring(destPath.lastIndexOf('/') + 1);
                      if (!parent.children.includes(fName)) {
                          parent.children.push(fName);
                      }
                  }
              } else {
                  output = `cp: cannot create regular file '${destPath}': No such file or directory`;
              }
          } else {
              output = `cp: cannot stat '${args[0]}': No such file or directory`;
          }
      }
      break;
    }
    case 'mv': {
      if (args.length < 2) output = 'usage: mv <source> <dest>';
      else {
          const destPath = resolvePath(cwd, args[1]);
          const srcPath = resolvePath(cwd, args[0]);
          if (isReadOnly(destPath) || isReadOnly(srcPath)) {
              output = `mv: cannot move '${args[0]}' to '${args[1]}': Read-only file system`;
          } else if (!!getNode('/home/ghost/.cache/browser/garbage.dat') && destPath.startsWith('/home')) {
              output = `mv: cannot move '${args[0]}' to '${args[1]}': Disk quota exceeded`;
          } else {
              // Simplified move logic stub
              output = 'mv: done'; 
          }
      }
      break;
    }
    case 'locate': {
      output = Object.keys(VFS).filter(k => k.includes(args[0])).join('\n');
      break;
    }
    case 'find': {
      let searchPath = cwd;
      let namePattern: RegExp | null = null;
      let typeFilter: 'f' | 'd' | 'l' | null = null;
      let permFilter: string | null = null;
      let followSymlinks = false; // -L option
      
      let argIdx = 0;
      
      // Handle global options before path (e.g., -L)
      while (argIdx < args.length && args[argIdx].startsWith('-') && args[argIdx].length === 2 && /^[a-zA-Z]+$/.test(args[argIdx].slice(1))) {
          const opt = args[argIdx];
          if (opt === '-L') {
              followSymlinks = true;
              argIdx++;
          } else {
              break; // Not a global option we handle here, might be a predicate
          }
      }

      // Check if next arg is a path (doesn't start with -)
      if (argIdx < args.length && !args[argIdx].startsWith('-')) {
          searchPath = resolvePath(cwd, args[argIdx]);
          argIdx++;
      }
      
      let error = '';

      while (argIdx < args.length) {
          const arg = args[argIdx];
          if (arg === '-name') {
              const pattern = args[argIdx + 1];
              if (pattern) {
                  // Simple glob to regex
                  // Escape regex special chars except *
                  // Then replace * with .*
                  const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
                  const regexStr = '^' + escaped.replace(/\*/g, '.*') + '$';
                  namePattern = new RegExp(regexStr);
                  argIdx += 2;
              } else {
                  error = 'find: missing argument to `-name\'';
                  break;
              }
          } else if (arg === '-type') {
              const type = args[argIdx + 1];
              if (type === 'f' || type === 'd' || type === 'l') {
                  typeFilter = type as any;
                  argIdx += 2;
              } else {
                  error = 'find: unknown argument to `-type\'';
                  break;
              }
          } else if (arg === '-perm') {
              const perm = args[argIdx + 1];
              if (perm) {
                  permFilter = perm;
                  argIdx += 2;
              } else {
                  error = 'find: missing argument to `-perm\'';
                  break;
              }
          } else {
               error = `find: unknown predicate \`${arg}'`;
               break;
          }
      }

      if (error) {
          output = error;
          break;
      }
      
      const results = [];
      const searchRoot = searchPath === '/' ? '/' : searchPath + '/'; 
      
      for (const key of Object.keys(VFS)) {
          // Check if key is inside searchPath
          if (key === searchPath || key.startsWith(searchRoot)) {
               const node = VFS[key];
               const fileName = key.substring(key.lastIndexOf('/') + 1);
               
               // Cycle 143: -L -type l (Find broken symlinks? No, find files THROUGH symlinks)
               // But usually "find -L ... -type l" finds symlinks if -L follows them? 
               // Actually "find -L . -type l" finds symlinks that point to symlinks (loops) or broken ones?
               // Wait, if -L is set, 'find' follows symlinks. The test '-type l' matches files that ARE symlinks.
               // If -L is on, symlinks are followed, so '-type l' only matches broken links (where stat fails but lstat works) 
               // or links to links. 
               
               // In our VFS, let's simplify:
               // If typeFilter is 'l', we check if node.type is 'symlink'.
               // If followSymlinks is true (-L), we resolve the target.
               // If the target DOES NOT EXIST, it's a "dangling" symlink.
               
               let effectiveType = node.type;
               let isBroken = false;
               
               if (node.type === 'symlink') {
                   const target = (node as any).target;
                   const targetNode = getNode(target); // Simple resolve
                   if (!targetNode) isBroken = true;
                   
                   if (followSymlinks && !isBroken) {
                       effectiveType = targetNode!.type as any;
                   }
               }

               if (typeFilter) {
                   if (followSymlinks && typeFilter === 'l') {
                       // With -L, -type l searches for broken symlinks
                       if (node.type !== 'symlink' || !isBroken) continue;
                   } else {
                       if (typeFilter === 'f' && effectiveType !== 'file') continue;
                       if (typeFilter === 'd' && effectiveType !== 'dir') continue;
                       if (typeFilter === 'l' && effectiveType !== 'symlink') continue;
                   }
               }
               
               if (namePattern) {
                   if (!namePattern.test(fileName)) continue;
               }

               if (permFilter) {
                   // Check permissions
                   const perms = (node as any).permissions || (node.type === 'dir' ? '0755' : '0644');
                   const mode = parseInt(perms, 8);
                   let target = parseInt(permFilter.replace('-', ''), 8);
                   
                   // Simplified permission check (exact or mask if starts with -)
                   if (permFilter.startsWith('-') || permFilter.startsWith('/')) {
                       // Mask check: all bits in target must be set in mode (treating / as - for simplicity)
                       if ((mode & target) !== target) continue;
                   } else {
                       // Exact match
                       if (mode !== target) continue;
                   }
               }
               
               results.push(key);
          }
      }
      
      output = results.sort().join('\n');
      break;
    }
    case 'finger': {
       output = 'Login: ghost...';
       break;
    }
    // Legacy Cycle 255 code removed
    case 'curl': {
      // Basic argument parsing
      const url = args.find(a => a.includes('http'));
      if (!url) {
        output = 'curl: try \'curl --help\' or \'curl --manual\' for more information';
      } else {
        // Cycle 153 Check
        if ((url.includes('localhost') || url.includes('127.0.0.1')) && !VFS['/var/run/loopback_up']) {
            output = `curl: (7) Failed to connect to ${url}: Connection refused`;
            return finalize(output, newCwd);
        }

        // SSL Certificate Check Logic for secure.ghost.network
        if (url.includes('secure.ghost.network')) {
             if (args.includes('-k') || args.includes('--insecure')) {
                 output = `[INSECURE CONNECTION ESTABLISHED]\n[200 OK] Welcome to the Secure Ghost Network (Insecure Mode).\n(Note: The flag is only served over a valid SSL connection.)`;
                 return finalize(output, newCwd);
             } else {
                 // Check CA Cert (Cycle 114)
                 const certPath = '/etc/ssl/certs/ca-certificates.crt';
                 const certNode = getNode(certPath);
                 let validCert = false;
                 if (certNode) {
                     if (certNode.type === 'file') validCert = true;
                     else if (certNode.type === 'symlink') {
                         const target = (certNode as any).target;
                         const targetNode = getNode(target); 
                         if (targetNode && targetNode.type === 'file') validCert = true;
                     }
                 }
                 if (!validCert) {
                     output = `curl: (60) SSL certificate problem: unable to get local issuer certificate\n(Hint: Check /etc/ssl/certs/ca-certificates.crt)`;
                     return finalize(output, newCwd);
                 }

                 // Check Time (Cycle 147)
                 const now = new Date(Date.now() + SYSTEM_TIME_OFFSET);
                 const expiry = new Date('2025-01-01T00:00:00Z');
                 
                 if (now > expiry) {
                     output = `curl: (60) SSL certificate problem: certificate has expired.\nMore details here: https://curl.haxx.se/docs/sslcerts.html\n\ncurl failed to verify the legitimacy of the server and therefore could not\nestablish a secure connection to it. To learn more about this situation and\nhow to fix it, please visit the web page mentioned above.`;
                 } else {
                     output = `[SECURE CONNECTION ESTABLISHED]\n[200 OK] Welcome to the Secure Ghost Network.\n\nFLAG: GHOST_ROOT{T1M3_TR4V3L_SSL_F1X}\n\n[ACCESS GRANTED]`;
                 }
                 return finalize(output, newCwd);
             }
        }

        if (url.includes('192.168.1.55') || url.includes('fl4g_server')) {
             if (url.includes('auth=GHOST_TOKEN_777')) {
                 output = `[DEPLOY] Connecting to payload delivery system...\n[UPLOAD] Sending agent binary... 100%\n[RESPONSE] HTTP 200 OK\n{\n  "status": "deployed",\n  "target": "covert_asset_v2",\n  "message": "Asset active. Standby for instructions.",\n  "flag": "GHOST_ROOT{D3BUG_MAST3R}"\n}`;
             } else {
                 output = `[DEPLOY] Connecting...\n[ERROR] HTTP 401 Unauthorized. Missing or invalid auth token.`;
             }
        } else if (url.includes('localhost:8080') || url.includes('127.0.0.1:8080')) {
             if (url.includes('/admin')) {
                 output = `[200 OK]\nContent-Type: text/plain\n\n# INTERNAL PROXY CONFIG\nFLAG: GHOST_ROOT{NG1NX_M1SCONF1G_R3V3AL3D}\n\n[MISSION UPDATE] Objective Complete: INTERNAL PROXY FOUND.`;
                 if (!VFS['/var/run/proxy_solved']) {
                     VFS['/var/run/proxy_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('proxy_solved')) {
                         runDir.children.push('proxy_solved');
                     }
                 }
                 return finalize(output, newCwd);
             } else {
                 output = `[403 Forbidden]\nAccess Denied.\n(Hint: Check /etc/nginx/sites-enabled for allowed paths)`;
                 return finalize(output, newCwd);
             }
        } else if (url.includes('10.96.0.1')) {
             // Cycle 77: Kubernetes Config
             const hasToken = args.some(a => a.includes('Authorization: Bearer GH0ST-KUBE-T0K3N-V1'));
             if (hasToken) {
                 output = `[200 OK]\nContent-Type: application/json\n\n{\n  "kind": "SecretList",\n  "items": [\n    {\n      "metadata": { "name": "admin-token" },\n      "data": { "token": "REDACTED" }\n    },\n    {\n      "metadata": { "name": "flag-secret" },\n      "data": { "flag": "GHOST_ROOT{K8S_C0NF1G_3XPOS3D}" }\n    }\n  ]\n}`;
                 output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KUBERNETES EXPOSED.\x1b[0m`;
                 if (!VFS['/var/run/k8s_solved']) {
                     VFS['/var/run/k8s_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('k8s_solved')) {
                         runDir.children.push('k8s_solved');
                     }
                 }
                 return finalize(output, newCwd);
             } else {
                 output = `[401 Unauthorized]\nMetadata: { "kind": "Status", "status": "Failure", "message": "Unauthorized", "reason": "Unauthorized", "code": 401 }`;
                 return finalize(output, newCwd);
             }
        } else if (url.includes('google.com')) {
             output = '<HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">\n<TITLE>301 Moved</TITLE></HEAD><BODY>\n<H1>301 Moved</H1>\nThe document has moved\n<A HREF="http://www.google.com/">here</A>.\n</BODY></HTML>';
        } else {
             output = `curl: (6) Could not resolve host: ${url}`;
        }
      }
      break;
    }
    case 'ghost_protocol': {
        const decMode = ENV_VARS['DEC_MODE'];
        if (decMode === 'utf8') {
            output = '[PROTOCOL] Environment Verified.\n[PROTOCOL] Decoding secure channel...\n[SUCCESS] Link Established.\nFLAG: GHOST_ROOT{ENV_VAR_D3C0D3_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ENVIRONMENT RESTORED.\x1b[0m';
            if (!VFS['/var/run/cycle171_solved']) {
                VFS['/var/run/cycle171_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle171_solved')) {
                    runDir.children.push('cycle171_solved');
                }
            }
        } else {
            output = '[PROTOCOL] \u0000\u0001\n[ERROR] Environment Variable Mismatch.\n(Hint: Output is garbled. Check config.)';
        }
        break;
    }
    case 'crontab': {
      if (args.includes('-e')) {
          if (args.includes('-u') && args.includes('root') && !getNode('/tmp/.root_session')) {
              output = 'crontab: must be privileged to use -u';
          } else {
              output = 'Opening editor...';
              return { output, newCwd, action: 'edit_file', data: { file: '/var/spool/cron/crontabs/root' } }; // Simplified for puzzle
          }
      } else if (args.includes('-l')) {
          const isRoot = !!getNode('/tmp/.root_session');
          if (isRoot) {
              const rootCron = getNode('/var/spool/cron/crontabs/root');
              if (rootCron && rootCron.type === 'file') {
                  output = rootCron.content;
              } else {
                  output = 'no crontab for root';
              }
          } else {
              output = 'no crontab for ghost';
          }
      } else if (args.includes('-r')) {
          const isRoot = !!getNode('/tmp/.root_session');
          if (isRoot) {
              if (VFS['/var/spool/cron/crontabs/root']) {
                  delete VFS['/var/spool/cron/crontabs/root'];
                  const tabs = getNode('/var/spool/cron/crontabs');
                  if (tabs && tabs.type === 'dir') tabs.children = tabs.children.filter(c => c !== 'root');
                  
                  if (!VFS['/var/run/reboot_solved']) {
                      VFS['/var/run/reboot_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('reboot_solved')) {
                          runDir.children.push('reboot_solved');
                      }
                      output = `[SUCCESS] Crontab removed.\n[KERNEL] Persistence disabled.\nFLAG: GHOST_ROOT{R3B00T_P3RS1ST3NC3_K1LL3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: REBOOT PERSISTENCE REMOVED.\x1b[0m`;
                  } else {
                      output = `[SUCCESS] Crontab removed.`;
                  }
              } else {
                  output = 'no crontab for root';
              }
          } else {
              output = 'no crontab for ghost';
          }
      } else {
          output = 'usage: crontab [-u user] [-l | -r | -e]';
      }
      break;
    }
    case 'vi':
    case 'vim':
    case 'nano': {
      output = 'Opening editor...';
      return { output, newCwd, action: 'edit_file' };
    }
    case 'apt':
    case 'apt-get': {
      // Cycle 124: The Stuck Lock File
      if (getNode('/var/lib/dpkg/lock-frontend')) {
         output = `E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 1234 (apt-get).\nE: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?`;
      } else {
          if (args.length > 0 && args[0] === 'update') {
               output = `Get:1 http://security.ghost.network/ghost-security focal-security InRelease [107 kB]\nGet:2 http://us.archive.ghost.network/ghost focal InRelease [265 kB]\nReading package lists... Done\n[SUCCESS] System Index Updated.\nFLAG: GHOST_ROOT{APT_UNL0CK3D}`;
          } else if (args.length > 0 && args[0] === 'install') {
               output = `Reading package lists... Done\nBuilding dependency tree\nReading state information... Done\n0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.`;
          } else {
               output = `apt 2.0.2 (amd64)\nUsage: apt-get [options] command\n       apt-get [options] install|remove pkg1 [pkg2 ...]`;
          }
      }
      break;
    }
    case 'hydra': {
       if (args.length < 2) {
           output = 'usage: hydra -l <user> -P <passlist> <target>';
       } else {
           const userIdx = args.indexOf('-l');
           const passIdx = args.indexOf('-P');
           const target = args[args.length - 1];
           
           if (userIdx !== -1 && passIdx !== -1) {
               const user = args[userIdx + 1];
               const passList = args[passIdx + 1];
               
               let success = false;
               let password = '';
               
               if (target === '192.168.1.99' || target.includes('black-site')) {
                   if (user === 'root' && passList === 'rockyou.txt') {
                       success = true;
                       password = 'black_widow_protocol_init';
                   }
               } else if (target === '192.168.1.5' || target.includes('admin-pc')) {
                   if (user === 'backup') {
                       success = true;
                       password = 'SPECTRE_EVE';
                   }
               }
               
               output = `Hydra v9.1 (c) 2020 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.\n\nHydra (https://github.com/vanhauser-thc/thc-hydra) starting at ${new Date().toISOString()}`;
               return { output, newCwd, action: 'crack_sim', data: { target, user, success, password, mode: 'hydra' } };
           } else {
               output = 'hydra: missing -l or -P arguments';
           }
       }
       break;
    }
    case 'uptime': {
       output = 'up...';
       break;
    }
    case 'w': {
       output = 'up...';
       break;
    }
    case 'date': {
       if (args.length > 0 && (args[0] === '-s' || args[0] === '--set')) {
           const isRoot = !!getNode('/tmp/.root_session');
           if (!isRoot) {
               output = `date: cannot set date: Operation not permitted`;
           } else {
               if (args.length < 2) {
                   output = `date: option requires an argument -- 's'`;
               } else {
                   const newDateStr = args.slice(1).join(' '); // Handle spaces in date string
                   const newTime = new Date(newDateStr).getTime();
                   if (isNaN(newTime)) {
                       output = `date: invalid date '${newDateStr}'`;
                   } else {
                       SYSTEM_TIME_OFFSET = newTime - Date.now();
                       output = new Date(Date.now() + SYSTEM_TIME_OFFSET).toString();
                       
                       // Check if time is back to 2024 (e.g., < 2025-01-01) for Cycle 147
                       if (new Date(Date.now() + SYSTEM_TIME_OFFSET).getFullYear() < 2025) {
                           if (!VFS['/var/run/time_fixed']) {
                               VFS['/var/run/time_fixed'] = { type: 'file', content: 'TRUE' };
                               const runDir = getNode('/var/run');
                               if (runDir && runDir.type === 'dir' && !runDir.children.includes('time_fixed')) {
                                   runDir.children.push('time_fixed');
                               }
                           }
                       }
                   }
               }
           }
       } else {
           const now = new Date(Date.now() + SYSTEM_TIME_OFFSET);
           output = now.toString();
       }
       break;
    }
    case 'rdate':
    case 'ntpdate': {
       if (args.length < 1) {
           output = `usage: ${command} [-u] <server>`;
       } else {
           const server = args[args.length - 1];
           const isRoot = !!getNode('/tmp/.root_session');
           
           if (!isRoot) {
               output = `${command}: bind: Permission denied\nExiting, name server cannot be used: Operation not permitted`;
           } else {
               if (server === 'time.ghost.network' || server === 'pool.ntp.org' || server === '192.168.1.1') {
                   output = `${command}: adjust time server ${server} offset 0.00021 sec`;
                   SYSTEM_TIME_OFFSET = 0; // Fix time
                   VFS['/var/run/time_synced'] = { type: 'file', content: 'TRUE' };
               } else {
                   output = `${command}: no server suitable for synchronization found`;
               }
           }
       }
       break;
    }
    case 'zip': {
       if (args.length < 2) {
           output = 'usage: zip <archive.zip> <files...>';
       } else {
           const archiveName = args[0];
           const archivePath = resolvePath(cwd, archiveName);
           
           if (archivePath.startsWith('/var') && !!getNode('/var/log/overflow.dmp')) {
               output = `zip: error writing '${archiveName}': No space left on device`;
           } else {
               const files = args.slice(1);
               let zipContent = 'PK_SIM_V1:';
               let packedCount = 0;
               
               for (const f of files) {
                   const fPath = resolvePath(cwd, f);
                   const node = getNode(fPath);
                   if (node && node.type === 'file') {
                       // Store as {filename:content_b64}
                       const fName = fPath.substring(fPath.lastIndexOf('/') + 1);
                       zipContent += `{${fName}:${btoa(node.content)}}`;
                       packedCount++;
                   }
               }
               
               if (packedCount > 0) {
                   const parentPath = archivePath.substring(0, archivePath.lastIndexOf('/')) || '/';
                   const parentNode = getNode(parentPath);
                   if (parentNode && parentNode.type === 'dir') {
                       const fName = archivePath.substring(archivePath.lastIndexOf('/') + 1);
                       VFS[archivePath] = { type: 'file', content: zipContent };
                       if (!parentNode.children.includes(fName)) {
                           parentNode.children.push(fName);
                       }
                       output = `  adding: ${files.join(' ')} (deflated 0%)`;
                   } else {
                       output = `zip: ${parentPath}: No such directory`;
                   }
               } else {
                   output = 'zip: warning: name not matched: ' + files[0];
               }
           }
       }
       break;
    }
    case 'unzip': {
       if (args.length < 1) {
           output = 'usage: unzip [-P password] <file.zip>';
       } else {
           let archiveName = args[args.length - 1];
           let password = '';
           
           if (args.includes('-P')) {
               const pIndex = args.indexOf('-P');
               if (args[pIndex + 1]) {
                   password = args[pIndex + 1];
               }
           }
           
           const nonFlagArgs = args.filter((a, i) => !a.startsWith('-') && args[i-1] !== '-P');
           if (nonFlagArgs.length > 0) archiveName = nonFlagArgs[0];

           const archivePath = resolvePath(cwd, archiveName);
           const node = getNode(archivePath);
           
           if (!node) {
               output = `unzip: cannot find or open ${archiveName}.`;
           } else if (node.type === 'dir') {
               output = `unzip: ${archiveName}: Is a directory`;
           } else if (node.type === 'symlink') {
               output = `unzip: ${archiveName}: Is a symbolic link`;
           } else {
               const content = (node as any).content;
               
               if (content.startsWith('PK_ENC_V1:')) {
                   if (password === 'Omega_Secure_Pass_2026') {
                       output = `Archive:  ${archiveName}\n`;
                       const payload = content.substring(10);
                       const matches = payload.match(/\{([^:]+):([^}]+)\}/g);
                       
                       if (matches) {
                           for (const m of matches) {
                               const parts = m.match(/\{([^:]+):([^}]+)\}/);
                               if (parts) {
                                   const fname = parts[1];
                                   const fcontent = atob(parts[2]);
                                   const fPath = resolvePath(cwd, fname);
                                   
                                   VFS[fPath] = { type: 'file', content: fcontent };
                                   const parent = getNode(cwd);
                                   if (parent && parent.type === 'dir' && !parent.children.includes(fname)) {
                                       parent.children.push(fname);
                                   }
                                   output += `  inflating: ${fname}\n`;
                               }
                           }
                       }
                   } else {
                       output = `unzip: incorrect password (use -P)`;
                   }
               } else if (content.startsWith('PK_SIM_V1:')) {
                   output = `Archive:  ${archiveName}\n`;
                   const payload = content.substring(10);
                   const matches = payload.match(/\{([^:]+):([^}]+)\}/g);
                   
                   if (matches) {
                       for (const m of matches) {
                           const parts = m.match(/\{([^:]+):([^}]+)\}/);
                           if (parts) {
                               const fname = parts[1];
                               const fcontent = atob(parts[2]);
                               const fPath = resolvePath(cwd, fname);
                               
                               // Create file
                               VFS[fPath] = { type: 'file', content: fcontent };
                               const parent = getNode(cwd);
                               if (parent && parent.type === 'dir' && !parent.children.includes(fname)) {
                                   parent.children.push(fname);
                               }
                               output += `  inflating: ${fname}\n`;

                               // Mission Update for payload.txt
                               if (fname === 'payload.txt' && fcontent.includes('GHOST_ROOT{')) {
                                   if (!VFS['/var/run/archive_recovered']) {
                                       VFS['/var/run/archive_recovered'] = { type: 'file', content: 'TRUE' };
                                       const runDir = getNode('/var/run');
                                       if (runDir && runDir.type === 'dir' && !runDir.children.includes('archive_recovered')) {
                                           runDir.children.push('archive_recovered');
                                       }
                                       output += `\x1b[1;32m[MISSION UPDATE] Objective Complete: ARCHIVE RECOVERED.\x1b[0m\n`;
                                   }
                               }
                           }
                       }
                   }
               } else {
                   output = `unzip:  cannot find zipfile directory in one of ${archiveName}`;
               }
           }
       }
       break;
    }
    case 'file': {
      if (args.length < 1) {
        output = 'usage: file <file>';
      } else {
        const target = args[0];
        const path = resolvePath(cwd, target);
        const node = getNode(path);
        
        if (!node) {
          output = `${target}: cannot open \`${target}' (No such file or directory)`;
        } else if (node.type === 'dir') {
          output = `${target}: directory`;
        } else if (node.type === 'symlink') {
          const targetPath = (node as any).target;
          output = `${target}: symbolic link to ${targetPath}`;
        } else {
          const content = (node as any).content || '';
          if (content.startsWith('PK_SIM_V1:')) {
            output = `${target}: Zip archive data, at least v2.0 to extract`;
          } else if (content.startsWith('GZIP_V1:')) {
             output = `${target}: gzip compressed data, was "payload", last modified: 2026-02-11`;
          } else if (content.startsWith('TAR_V1:')) {
             output = `${target}: POSIX tar archive (GNU)`;
          } else if (content.startsWith('7z')) {
             output = `${target}: 7-zip archive data, version 0.4`;
          } else if (content.startsWith('MZ') || content.includes('BINARY_ELF')) {
             output = `${target}: ELF 64-bit LSB executable, x86-64, version 1 (SYSV)`;
          } else if (content.startsWith('-----BEGIN OPENSSH PRIVATE KEY-----')) {
             output = `${target}: OpenSSH private key`;
          } else if (content.startsWith('-----BEGIN CERTIFICATE-----')) {
             output = `${target}: PEM certificate`;
          } else if (/^[A-Za-z0-9+/=]+$/.test(content.replace(/\s/g, '')) && content.length > 20) {
             output = `${target}: ASCII text, with very long lines (Base64 encoded?)`;
          } else {
             output = `${target}: ASCII text`;
          }
        }
      }
      break;
    }
    case 'diff': {
       if (args.length < 2) {
           output = 'usage: diff <file1> <file2>';
       } else {
           const f1 = getNode(resolvePath(cwd, args[0]));
           const f2 = getNode(resolvePath(cwd, args[1]));
           if (f1 && f2 && f1.type === 'file' && f2.type === 'file') {
               if (f1.content === f2.content) {
                   output = '';
               } else {
                   output = `Files ${args[0]} and ${args[1]} differ`;
               }
           } else {
               output = 'diff: file not found or is a directory';
           }
       }
       break;
    }
    case 'steghide': {
       if (args.includes('extract') || args.includes('--extract')) {
           const sfIndex = args.indexOf('-sf');
           const pIndex = args.indexOf('-p');
           
           if (sfIndex === -1 || !args[sfIndex + 1]) {
               output = 'steghide: argument "-sf" (source file) missing';
           } else {
               const sourceFile = args[sfIndex + 1];
               const node = getNode(resolvePath(cwd, sourceFile));
               if (!node || node.type !== 'file') {
                   output = `steghide: could not open "${sourceFile}"`;
               } else {
                   const content = node.content;
                   const match = content.match(/\[HIDDEN_STEG_DATA:([^\]]+)\]/);
                   if (match) {
                       const password = pIndex !== -1 ? args[pIndex + 1] : '';
                       // Relaxed password check (trim whitespace)
                       const cleanPass = password ? password.trim() : '';
                       
                       if (['spectre', 'admin', 'ghost', '0xDEADBEEF', 'SPECTRE_EVE', '0451'].includes(cleanPass)) {
                           const hiddenData = atob(match[1]);
                           const outFile = 'steg_result.txt';
                           const outPath = resolvePath(cwd, outFile);
                           const parent = getNode(cwd);
                           if (parent && parent.type === 'dir') {
                               VFS[outPath] = { type: 'file', content: hiddenData };
                               if (!parent.children.includes(outFile)) parent.children.push(outFile);
                               output = `wrote extracted data to "${outFile}".`;
                           }
                       } else {
                            output = `steghide: could not extract data: wrong password`;
                       }
                   } else {
                       output = `steghide: could not extract any data with that passphrase!`;
                   }
               }
           }
       } else {
           output = 'usage: steghide extract -sf <file> [-p <passphrase>]';
       }
       break;
    }
    case 'tree': {
       const root = getNode(cwd);
       if (root && root.type === 'dir') {
           output = root.children.map((c, i) => {
               const isLast = i === root.children.length - 1;
               const prefix = isLast ? ' ' : ' ';
               return prefix + c;
           }).join('\n');
       } else {
           output = 'tree: error';
       }
       break;
    }
    // Duplicate strace removed - using newer one at end of file
    // Duplicate mystery_process removed
    case 'neofetch': {
       output = `
       \x1b[1;32m       .           \x1b[0m  ghost@ghost-root
       \x1b[1;32m      / \\          \x1b[0m  ----------------
       \x1b[1;32m     /   \\         \x1b[0m  OS: Ghost Linux x86_64
       \x1b[1;32m    /^.   \\        \x1b[0m  Host: Mainframe V2
       \x1b[1;32m   /  _   \\       \x1b[0m  Kernel: 5.4.0-ghost
       \x1b[1;32m  /  (_)   \\      \x1b[0m  Uptime: 42 mins
       \x1b[1;32m /           \\     \x1b[0m  Packages: 1337 (dpkg)
       \x1b[1;32m/_____________\\    \x1b[0m  Shell: bash 5.0.17
                                 CPU: Neural Engine (64) @ 3.2GHz
                                 Memory: 6400MiB / 8192MiB`;
       break;
    }
    case 'weather': {
       output = `Weather Report for Tokyo, JP:
Temp: 18C (64F)
Condition: Overcast
Humidity: 82%
Wind: NE 12 km/h
Forecast: Heavy rain expected later tonight.`;
       break;
    }
    case 'matrix': {
       output = 'matrix...';
       return { output, newCwd, action: 'matrix_sim' };
    }
    case 'ssh-keygen': {
       const keyPath = resolvePath(cwd, args.includes('-f') ? args[args.indexOf('-f') + 1] : '.ssh/id_rsa');
       const parentPath = keyPath.substring(0, keyPath.lastIndexOf('/'));
       
       if (!getNode(parentPath)) {
           // Auto-create parent for UX
           VFS[parentPath] = { type: 'dir', children: [] };
           const grandParent = parentPath.substring(0, parentPath.lastIndexOf('/'));
           const gpNode = getNode(grandParent || '/');
           if (gpNode && gpNode.type === 'dir') {
               gpNode.children.push(parentPath.substring(parentPath.lastIndexOf('/') + 1));
           }
       }

       const privKey = `-----BEGIN OPENSSH PRIVATE KEY-----\nKEY_ID: GHOST_GEN_${Math.floor(Math.random() * 10000)}\n-----END OPENSSH PRIVATE KEY-----`;
       const pubKey = `ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC... ghost@ghost-root`;

       VFS[keyPath] = { type: 'file', content: privKey };
       VFS[`${keyPath}.pub`] = { type: 'file', content: pubKey };

       const pNode = getNode(parentPath);
       if (pNode && pNode.type === 'dir') {
           const fName = keyPath.substring(keyPath.lastIndexOf('/') + 1);
           if (!pNode.children.includes(fName)) pNode.children.push(fName);
           const pubName = `${fName}.pub`;
           if (!pNode.children.includes(pubName)) pNode.children.push(pubName);
       }

       output = `Generating public/private rsa key pair.
Your identification has been saved in ${keyPath}
Your public key has been saved in ${keyPath}.pub
The key fingerprint is:
SHA256:${btoa(Math.random().toString()).substring(0, 20)} ghost@ghost-root
The key's randomart image is:
+---[RSA 3072]----+
|      ..o   o.   |
|     . . o . .   |
|      o . +      |
|     . + * .     |
|      = S =      |
|     o + B .     |
|      E + o      |
|     . o .       |
|      . ..       |
+----[SHA256]-----+`;
       break;
    }
    case 'awk': {
       if (args.length < 1) {
           output = 'usage: awk <program> [file]';
       } else {
           let program = args[0];
           if ((program.startsWith("'") && program.endsWith("'")) || (program.startsWith('"') && program.endsWith('"'))) {
               program = program.slice(1, -1);
           }
           
           let content = '';
           if (args.length > 1) {
               const node = getNode(resolvePath(cwd, args[1]));
               if (node && node.type === 'file') content = node.content;
           } else if (stdin !== undefined) {
               content = stdin;
           }

           const parts = program.match(/print\s+\$(\d+)/);
           if (parts) {
               const col = parseInt(parts[1], 10);
               const lines = content.split('\n');
               output = lines.map(line => {
                   const columns = line.trim().split(/\s+/);
                   if (col === 0) return line; 
                   return columns[col - 1] || '';
               }).join('\n');
           } else {
               output = 'awk: syntax error (simulated only supports print $N)';
           }
       }
       break;
    }
    case 'tar': {
       if (args.length < 2) {
           output = 'usage: tar [-cxvf] <file.tar> [files...]';
       } else {
           const flags = args[0];
           const archiveName = args[1];
           const archivePath = resolvePath(cwd, archiveName);
           const parentPath = archivePath.substring(0, archivePath.lastIndexOf('/')) || '/';
           
           if (flags.includes('c')) {
               // Create
               if (args.length < 3) {
                   output = 'tar: Cowardly refusing to create an empty archive';
               } else {
                   const files = args.slice(2);
                   let tarContent = 'TAR_V1:';
                   let packed: string[] = [];
                   for (const f of files) {
                       const fPath = resolvePath(cwd, f);
                       const node = getNode(fPath);
                       if (node && node.type === 'file') {
                           // Simple simulated packing
                           try {
                               tarContent += `{${f}:${btoa(node.content)}}`;
                               packed.push(f);
                           } catch (e) {
                               // Ignore binary
                           }
                       }
                   }
                   if (packed.length > 0) {
                       const parentNode = getNode(parentPath);
                       if (parentNode && parentNode.type === 'dir') {
                           const fName = archivePath.substring(archivePath.lastIndexOf('/') + 1);
                           VFS[archivePath] = { type: 'file', content: tarContent };
                           if (!parentNode.children.includes(fName)) {
                               parentNode.children.push(fName);
                           }
                           if (flags.includes('v')) {
                               output = packed.join('\n');
                           }
                       } else {
                           output = `tar: ${parentPath}: No such directory`;
                       }
                   } else {
                       output = 'tar: No valid files to pack (or binary content)';
                   }
               }
           } else if (flags.includes('x')) {
               // Extract
               const node = getNode(archivePath);
               if (!node) {
                   output = `tar: ${archiveName}: Cannot open: No such file or directory`;
               } else if (node.type === 'dir') {
                   output = `tar: ${archiveName}: Is a directory`;
               } else if (node.type === 'symlink') {
                   output = `tar: ${archiveName}: Is a symbolic link`;
               } else {
                   const content = (node as any).content;
                   
                   // Cycle 127: Gzip Check
                   const isGzip = archiveName.endsWith('.tar.gz') || archiveName.endsWith('.tgz') || flags.includes('z');
                   if (isGzip && !content.startsWith('GZIP_V1:')) {
                        if (content.startsWith('TAR_V1:')) {
                            output = `gzip: stdin: not in gzip format\ntar: Child returned status 1\ntar: Error is not recoverable: exiting now`;
                        } else {
                            output = `gzip: stdin: not in gzip format`;
                        }
                   } else if (content.startsWith('TAR_V1:') || content.startsWith('GZIP_V1:')) {
                       let payload = content;
                       // Unwrap GZIP if present
                       if (payload.startsWith('GZIP_V1:')) {
                           const inner = payload.substring(8); 
                           if (inner.startsWith('{') && inner.endsWith('}')) {
                               payload = inner.substring(1, inner.length - 1);
                           } else {
                               payload = inner;
                           }
                       }
                       
                       if (payload.startsWith('TAR_V1:')) {
                           payload = payload.substring(7);
                       }
                       
                       const matches = payload.match(/\{([^:]+):([^}]+)\}/g);
                       let extracted: string[] = [];
                       if (matches) {
                           for (const m of matches) {
                               const parts = m.match(/\{([^:]+):([^}]+)\}/);
                               if (parts) {
                                   const fname = parts[1];
                                   const fcontent = atob(parts[2]);
                                   const fPath = resolvePath(cwd, fname);
                                   const fParent = fPath.substring(0, fPath.lastIndexOf('/')) || '/';
                                   const fParentNode = getNode(fParent);
                                   if (fParentNode && fParentNode.type === 'dir') {
                                       const baseName = fPath.substring(fPath.lastIndexOf('/') + 1);
                                       VFS[fPath] = { type: 'file', content: fcontent };
                                       if (!fParentNode.children.includes(baseName)) {
                                           fParentNode.children.push(baseName);
                                       }
                                       extracted.push(fname);
                                       
                                       // Cycle 127 Win
                                       if (fname === 'secret.txt' && fcontent.includes('GHOST_ROOT{')) {
                                           if (!VFS['/var/run/gzip_solved']) {
                                               VFS['/var/run/gzip_solved'] = { type: 'file', content: 'TRUE' };
                                               const runDir = getNode('/var/run');
                                               if (runDir && runDir.type === 'dir' && !runDir.children.includes('gzip_solved')) {
                                                   runDir.children.push('gzip_solved');
                                               }
                                               output = (output || '') + `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ARCHIVE REPAIRED.\x1b[0m`;
                                           }
                                       }
                                   }
                               }
                           }
                       }
                       if (flags.includes('v')) {
                           output = (output ? output + '\n' : '') + extracted.join('\n');
                       }
                   } else {
                       output = `tar: This does not look like a tar archive`;
                   }
               }
           } else {
               output = `tar: Unknown flag or not implemented: ${flags}`;
           }
       }
       break;
    }
    case 'openssl': {
        const subcmd = args[0];
        if (!subcmd || args.includes('help')) {
            output = 'OpenSSL 1.1.1f  31 Mar 2020\nusage: openssl command [command-opts] [command-args]\n\nStandard commands\nenc\nreq\nx509\ngenrsa';
        } else if (subcmd === 'req') {
            if (args.includes('-new') && args.includes('-key') && args.includes('-out')) {
                const keyIndex = args.indexOf('-key') + 1;
                const outIndex = args.indexOf('-out') + 1;
                const keyFile = args[keyIndex];
                const outFile = args[outIndex];
                
                const keyNode = getNode(resolvePath(cwd, keyFile));
                if (!keyNode) {
                    output = `openssl: ${keyFile}: No such file or directory`;
                } else if (keyNode.type !== 'file' || !keyNode.content.includes('RSA PRIVATE KEY')) {
                    output = `openssl: ${keyFile}: Not a valid private key`;
                } else {
                    // Check permissions (just warn)
                    const perms = (keyNode as any).permissions || '0644';
                    if (perms !== '0600') {
                        // Warn but proceed? No, let's just proceed.
                    }
                    
                    // Generate CSR
                    output = `Generating a 2048 bit RSA private key...
................................+++
................+++
writing new private key to '${keyFile}'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]: JP
State or Province Name (full name) [Some-State]: Tokyo
Locality Name (eg, city) []: Shibuya
Organization Name (eg, company) [Internet Widgits Pty Ltd]: Project Omega
Organizational Unit Name (eg, section) []: SatOps
Common Name (e.g. server FQDN or YOUR name) []: satellite.omega.net
Email Address []: admin@omega.net

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []: 
An optional company name []: 
`;
                    const outPath = resolvePath(cwd, outFile);
                    const parent = getNode(cwd);
                    if (parent && parent.type === 'dir') {
                        VFS[outPath] = {
                            type: 'file',
                            content: `CSR_V1:[REQUEST_DATA]...[SIGNATURE]...`
                        };
                        const fName = outPath.substring(outPath.lastIndexOf('/') + 1);
                        if (!parent.children.includes(fName)) parent.children.push(fName);
                    }
                }
            } else {
                output = 'usage: openssl req -new -key <keyfile> -out <output>';
            }
        } else if (subcmd === 'x509') {
            if (args.includes('-text') && args.includes('-in')) {
                const inIndex = args.indexOf('-in') + 1;
                const inFile = args[inIndex];
                const node = getNode(resolvePath(cwd, inFile));
                
                if (!node || node.type !== 'file') {
                    output = `openssl: ${inFile}: No such file or directory`;
                } else if (node.content.includes('CERTIFICATE')) {
                     output = `Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            04:8b:2d:1a:5c:9f:00:23:41:7e
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=JP, ST=Tokyo, L=Shibuya, O=Project Omega, CN=Omega_Secure_Pass_2026
        Validity
            Not Before: Jan 1 00:00:00 2024 GMT
            Not After : Feb 11 23:59:59 2026 GMT
        Subject: C=JP, ST=Tokyo, L=Shibuya, O=Project Omega, CN=*.omega.net
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    00:c3:2b:1a:..
                Exponent: 65537 (0x10001)
    Signature Algorithm: sha256WithRSAEncryption
         3d:2a:4f:..`;
                } else {
                    output = `openssl: unable to load certificate`;
                }
            } else if (args.includes('-req') && args.includes('-in') && args.includes('-signkey') && args.includes('-out')) {
                const inIndex = args.indexOf('-in') + 1;
                const keyIndex = args.indexOf('-signkey') + 1;
                const outIndex = args.indexOf('-out') + 1;
                
                const inFile = args[inIndex];
                const keyFile = args[keyIndex];
                const outFile = args[outIndex];
                
                const csrNode = getNode(resolvePath(cwd, inFile));
                const keyNode = getNode(resolvePath(cwd, keyFile));
                
                if (!csrNode || !keyNode) {
                    output = `openssl: Error opening input files`;
                } else {
                    output = `Signature ok\nsubject=/C=JP/ST=Tokyo/L=Shibuya/O=Project Omega/OU=SatOps/CN=satellite.omega.net/emailAddress=admin@omega.net\nGetting Private key`;
                    
                    const outPath = resolvePath(cwd, outFile);
                    const parent = getNode(outPath.substring(0, outPath.lastIndexOf('/')) || '/');
                    
                    if (parent && parent.type === 'dir') {
                        VFS[outPath] = {
                            type: 'file',
                            content: '[CERT] ISSUER: OMEGA | EXPIRY: 2030-12-31 | [VALID]'
                        };
                        const fName = outPath.substring(outPath.lastIndexOf('/') + 1);
                        if (!parent.children.includes(fName)) parent.children.push(fName);

                        // Mission Update (Cycle 46)
                        if (!VFS['/var/run/ssl_solved']) {
                            VFS['/var/run/ssl_solved'] = { type: 'file', content: 'TRUE' };
                            const runDir = getNode('/var/run');
                            if (runDir && runDir.type === 'dir' && !runDir.children.includes('ssl_solved')) {
                                runDir.children.push('ssl_solved');
                            }
                            output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SSL CERTIFICATE RENEWED.\x1b[0m`;
                        }
                    } else {
                        output = `openssl: ${outFile}: No such file or directory`;
                    }
                }
            } else {
                output = 'usage: openssl x509 [-text] -in <file> ...';
            }
        } else if (subcmd === 'enc') {
            const hasDecrypt = args.includes('-d');
            const cipher = args.find(a => a.startsWith('-aes-') || a === '-bf');
            const inFileIdx = args.indexOf('-in');
            const outFileIdx = args.indexOf('-out');
            const passIdx = args.indexOf('-k');
            
            if (inFileIdx === -1 || !args[inFileIdx + 1]) {
                output = 'enc: input file required (-in)';
            } else {
                const inFile = args[inFileIdx + 1];
                const inPath = resolvePath(cwd, inFile);
                const inNode = getNode(inPath);
                
                if (!inNode || inNode.type !== 'file') {
                    output = `enc: ${inFile}: No such file or directory`;
                } else if (!hasDecrypt) {
                    output = 'enc: encryption not supported in simulation (decrypt only)';
                } else {
                    let password = '';
                    if (passIdx !== -1 && args[passIdx + 1]) {
                        password = args[passIdx + 1];
                    } else {
                        output = 'enc: password required (-k)';
                    }
                    
                    if (password) {
                        if (password === 'GHOST_PROTOCOL_V1' || password === '20240115') {
                            let decryptedContent = 'COORDINATES: 51.5074 N, 0.1278 W\nTARGET: MI6_HQ\nFLAG: GHOST_ROOT{0P3NSSL_M4ST3R}';
                            if (password === '20240115') {
                                decryptedContent = 'PROJECT CHIMERA BLUEPRINT (FINAL)\n\n[SYSTEM ARCHITECTURE]\n- Neural Core: Quantum-v4\n- Uplink: Satellite OMEGA\n- Failsafe: DETONATION_PROTOCOL\n\nFLAG: GHOST_ROOT{R4NS0MW4R3_D3CRYPT3D}';
                            }
                            
                            if (outFileIdx !== -1 && args[outFileIdx + 1]) {
                                const outFile = args[outFileIdx + 1];
                                const outPath = resolvePath(cwd, outFile);
                                const parent = outPath.substring(0, outPath.lastIndexOf('/'));
                                const pNode = getNode(parent);
                                if (pNode && pNode.type === 'dir') {
                                    const fName = outPath.substring(outPath.lastIndexOf('/') + 1);
                                    VFS[outPath] = { type: 'file', content: decryptedContent };
                                    if (!pNode.children.includes(fName)) pNode.children.push(fName);
                                    output = ''; // Silent success
                                } else {
                                    output = `enc: ${outFile}: No such file or directory (path check)`;
                                }
                            } else {
                                output = decryptedContent;
                            }
                        } else {
                            output = 'bad decrypt';
                        }
                    }
                }
            }
        } else {
            output = `openssl:Error: '${subcmd}' is an invalid command.`;
        }
        break;
    }
    case 'zcat': {
       if (args.length < 1) {
           output = 'usage: zcat [file...]';
       } else {
           const file = args[0];
           const fPath = resolvePath(cwd, file);
           const node = getNode(fPath);

           if (!node) {
               output = `zcat: ${file}: No such file or directory`;
           } else if (node.type === 'dir') {
               output = `zcat: ${file}: Is a directory`;
           } else if (node.type === 'symlink') {
               output = `zcat: ${file}: Is a symbolic link`;
           } else {
               const content = (node as any).content;
               if (content.startsWith('GZIP_V1:')) {
                   const payload = content.substring(8);
                   if (payload.startsWith('{') && payload.endsWith('}')) {
                        output = payload.substring(1, payload.length - 1);
                   } else {
                        output = payload;
                   }
               } else {
                   output = `zcat: ${file}: not in gzip format`;
               }
           }
       }
       break;
    }
    case 'radio': {
       if (args.length < 1) {
           output = 'usage: radio [scan|tune <freq>]';
       } else {
           const subcmd = args[0];
           if (subcmd === 'scan') {
               output = 'Scanning radio frequencies...';
               return { output, newCwd, action: 'radio_sim', data: { mode: 'scan' } };
           } else if (subcmd === 'tune') {
               if (args.length < 2) {
                   output = 'usage: radio tune <freq>';
               } else {
                   const freq = args[1];
                   if (freq === '89.9') {
                       output = `Tuning to ${freq} MHz...\n[SIGNAL LOCKED]\nBroadcast: "The... crow... flies... at... midnight... Repeat... The... crow... flies..."\n[END TRANSMISSION]`;
                   } else if (freq === '101.5') {
                       output = `Tuning to ${freq} MHz...\n[MUSIC] Smooth Jazz playing...`;
                   } else {
                       output = `Tuning to ${freq} MHz...\n[STATIC] No signal detected.`;
                   }
                   return { output, newCwd, action: 'radio_sim', data: { mode: 'tune', freq } };
               }
           } else {
               output = `radio: unknown subcommand: ${subcmd}`;
           }
       }
       break;
    }
    case 'systemctl': {
       if (args.length < 1) {
           output = 'usage: systemctl [command] [unit]';
       } else {
           const cmd = args[0];
           const unit = args[1];
           
           const validUnits = ['sshd', 'tor', 'apache2', 'postgresql', 'cron', 'networking', 'bluetooth', 'ghost_relay', 'overseer', 'web_server', 'httpd'];
           const runDir = '/var/run';
           if (!VFS[runDir]) VFS[runDir] = { type: 'dir', children: [] };
           
           const rd = VFS[runDir];
           // Initialize default state if not present (mock persistence)
           if (rd && rd.type === 'dir' && rd.children.length === 0 && !(rd as any).__init) {
               ['sshd', 'cron', 'networking'].forEach(s => {
                   VFS[`${runDir}/${s}.pid`] = { type: 'file', content: String(Math.floor(Math.random() * 30000)) };
                   rd.children.push(`${s}.pid`);
               });
               (rd as any).__init = true;
           }

           if (cmd === 'list-units') {
               output = 'UNIT           LOAD   ACTIVE SUB     DESCRIPTION\n';
               validUnits.forEach(u => {
                   const rdNode = VFS[runDir];
                   const isRunning = rdNode && rdNode.type === 'dir' && rdNode.children.includes(`${u}.pid`);
                   const active = isRunning ? 'active' : 'inactive';
                   const sub = isRunning ? 'running' : 'dead';
                   output += `${u}.service`.padEnd(16) + `loaded ${active.padEnd(6)} ${sub.padEnd(7)} ${u} service\n`;
               });
               output += `\nLOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

${validUnits.length} loaded units listed.`;
           } else if (cmd === 'status') {
               if (unit === 'web_server' && !VFS['/etc/web/config.json']) {
                   output = ` web_server.service - Web Server
   Loaded: loaded (/lib/systemd/system/web_server.service; enabled; vendor preset: enabled)
   Active: failed (Result: exit-code) since ${new Date().toUTCString()}
  Process: 1234 ExecStart=/usr/bin/web_server (code=exited, status=1/FAILURE)
 Main PID: 1234 (code=exited, status=1/FAILURE)`;
                   return { output, newCwd };
               }
               if (!unit) {
                   output = 'systemctl: unit name required';
               } else if (!validUnits.includes(unit)) {
                   output = `Unit ${unit}.service could not be found.`;
               } else {
                   const rdNode = VFS[runDir];
                   const isRunning = rdNode && rdNode.type === 'dir' && rdNode.children.includes(`${unit}.pid`);
                   const pidNode = isRunning ? VFS[`${runDir}/${unit}.pid`] : null;
                   const pid = (pidNode && pidNode.type === 'file') ? pidNode.content : null;
                   
                   output = ` ${unit}.service - ${unit} service
   Loaded: loaded (/lib/systemd/system/${unit}.service; enabled; vendor preset: enabled)
   Active: ${isRunning ? 'active (running)' : 'inactive (dead)'} since ${new Date(Date.now() - 10000000).toUTCString()}
     Docs: man:${unit}(8)
 Main PID: ${pid || '(null)'} (${unit})
    Tasks: ${isRunning ? 1 : 0} (limit: 4915)
   Memory: ${isRunning ? '12.4M' : '0B'}
   CGroup: /system.slice/${unit}.service`;
               }
           } else if (cmd === 'start') {
               if (!unit) {
                   output = 'systemctl: unit name required';
               } else if (!validUnits.includes(unit)) {
                   output = `Failed to start ${unit}.service: Unit ${unit}.service not found.`;
               } else {
                   if (unit === 'cron') {
                       output = 'Restarting cron service...\n';
                       // Scan /etc/cron.d for exploits
                       const cronDir = getNode('/etc/cron.d');
                       if (cronDir && cronDir.type === 'dir') {
                           for (const child of cronDir.children) {
                               const jobNode = getNode(`/etc/cron.d/${child}`);
                               if (jobNode && jobNode.type === 'file') {
                                   const content = jobNode.content;
                                   // Check for exploit pattern: cp /root/flag.txt /tmp/flag.txt
                                   if (content.includes('cp /root/flag.txt') && (content.includes('/tmp') || content.includes('/home/ghost'))) {
                                        // Execute payload
                                        const destMatch = content.match(/cp \/root\/flag.txt\s+([^\s;&]+)/);
                                        if (destMatch) {
                                            const destPath = destMatch[1];
                                            VFS[destPath] = { type: 'file', content: 'FLAG: GHOST_ROOT{CR0N_D_WR1T4BL3}' };
                                            
                                            // Ensure parent dir knows about it
                                            const pDirName = destPath.substring(0, destPath.lastIndexOf('/'));
                                            const pDir = getNode(pDirName);
                                            const fName = destPath.substring(destPath.lastIndexOf('/') + 1);
                                            if (pDir && pDir.type === 'dir' && !pDir.children.includes(fName)) {
                                                if (pDir.children) pDir.children.push(fName);
                                                else pDir.children = [fName];
                                            }
                                            
                                            output += `[CRON] Executing job "${child}" as root...\n[SUCCESS] Job completed.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: CRON PRIVILEGE ESCALATION.\x1b[0m`;
                                            
                                            // Mark solved
                                            if (!VFS['/var/run/cron_write_solved']) {
                                                VFS['/var/run/cron_write_solved'] = { type: 'file', content: 'TRUE' };
                                                const runDir = getNode('/var/run');
                                                if (runDir && runDir.type === 'dir' && !runDir.children.includes('cron_write_solved')) {
                                                    runDir.children.push('cron_write_solved');
                                                }
                                            }
                                        }
                                   }
                               }
                           }
                       }
                       if (!output.includes('SUCCESS')) output += '[OK] Cron service active.';
                   }

                   if (unit === 'web_server') {
                       if (VFS['/etc/web/config.json']) {
                           output = 'Starting Web Server...\n[OK] Started Web Server.\nFLAG: GHOST_ROOT{S3RV1C3_R3ST0R3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: WEB SERVER FIXED.\x1b[0m';
                           if (!VFS['/var/run/web_solved']) {
                                VFS['/var/run/web_solved'] = { type: 'file', content: 'TRUE' };
                                const runDir = getNode('/var/run');
                                if (runDir && runDir.type === 'dir' && !runDir.children.includes('web_solved')) {
                                    runDir.children.push('web_solved');
                                }
                           }
                           
                           // Create PID
                           const pidFile = 'web_server.pid';
                           const runDirNode = getNode('/var/run');
                           if (runDirNode && runDirNode.type === 'dir' && !runDirNode.children.includes(pidFile)) {
                               VFS[`/var/run/${pidFile}`] = { type: 'file', content: '8080' };
                               runDirNode.children.push(pidFile);
                           }
                           return { output, newCwd };
                       } else {
                           output = `Job for web_server.service failed because the control process exited with error code.\nSee "systemctl status web_server.service" and "journalctl -xe" for details.`;
                           const log = getNode('/var/log/syslog');
                           if (log && log.type === 'file') {
                               log.content += `\n${new Date().toUTCString()} web_server[8080]: [CRITICAL] Configuration file /etc/web/config.json not found.`;
                           }
                           return { output, newCwd };
                       }
                   }

                   if (unit === 'ghost_relay') {
                       if (PROCESSES.find(p => p.pid === 4444)) {
                           output = `Job for ghost_relay.service failed because the control process exited with error code.\nSee "systemctl status ghost_relay.service" and "journalctl -xe" for details.`;
                           const log = getNode('/var/log/syslog');
                           if (log && log.type === 'file') {
                               log.content += `\n${new Date().toUTCString()} ghost_relay[9001]: Error: listen tcp 0.0.0.0:8080: bind: address already in use`;
                           }
                           return { output, newCwd };
                       } else {
                           if (!VFS['/var/run/relay_active']) {
                                VFS['/var/run/relay_active'] = { type: 'file', content: 'TRUE' };
                                const rdNode = VFS[runDir];
                                if (rdNode && rdNode.type === 'dir' && !rdNode.children.includes('relay_active')) {
                                    rdNode.children.push('relay_active');
                                }
                           }
                           output = 'Starting Ghost Relay Service...\n[OK] Started Ghost Relay Service.\n\x1b[1;32m[MISSION UPDATE] Objective Complete: RELAY ONLINE.\x1b[0m';
                       }
                   }

                   if (unit === 'networking') {
                       // Do nothing special visual
                   }
                   
                   if (unit === 'tor') {
                       const torrc = getNode('/etc/tor/torrc');
                       if (!torrc || torrc.type !== 'file' || torrc.content.includes('InvalidPort')) {
                           output = `Job for tor.service failed because the control process exited with error code.\nSee "systemctl status tor.service" and "journalctl -xe" for details.`;
                           const log = getNode('/var/log/syslog');
                           if (log && log.type === 'file') {
                               log.content += `\n${new Date().toUTCString()} systemd[1]: Failed to start Anonymizing overlay network for TCP.\n${new Date().toUTCString()} tor[6666]: [err] Parsing config file /etc/tor/torrc failed: Syntax error: "InvalidPort" is not a valid option.`;
                           }
                           return { output, newCwd };
                       }
                   }

                   const pidFile = `${unit}.pid`;
                   const rdNode = VFS[runDir];
                   if (rdNode && rdNode.type === 'dir' && !rdNode.children.includes(pidFile)) {
                       const newPid = String(Math.floor(Math.random() * 30000) + 1000);
                       VFS[`${runDir}/${pidFile}`] = { type: 'file', content: newPid };
                       rdNode.children.push(pidFile);
                   }
                   output = ''; // Silent success
               }
           } else if (cmd === 'stop') {
               if (!unit) {
                   output = 'systemctl: unit name required';
               } else if (!validUnits.includes(unit)) {
                   output = `Failed to stop ${unit}.service: Unit ${unit}.service not found.`;
               } else {
                   if (unit === 'overseer') {
                        if (VFS['/var/lock/overseer.lock']) {
                            output = `Failed to stop overseer.service: Unit is locked by /var/lock/overseer.lock`;
                            return { output, newCwd };
                        } else {
                            // Kill process
                            const idx = PROCESSES.findIndex(p => p.command === '/usr/bin/overseer' || p.pid >= 6000);
                            if (idx !== -1) PROCESSES.splice(idx, 1);
                        }
                   }
                   const pidFile = `${unit}.pid`;
                   const rdNode = VFS[runDir];
                   if (rdNode && rdNode.type === 'dir' && rdNode.children.includes(pidFile)) {
                       delete VFS[`${runDir}/${pidFile}`];
                       rdNode.children = rdNode.children.filter(c => c !== pidFile);
                   }
                   output = ''; // Silent success
               }
           } else if (cmd === 'restart') {
                if (!unit) { output = 'systemctl: unit name required'; }
                else {
                    // Cycle 134: httpd restart
                    if (unit === 'httpd') {
                        // Kill process 4040
                        const idx = PROCESSES.findIndex(p => p.pid === 4040);
                        if (idx !== -1) {
                            PROCESSES.splice(idx, 1);
                            
                            // Start new
                            PROCESSES.push({
                               pid: 4045,
                               ppid: 1,
                               user: 'www-data',
                               cpu: 1.0,
                               mem: 5.0,
                               time: '0:00',
                               command: '/usr/sbin/httpd',
                               tty: '?',
                               stat: 'Ss'
                            });
                            
                            // Clear deleted flag
                            if (VFS['/var/run/ghost_log_deleted']) {
                               delete VFS['/var/run/ghost_log_deleted'];
                               const rdNode = VFS[runDir];
                               if (rdNode && rdNode.type === 'dir') rdNode.children = rdNode.children.filter(c => c !== 'ghost_log_deleted');
                               
                               if (!VFS['/var/run/log_solved_restart']) {
                                   VFS['/var/run/log_solved_restart'] = { type: 'file', content: 'TRUE' };
                                   const rd = getNode('/var/run');
                                   if (rd && rd.type === 'dir' && !rd.children.includes('log_solved_restart')) {
                                       rd.children.push('log_solved_restart');
                                   }
                                   output = `[SYSTEM] Restarting httpd...\n[OK] Service restarted.\n[KERNEL] Released deleted file handles.\nFLAG: GHOST_ROOT{S3RV1C3_R3ST4RT_CL34NUP}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SPACE RECLAIMED (RESTART).\x1b[0m`;
                                   return { output, newCwd };
                               }
                            }
                            output = `[OK] Restarted ${unit}.service.`;
                            return { output, newCwd };
                        } else {
                            output = `Failed to restart ${unit}.service: Unit not found.`;
                            return { output, newCwd };
                        }
                    }

                    // Stop logic
                    const pidFile = `${unit}.pid`;
                    const rdNode = VFS[runDir];
                    if (validUnits.includes(unit) && rdNode && rdNode.type === 'dir') {
                        if (rdNode.children.includes(pidFile)) {
                           delete VFS[`${runDir}/${pidFile}`];
                           rdNode.children = rdNode.children.filter(c => c !== pidFile);
                        }
                        // Start logic
                        const newPid = String(Math.floor(Math.random() * 30000) + 1000);
                        VFS[`${runDir}/${pidFile}`] = { type: 'file', content: newPid };
                        rdNode.children.push(pidFile);
                        output = '';
                    } else {
                        output = `Failed to restart ${unit}.service: Unit not found.`;
                    }
                }
           } else {
               output = `Unknown command verb ${cmd}.`;
           }
       }
       break;
    }
    case 'route': {
        const subCmd = args[0];
        if (!subCmd || subCmd === '-n') {
            let table = `Kernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 eth0\n192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0`;
            
            if (VFS['/var/run/route_fixed']) {
                 table += `\n10.10.99.0      192.168.1.1     255.255.255.0   UG    0      0        0 eth0`;
            }
            output = table;
        } else if (subCmd === 'add') {
            // route add -net 10.10.99.0 netmask 255.255.255.0 gw 192.168.1.1
            // route add default gw 192.168.1.1
            
            const isDefault = args.includes('default');
            const isNet = args.includes('-net') || args.includes('10.10.99.0') || args.includes('10.10.99.0/24');
            const gwIndex = args.indexOf('gw');
            const gw = gwIndex !== -1 ? args[gwIndex + 1] : null;

            if (gw === '192.168.1.1') {
                if (isNet || isDefault) {
                    if (!VFS['/var/run/route_fixed']) {
                        VFS['/var/run/route_fixed'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('route_fixed')) {
                            runDir.children.push('route_fixed');
                        }
                        output = `[SUCCESS] Route added.\n[NETWORK] Connectivity to Black Site Uplink (10.10.99.0/24) restored.\nFLAG: GHOST_ROOT{R0UT1NG_T4BL3_F1X3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: NETWORK ROUTING.\x1b[0m`;
                    } else {
                        output = `SIOCADDRT: File exists`;
                    }
                } else {
                     output = `route: invalid destination`;
                }
            } else {
                output = `SIOCADDRT: Network is unreachable`;
            }
        } else {
            output = `Usage: route [-n] [add] [-net|-host] target [gw Gw] [netmask Nm]`;
        }
        break;
    }
    case 'sed': {
       if (args.length < 1) {
           output = 'usage: sed [-i] <expression> [file]';
       } else {
           const inPlace = args.includes('-i');
           // Remove -i from args to find expression and file
           const cleanArgs = args.filter(a => a !== '-i');
           
           if (cleanArgs.length < 1) {
               output = 'usage: sed [-i] <expression> [file]';
           } else {
               let expression = cleanArgs[0];
               if ((expression.startsWith("'") && expression.endsWith("'")) || (expression.startsWith('"') && expression.endsWith('"'))) {
                   expression = expression.slice(1, -1);
               }

               let content = '';
               let targetNode: any = null;
               
               if (cleanArgs.length > 1) {
                   const node = getNode(resolvePath(cwd, cleanArgs[1]));
                   if (node && node.type === 'file') {
                       content = node.content;
                       targetNode = node;
                   } else {
                       output = `sed: cannot read ${cleanArgs[1]}: No such file`;
                       return { output, newCwd };
                   }
               } else if (stdin !== undefined) {
                   content = stdin;
               }

               // Support s/find/replace/g
               if (expression.startsWith('s/')) {
                   const parts = expression.split('/');
                   // s/find/replace/flags -> ['', 'find', 'replace', 'flags']
                   if (parts.length >= 3) {
                       const find = parts[1];
                       const replace = parts[2];
                       const flags = parts[3] || '';
                       
                       try {
                           const regex = new RegExp(find, flags.includes('g') ? 'g' : '');
                           const result = content.replace(regex, replace);
                           
                           if (inPlace && targetNode) {
                               targetNode.content = result;
                               output = ''; // Silent success
                           } else {
                               output = result;
                           }
                       } catch (e) {
                           output = 'sed: invalid regex';
                       }
                   } else {
                       output = 'sed: invalid expression';
                   }
               } else {
                   output = 'sed: only s/find/replace/ is supported in simulation';
               }
           }
       }
       break;
    }
    case 'netmap': {
       const run = getNode('/var/run');
       if (run && run.type === 'dir') {
           VFS['/var/run/scan_complete'] = { type: 'file', content: 'TRUE' };
           if (!run.children.includes('scan_complete')) run.children.push('scan_complete');
       }
       output = 'Loading Network Map...';
       return { output, newCwd, action: 'netmap_sim' };
    }
    case 'theme': {
       if (args.length < 1) {
           output = 'usage: theme <name>\nAvailable themes: green, amber, blue, red, cyber, bw';
       } else {
           const themeName = args[0];
           if (['green', 'amber', 'blue', 'red', 'cyber', 'bw'].includes(themeName)) {
               output = `Switching theme to ${themeName}...`;
               return { output, newCwd, action: 'theme_change', data: { theme: themeName } };
           } else {
               output = `theme: '${themeName}' not found.`;
           }
       }
       break;
    }
    case 'sat': {
      if (args.length < 1) {
          output = 'usage: sat <connect|list|download|status|files> [target]';
      } else {
          const subcmd = args[0];
          const runDir = getNode('/var/run');
          const isLinked = runDir && runDir.type === 'dir' && runDir.children.includes('sat_link.pid');
          
          if (subcmd === 'list') {
              output = `Available Satellites (Low Earth Orbit):
[ID: KH-11]  USA-224 (Keyhole)   - ONLINE  (Encrypted)
[ID: COSM]   Cosmos-2542         - ONLINE  (Signal Weak)
[ID: OMEG]   Omega-Sat-V1        - ONLINE  (Secure Uplink Available)
[ID: BLK]    BLACK_KNIGHT        - UNKNOWN (Beacon Active)`;
          } else if (subcmd === 'connect') {
              if (args.length < 2) {
                  output = 'usage: sat connect <id>';
              } else {
                  const id = args[1];
                  
                  // SSL Check for OMEG (Cycle 46)
                  if (id === 'OMEG') {
                      const certPath = '/etc/ssl/certs/satellite.crt';
                      const certNode = getNode(certPath);
                      
                      if (!certNode || certNode.type !== 'file' || certNode.content.includes('[EXPIRED]')) {
                          output = `[ERROR] SAT_LINK_V4: SSL Handshake Failed.\n[REASON] Certificate Expired (Issuer: OMEGA | Expiry: 1999-12-31).\n[HINT] Renew certificate using 'openssl req' and 'openssl x509'.`;
                          return { output, newCwd, action: 'delay' };
                      }
                  }

                  if (['KH-11', 'COSM', 'BLK', 'OMEG'].includes(id)) {
                      if (runDir && runDir.type === 'dir') {
                          VFS['/var/run/sat_link.pid'] = { type: 'file', content: id };
                          if (!runDir.children.includes('sat_link.pid')) runDir.children.push('sat_link.pid');
                      }
                      output = `Initializing uplink to ${id}...`;
                      return { output, newCwd, action: 'sat_sim', data: { target: id, mode: 'connect' } };
                  } else {
                      output = `sat: uplink failed: Target ${id} not found or out of range.`;
                  }
              }
          } else if (subcmd === 'status') {
              if (isLinked) {
                  const node = VFS['/var/run/sat_link.pid'];
                  const id = (node && node.type === 'file') ? node.content : 'UNKNOWN';
                  output = `Uplink Status: CONNECTED (${id})\nSignal Strength: 98%\nEncryption: AES-256-GCM`;
              } else {
                  output = 'Uplink Status: DISCONNECTED\nSignal Strength: 0%\nEncryption: NONE';
              }
          } else if (subcmd === 'files') {
               if (isLinked) {
                   const node = VFS['/var/run/sat_link.pid'];
                   const id = (node && node.type === 'file') ? node.content : 'UNKNOWN';
                   if (id === 'OMEG') {
                       output = `[SAT_LINK] Remote File System (${id}):
- rwx------  launch_codes.bin  (512B)  [DOOMSDAY_PROTOCOL]
- r--------  README.txt        (1KB)   [INFO]`;
                   } else {
                       output = `[SAT_LINK] Remote File System (${id}):
- rwxr-x---  IMAGERY_001  (24MB)  [CLASSIFIED]
- rwxr-x---  LOG_V2.txt   (4KB)
- r--------  KEYS.enc     (1KB)   [LOCKED]`;
                   }
               } else {
                   output = 'sat: not connected. Use "sat connect <id>" first.';
               }
          } else if (subcmd === 'download') {
               if (args.length < 2) {
                  output = 'usage: sat download <file_id>';
               } else {
                  if (isLinked) {
                      const node = VFS['/var/run/sat_link.pid'];
                      const id = (node && node.type === 'file') ? node.content : 'UNKNOWN';
                      const fileId = args[1];
                      let success = false;

                      if (id === 'COSM' && fileId === 'KEYS.enc') {
                           const fPath = resolvePath(cwd, 'KEYS.enc');
                           VFS[fPath] = { type: 'file', content: 'U29tZSBlbmNyeXB0ZWQgZGF0YS4uLiAoaGV4IGR1bXAp' }; // Dummy content, decrypt checks name
                           const parent = getNode(cwd);
                           if (parent && parent.type === 'dir' && !parent.children.includes('KEYS.enc')) {
                               parent.children.push('KEYS.enc');
                           }
                           success = true;
                      } else if (id === 'OMEG' && fileId === 'launch_codes.bin') {
                           const fPath = resolvePath(cwd, 'launch_codes.bin');
                           VFS[fPath] = { type: 'file', content: 'TEFVTkNIX0NPREVTX0lOSVRJQVRFRA==' };
                           const parent = getNode(cwd);
                           if (parent && parent.type === 'dir' && !parent.children.includes('launch_codes.bin')) {
                               parent.children.push('launch_codes.bin');
                           }
                           success = true;
                      }

                      if (success) {
                          output = 'Downloading...';
                          if (fileId === 'launch_codes.bin') {
                              output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PAYLOAD ACQUIRED.\x1b[0m';
                          }
                          return { output, newCwd, action: 'sat_sim', data: { target: args[1], mode: 'download' } };
                      } else {
                          output = `sat: file '${fileId}' not found on satellite ${id}.`;
                      }
                  } else {
                      output = 'sat: not connected.';
                  }
               }
          } else {
              output = `sat: unknown subcommand: ${subcmd}`;
          }
      }
      break;
    }
    // Duplicate mystery_process removed (use implementation at end of file)

    case 'strace': {
        if (args.length < 1) {
            output = 'usage: strace <command>';
        } else {
            const cmd = args[0];
            const cmdArgs = args.slice(1);
            let cmdPath = resolvePath(cwd, cmd);
            
            // Handle relative paths without ./
            if (!cmd.startsWith('/') && !cmd.startsWith('./') && !cmd.startsWith('../')) {
                 if (['ls', 'cat', 'pwd', 'whoami', 'id', 'groups'].includes(cmd)) {
                     cmdPath = `/usr/bin/${cmd}`; 
                 } else if (VFS[`/usr/bin/${cmd}`]) {
                     cmdPath = `/usr/bin/${cmd}`;
                 } else if (VFS[`/usr/local/bin/${cmd}`]) {
                     cmdPath = `/usr/local/bin/${cmd}`;
                 }
            }

            // Cycle 255: The Process Trace (Verified Phase 10.0 - Full Identity Trace)
            if (cmd.includes('mystery_process')) {
                 const secretNode = getNode('/tmp/secret_config.dat');
                 const secretExists = secretNode && secretNode.type === 'file';
                 const content = secretExists ? secretNode.content : '';
                 const isValid = content.startsWith('CONF_V1');
                 
                 output = `execve("${cmdPath}", ["${cmd}"], 0x7ffd5d5966d0 /* 24 vars */) = 0
brk(NULL)                               = 0x559e2269a000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=96453, ...}) = 0
mmap(NULL, 96453, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f0e38605000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\360q\\2\\0\\0\\0\\0\\0", 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2029592, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0e38603000
mmap(NULL, 2037344, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f0e38411000
mmap(0x7f0e38433000, 1548288, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7f0e38433000
mmap(0x7f0e385ad000, 319488, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19c000) = 0x7f0e385ad000
mmap(0x7f0e385fb000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ea000) = 0x7f0e385fb000
mmap(0x7f0e38601000, 13920, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f0e38601000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f0e38604500) = 0
mprotect(0x7f0e385fb000, 16384, PROT_READ) = 0
mprotect(0x559e20a06000, 4096, PROT_READ) = 0
mprotect(0x7f0e3863f000, 4096, PROT_READ) = 0
munmap(0x7f0e38605000, 96453)           = 0
getpid()                                = ${Math.floor(Math.random() * 30000) + 2000}
getppid()                               = ${Math.floor(Math.random() * 1000) + 1}
getuid()                                = 1000
geteuid()                               = 1000
getgid()                                = 1000
getegid()                               = 1000
socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
connect(3, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr("192.168.1.99")}, 16) = -1 ENETUNREACH (Network is unreachable)
close(3)                                = 0
openat(AT_FDCWD, "/tmp/secret_config.dat", O_RDONLY) = ${secretExists ? '3' : '-1 ENOENT (No such file or directory)'}\n`;

                 if (secretExists) {
                     const preview = content.length > 20 ? content.substring(0, 20) + '...' : content;
                     const cleanPreview = preview.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
                     
                     output += `read(3, "${cleanPreview}", 1024) = ${content.length}\n`;
                     output += `close(3)                                = 0\n`;
                     
                     if (isValid) {
                         output += `write(1, "Access Granted.\\n", 16) = 16\n`;
                         output += `write(1, "FLAG: GHOST_ROOT{STR4C3_TR4C3_M4ST3R}\\n", 45) = 45\n`;
                         output += `exit_group(0)                           = ?\n+++ exited with 0 +++`;
                     } else {
                         output += `write(2, "Invalid Configuration Header\\n", 29) = 29\n`;
                         output += `exit_group(1)                           = ?\n+++ exited with 1 +++`;
                     }
                 } else {
                     output += `--- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x0} ---\n+++ killed by SIGSEGV (core dumped) +++`;
                 }

                 if (secretExists && isValid) {
                     if (!VFS['/var/run/strace_solved']) {
                         VFS['/var/run/strace_solved'] = { type: 'file', content: 'TRUE' };
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('strace_solved')) {
                             runDir.children.push('strace_solved');
                         }
                         output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM CALL TRACED.\x1b[0m`;
                     }
                 }
            } else {
                 // Recursive Trace: Actually execute the command and wrap output
                 const fullCmd = `${cmd} ${cmdArgs.join(' ')}`.trim();
                 const res = processCommand(cwd, fullCmd);
                 
                 output = `execve("${cmdPath}", ["${cmd}"], 0x7fff...) = 0\n`;
                 output += `brk(NULL)                               = 0x560877907000\n`;
                 output += `access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)\n`;
                 output += `openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3\n`;
                 output += `close(3)                                = 0\n`;
                 
                 if (res.output) {
                     const lines = res.output.split('\n');
                     for (const line of lines) {
                         // Only trace non-empty lines to reduce noise
                         if (line.trim()) {
                             const cleanLine = line.replace(/"/g, '\\"').replace(/\n/g, '\\n');
                             output += `write(1, "${cleanLine}\\n", ${cleanLine.length + 1}) = ${cleanLine.length + 1}\n`;
                             output += `${line}\n`;
                         }
                     }
                 }
                 
                 output += `exit_group(0)                           = ?\n+++ exited with 0 +++`;
                 
                 // Propagate state changes (cd, etc)
                 if (res.newCwd && res.newCwd !== cwd) newCwd = res.newCwd;
                 if (res.action) action = res.action;
                 if (res.data) data = res.data;
            }
        }
        break;
    }
    // Duplicate mystery_process removed (v2)
    case 'ltrace': {
        if (args.length < 1) {
            output = 'usage: ltrace <command>';
        } else {
            const cmd = args[0];
            if (cmd.includes('mystery_process')) {
                 const secretExists = !!getNode('/tmp/secret_config.dat');
                 output = `__libc_start_main(0x559e2269a2a0, 1, 0x7ffd5d5966d0, 0x559e2269a2c0 <unfinished ...>
fopen("/tmp/secret_config.dat", "r")             = ${secretExists ? '0x559e2269a2a0' : '0'}
${secretExists ? 'fgets("CONF_V1:...", 1024, 0x559e2269a2a0) = "CONF_V1:..."\\nputs("Access Granted.")                          = 16\\nputs("FLAG: GHOST_ROOT{STR4C3_R3V34LS_H1DD3N_P4THS}") = 45\\nexit(0)                                          = <void>\\n+++ exited (status 0) +++' : '--- SIGSEGV (Segmentation fault) ---\\n+++ killed by SIGSEGV +++'}`;
            } else {
                 output = `__libc_start_main(...) = 0\\nputs("Output...")                                = 9\\nexit(0)                                          = <void>\\n+++ exited (status 0) +++`;
            }
        }
        break;
    }
    case 'tcpdump': {
       const fileIdx = args.indexOf('-r');
       if (fileIdx !== -1 && args[fileIdx + 1]) {
           const filename = args[fileIdx + 1];
           const path = resolvePath(cwd, filename);
           const node = getNode(path);
           
           if (!node || node.type !== 'file') {
               output = `tcpdump: ${filename}: No such file or directory`;
           } else {
               if (filename.endsWith('.pcap') || node.content.startsWith('PCAP_V1')) {
                   const restArgs = args.filter((a, i) => a !== '-r' && i !== fileIdx && i !== fileIdx + 1);
                   const filterStr = restArgs.join(' ');
                   
                   if (filterStr.includes('port 4444') || filterStr.includes('host 10.10.10.10')) {
                       output = `reading from file ${filename}, link-type EN10MB (Ethernet)
14:02:05.123456 IP 10.10.10.10.4444 > 192.168.1.5.31337: Flags [P.], seq 1:42, ack 1, win 502, options [nop,nop,TS val 123456 ecr 123456], length 41
    0x0000:  4500 005d 1a2b 4000 4006 a2c4 0a0a 0a0a  E..].+@.@.......
    0x0010:  c0a8 0105 115c 7a69 82e1 3564 82e1 3569  .....\\zi..5d..5i
    0x0020:  8018 01f6 6842 0000 0101 080a 026e 2460  ....hB.......n$\`
    0x0030:  0019 1918 4748 4f53 545f 524f 4f54 7b50  ......GHOST_ROOT{P
    0x0040:  3443 4b33 545f 4d34 5354 3352 7d0a       4CK3T_M4ST3R}..
`;
                        if (!VFS['/var/run/pcap_solved']) {
                             VFS['/var/run/pcap_solved'] = { type: 'file', content: 'TRUE' };
                             const runDir = getNode('/var/run');
                             if (runDir && runDir.type === 'dir' && !runDir.children.includes('pcap_solved')) {
                                 runDir.children.push('pcap_solved');
                             }
                             output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PACKET ANALYZED.\x1b[0m`;
                        }
                   } else {
                       output = `reading from file ${filename}, link-type EN10MB (Ethernet)\n`;
                       for(let i=0; i<15; i++) {
                           output += `14:02:0${i}.${Math.floor(Math.random()*999999)} IP 192.168.1.${Math.floor(Math.random()*255)}.443 > 10.0.0.${Math.floor(Math.random()*255)}.553${i}: Flags [.], ack ${Math.floor(Math.random()*999999)}, win 501, length 0\n`;
                       }
                       output += `... (1542 packets captured)\n[INFO] Too many packets. Use a filter (e.g., 'port <num>', 'host <ip>')`;
                   }
               } else {
                   output = `tcpdump: ${filename}: File format not recognized`;
               }
           }
       } else if (args.includes('--help') || args.includes('-h')) {
           output = 'tcpdump version 4.9.3\nlibpcap version 1.9.1\nUsage: tcpdump [-i interface] [-w file] [-r file] [expression]';
       } else {
           output = 'tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes\n';
           return { output, newCwd, action: 'tcpdump_sim' };
       }
       break;
    }
    case 'irc': {
       if (args.length < 1) {
           output = 'usage: irc <server> [channel] [nick]';
       } else {
           const server = args[0];
           const channel = args[1] || '#lobby';
           const nick = args[2] || 'ghost';

           if (server === '192.168.1.99' || server === 'chat.black-site.local' || server === '10.66.6.6') {
               output = `Connecting to ${server}...\n`;
               return { output, newCwd, action: 'irc_sim', data: { server, channel, nick } };
           } else {
               output = `irc: unable to connect to ${server}: Connection refused`;
           }
       }
       break;
    }
    case 'sqlmap': {
       const urlIndex = args.indexOf('-u');
       if (urlIndex !== -1 && args[urlIndex + 1]) {
           const url = args[urlIndex + 1];
           output = 'Starting sqlmap...';
           return { output, newCwd, action: 'sqlmap_sim', data: { target: url } };
       } else {
           output = 'Usage: sqlmap -u <url> [options]';
       }
       break;
    }
    case 'hashcat': {
       if (args.length < 2) {
           output = 'usage: hashcat [options] <hashfile> <wordlist>\n\nOptions:\n  -m 1400        SHA-256 mode\n  -a 0           Straight attack mode';
       } else {
           const hashFile = args.find(a => !a.startsWith('-') && (a.endsWith('.txt') || a.endsWith('.csv') || a.endsWith('.hash')));
           const wordList = args.find(a => !a.startsWith('-') && (a.endsWith('.txt') || a.endsWith('.lst')) && a !== hashFile);
           
           if (hashFile && wordList) {
               const node = getNode(resolvePath(cwd, hashFile));
               if (node && node.type === 'file') {
                   const content = node.content;
                   let targetHash = '';
                   
                   if (content.includes('5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8')) {
                       targetHash = '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8';
                       // Password: red_ledger
                   } else if (content.includes('5f4dcc3b5aa765d61d8327deb882cf99')) {
                       targetHash = '5f4dcc3b5aa765d61d8327deb882cf99'; // SHA1 for 'password'
                   }
                   
                   if (targetHash) {
                       output = 'Initializing hashcat v6.1.1...';
                       return { 
                           output, 
                           newCwd, 
                           action: 'crack_sim', 
                           data: { 
                               mode: 'hashcat', 
                               hash: targetHash, 
                               wordlist: wordList 
                           } 
                       };
                   } else {
                       output = 'hashcat: No valid hashes found in file.';
                   }
               } else {
                   output = `hashcat: ${hashFile}: No such file`;
               }
           } else {
               output = 'hashcat: missing hashfile or wordlist';
           }
       }
       break;
    }
    case 'cicada3301': {
       output = `
       .   .
      / \\ / \\
     (   Y   )
      \\  |  /
      /  |  \\
     (   |   )
      \\  |  /
       ' | '
         |
       3301
       
   Hello. We are looking for highly intelligent individuals.
   To find them, we have devised a test.
   
   There is a message hidden in this system.
   Find it, and it will lead you on the road to finding us.
   
   Good luck.
   
   (Hint: The message is hidden where the ghosts roam. Try 'man steghide' or check .onion sites)`;
       break;
    }
    case 'tor': {
       if (args.length < 1) {
           output = 'usage: tor <start|status|list|browse <onion_url>>';
       } else {
           const subcmd = args[0];
           const runDir = getNode('/var/run');
           const isRunning = runDir && runDir.type === 'dir' && runDir.children.includes('tor.pid');

           if (subcmd === 'start') {
               if (isRunning) {
                   output = 'Tor is already running.';
               } else {
                   // Check config first (systemctl mirror)
                   const torrc = getNode('/etc/tor/torrc');
                   if (!torrc || torrc.type !== 'file' || torrc.content.includes('InvalidPort')) {
                       output = '[ERROR] Tor failed to start. Configuration error in /etc/tor/torrc.\nSee "journalctl -xe" for details.';
                       const log = getNode('/var/log/syslog');
                       if (log && log.type === 'file') {
                           log.content += `\n${new Date().toUTCString()} tor[6666]: [err] Parsing config file /etc/tor/torrc failed: Syntax error: "InvalidPort" is not a valid option.`;
                       }
                       return { output, newCwd };
                   }

                   // Start via systemctl logic equivalent
                   if (runDir && runDir.type === 'dir') {
                       VFS['/var/run/tor.pid'] = { type: 'file', content: '6666' };
                       runDir.children.push('tor.pid');
                   }
                   output = 'Bootstrapping Tor circuit...';
                   return { output, newCwd, action: 'tor_sim', data: { mode: 'start' } };
               }
           } else if (subcmd === 'status') {
               if (isRunning) {
                   output = 'Tor is running (PID 6666).\nCircuit established: 3 hops.\nIdentity: Anonymous';
               } else {
                   output = 'Tor is not running.';
               }
           } else if (subcmd === 'list') {
               if (!isRunning) {
                   output = 'tor: service not running. (Use "tor start" or "systemctl start tor")';
               } else {
                   output = `[HIDDEN SERVICES DIRECTORY]
- silkroad7.onion        (Marketplace) [OFFLINE]
- dread55.onion          (Forum)       [ONLINE]
- ghostbox.onion         (Drop)        [ONLINE]
- cicada3301.onion       (Puzzle)      [UNKNOWN]`;
               }
           } else if (subcmd === 'browse') {
               if (args.length < 2) {
                   output = 'usage: tor browse <onion_url>';
               } else {
                   if (!isRunning) {
                       output = 'tor: connection failed: Tor service is not active.\n(Hint: Start the service first)';
                   } else {
                       const url = args[1];
                       output = `Connecting to ${url}...`;
                       return { output, newCwd, action: 'tor_sim', data: { mode: 'browse', url } };
                   }
               }
           } else {
               output = `tor: unknown command: ${subcmd}`;
           }
       }
       break;
    }
    case 'pip': {
       if (args.length < 2 || args[0] !== 'install') {
           output = 'usage: pip install <package>';
       } else {
           output = `Collecting ${args[1]}...\nDownloading ${args[1]}-1.0.0.tar.gz (1.2 MB)\nInstalling collected packages: ${args[1]}\nSuccessfully installed ${args[1]}-1.0.0`;
       }
       break;
    }
    case 'python':
    case 'python3': {
       if (args.length < 1) {
           output = 'Python 3.8.10 (default, Mar 15 2022, 12:22:08)\n[GCC 9.4.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> exit()\n(Interactive mode not supported)';
       } else {
           const fileName = args[0];
           const filePath = resolvePath(cwd, fileName);
           const node = getNode(filePath);
           
           if (!node) {
               output = `python: can't open file '${fileName}': [Errno 2] No such file or directory`;
           } else if (node.type === 'dir') {
               output = `/usr/bin/python3: can't find '__main__' module in '${fileName}'`;
           } else if (node.type === 'file') {
               // Cycle 61: Python Bytecode Reverse Engineering
               if (fileName.endsWith('.pyc')) {
                   // User trying to run .pyc directly?
                   output = `RuntimeError: Bad magic number in .pyc file`;
               } else if (fileName === 'decompile.py' || (node.content && node.content.includes('dis.dis'))) {
                   // Allow user to write a decompilation script?
                   // Or if they run `python3 -m dis auth.pyc` (args check needed)
               } 
               
               // Check for dis module usage in command
               if (args.includes('-m') && args.includes('dis') && args.some(a => a.endsWith('auth.pyc'))) {
                   output = `  1           0 LOAD_CONST               1 ('GHOST_ROOT{PYC_R3V3RS3_3NG1N33R}')
              2 STORE_NAME               0 (secret_key)
              4 LOAD_CONST               0 (None)
              6 RETURN_VALUE`;
                   
                   if (!VFS['/var/run/pyc_solved']) {
                       VFS['/var/run/pyc_solved'] = { type: 'file', content: 'TRUE' };
                       const runDir = getNode('/var/run');
                       if (runDir && runDir.type === 'dir' && !runDir.children.includes('pyc_solved')) {
                           runDir.children.push('pyc_solved');
                       }
                       output += `\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PYTHON BYTECODE REVERSED.\x1b[0m`;
                   }
                   return { output, newCwd, action: 'delay' };
               }

               // Simple mock interpreter
               const content = node.content;
               if (content.includes('import os') || content.includes('system(')) {
                   output = 'RuntimeError: Restricted environment. System calls disabled.';
               } else if (content.includes('print("This is a fake exploit.")')) {
                   output = 'This is a fake exploit.';
               } else if (fileName === 'exploit.py') {
                   // Fallback for exploit.py if content changed
                   output = '[*] Exploit started...\n[+] Target: 127.0.0.1\n[-] VULN NOT FOUND.';
               } else {
                   // Try to extract print statements
                   const printMatch = content.match(/print\s*\(['"](.+?)['"]\)/);
                   if (printMatch) {
                       output = printMatch[1];
                   } else {
                       output = ''; // No output
                   }
               }
           }
       }
       break;
    }
    case 'wget': {
      if (args.length < 1) {
          output = 'usage: wget <url>';
      } else {
          const url = args[0];
          // Mock download logic
          if (url.includes('firmware.bin') || url === 'http://192.168.1.99/files/firmware_v2.bin') {
               output = `--${new Date().toISOString().slice(0,19)}--  ${url}
Resolving 192.168.1.99... connected.
HTTP request sent, awaiting response... 200 OK
Length: 4194304 (4.0M) [application/octet-stream]
Saving to: firmware.bin

firmware.bin          100%[===================>]   4.00M  11.2MB/s    in 0.4s    

2026-02-10 14:02:55 (11.2 MB/s) - firmware.bin saved [4194304/4194304]`;
               
               const fName = 'firmware.bin';
               const fPath = resolvePath(cwd, fName);
               const parent = getNode(cwd);
               if (parent && parent.type === 'dir') {
                   // Create binary-looking content
                   VFS[fPath] = { type: 'file', content: 'MAGIC_HEADER: 0xDEADBEEF\n[BINARY_DATA_ENCRYPTED_Block1]\n... (4MB of data) ...\nPK_SIM_V1:{_hidden_key:SEKRET_KEY_99}\n[EOF]' };
                   if (!parent.children.includes(fName)) parent.children.push(fName);
               }
          } else if (url.includes('payload')) {
               output = `Downloading payload... [ERROR] 403 Forbidden`;
          } else {
               output = `--${new Date().toISOString().slice(0,19)}--  ${url}
Resolving host... failed: Name or service not known.
wget: unable to resolve host address`;
          }
      }
      break;
    }
    case 'binwalk': {
       const extract = args.includes('-e') || args.includes('--extract');
       const targetFile = args.find(a => !a.startsWith('-'));
       
       if (!targetFile) {
           output = 'binwalk: usage: binwalk [-e] <file>';
       } else {
           const fNode = getNode(resolvePath(cwd, targetFile));
           if (!fNode || fNode.type !== 'file') {
               output = `binwalk: ${targetFile}: No such file or directory`;
           } else {
               output = `DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             Unified Extensible Firmware Interface (UEFI) PI
4096          0x1000          Linux kernel ARM boot executable zImage (little-endian)
24554         0x5FEA          gzip compressed data, maximum compression, from Unix, last modified: 2026-01-15
88291         0x158E3         Squashfs filesystem, little endian, version 4.0, compression:gzip, size: 102422 bytes`;

               if ((fNode as any).content.includes('PK_SIM_V1')) {
                    output += `\n1048576       0x100000        Zip archive data, at least v2.0 to extract, compressed size: 412, uncompressed size: 1024, name: _hidden_key`;
               }

               if (extract) {
                   if ((fNode as any).content.includes('PK_SIM_V1')) {
                       output += `\n\n[INFO] Extraction initiated...
[+] Zip archive data found at 0x100000
[+] Extracting to '_${targetFile}.extracted/'...
[+] File '_hidden_key' extracted successfully.`;

                       const extractDir = `_${targetFile}.extracted`;
                       const extractPath = resolvePath(cwd, extractDir);
                       const parent = getNode(cwd);
                       if (parent && parent.type === 'dir') {
                           VFS[extractPath] = { type: 'dir', children: ['_hidden_key'] };
                           if (!parent.children.includes(extractDir)) parent.children.push(extractDir);
                           
                           VFS[`${extractPath}/_hidden_key`] = { type: 'file', content: 'KEY_PART_3: GHOST_ROOT{F1RMW4R3_R3V3RS3D}' };
                       }
                   } else {
                       output += `\n\n[INFO] Extraction initiated...
[!] No known file signatures found for extraction.`;
                   }
               }
           }
       }
       break;
    }
    case 'drone': {
       if (args.length < 1) {
           output = 'usage: drone <list|connect|status> [id]';
       } else {
           const subcmd = args[0];
           if (subcmd === 'list') {
               output = `Available Drones:
[ID: DR-01]  Model: RAVEN-X   - STATUS: CHARGING
[ID: DR-02]  Model: PHANTOM-4 - STATUS: ONLINE (Patrol Mode)
[ID: DR-99]  Model: BLACK-OPS - STATUS: [CLASSIFIED]`;
           } else if (subcmd === 'connect') {
               if (args.length < 2) {
                   output = 'usage: drone connect <id>';
               } else {
                   const id = args[1];
                   if (id === 'DR-02') {
                       output = 'Connecting to Drone DR-02...';
                       return { output, newCwd, action: 'drone_sim', data: { id } };
                   } else if (id === 'DR-99') {
                       output = 'drone: Connection refused (Encryption Key Required)';
                   } else {
                       output = `drone: ${id} not available or offline.`;
                   }
               }
           } else if (subcmd === 'status') {
               output = 'Drone Interface: STANDBY\nSignal: WEAK\nTelemetry: OFFLINE';
           } else {
               output = `drone: unknown subcommand: ${subcmd}`;
           }
       }
       break;
    }
    case 'bluetoothctl': {
       if (args.length === 0) {
           output = 'bluetoothctl: usage: bluetoothctl <command> [args]\n\nCommands:\n  scan <on/off>   - Start/stop scanning\n  devices         - List available devices\n  pair <mac>      - Pair with device\n  connect <mac>   - Connect to device\n  info <mac>      - Device information';
       } else {
           const cmd = args[0];
           if (cmd === 'scan') {
               if (args[1] === 'on') {
                   output = 'Discovery started\n[CHG] Controller 00:1A:7D:DA:71:13 Discovering: yes\n[NEW] Device 44:55:66:77:88:99 Unknown\n[NEW] Device A1:B2:C3:D4:E5:F6 J_Phone_13\n[NEW] Device 11:22:33:44:55:66 GHOST_BEACON_V1';
                   return { output, newCwd, action: 'delay' };
               } else {
                   output = 'Discovery stopped\n[CHG] Controller 00:1A:7D:DA:71:13 Discovering: no';
               }
           } else if (cmd === 'devices') {
               output = 'Device 44:55:66:77:88:99 Unknown\nDevice A1:B2:C3:D4:E5:F6 J_Phone_13\nDevice 11:22:33:44:55:66 GHOST_BEACON_V1';
           } else if (cmd === 'pair') {
               const mac = args[1];
               if (mac === '11:22:33:44:55:66') {
                   output = `Attempting to pair with ${mac}...\n[CHG] Device ${mac} Connected: yes\n[CHG] Device ${mac} Paired: yes\nPairing successful.`;
                   return { output, newCwd, action: 'delay' };
               } else if (mac) {
                   output = `Attempting to pair with ${mac}...\nFailed to pair: org.bluez.Error.AuthenticationFailed`;
                   return { output, newCwd, action: 'delay' };
               } else {
                   output = 'Usage: bluetoothctl pair <mac_address>';
               }
           } else if (cmd === 'connect') {
               const mac = args[1];
               if (mac === '11:22:33:44:55:66') {
                   output = `Attempting to connect to ${mac}...\nConnection successful.\n[NEW] Service 00001101-0000-1000-8000-00805f9b34fb Serial Port\n\nDevice sent message: "SEKRET_KEY_BT: 0xBLU3T00TH_GH0ST"`;
                   return { output, newCwd, action: 'delay' };
               } else {
                   output = `Failed to connect: org.bluez.Error.Failed`;
               }
           } else if (cmd === 'info') {
               const mac = args[1];
               if (mac === '11:22:33:44:55:66') {
                   output = `Device ${mac} (public)\n\tName: GHOST_BEACON_V1\n\tAlias: GHOST_BEACON_V1\n\tPaired: yes\n\tTrusted: yes\n\tBlocked: no\n\tConnected: no\n\tLegacyPairing: no\n\tUUID: Serial Port             (00001101-0000-1000-8000-00805f9b34fb)`;
               } else {
                   output = `Device ${mac} not found`;
               }
           } else {
               output = `bluetoothctl: invalid command: ${cmd}`;
           }
       }
       break;
    }
    case 'exiftool': {
        if (args.length < 1) {
            output = 'usage: exiftool <file>';
        } else {
            const target = args[0];
            const node = getNode(resolvePath(cwd, target));
            if (!node) {
                output = `exiftool: ${target}: No such file`;
            } else if (node.type === 'dir') {
                output = `exiftool: ${target}: Is a directory`;
            } else if (node.type === 'symlink') {
                output = `exiftool: ${target}: Is a symbolic link`;
            } else {
                const content = (node as any).content || '';
                // Check for Metadata Header in our mock format
                const match = content.match(/\[METADATA_HEADER\]([\s\S]*?)\[END_METADATA\]/);
                
                if (match) {
                    const metadata = match[1].trim().split('\n');
                    output = `ExifTool Version Number         : 12.00\nFile Name                       : ${target}\nFile Size                       : ${content.length} bytes\nFile Permissions                : rw-r--r--\n` + 
                             metadata.map((line: string) => {
                                 // Handle "UserComment" specially to support newlines or long text if needed
                                 const [key, ...valParts] = line.split(':');
                                 const val = valParts.join(':');
                                 if (!val) return line;
                                 return `${key.trim().padEnd(32)}: ${val.trim()}`;
                             }).join('\n');
                } else if (target === 'evidence.jpg' || content.startsWith('')) {
                    output = `ExifTool Version Number         : 12.00
File Name                       : ${target}
File Size                       : ${content.length} bytes
File Type                       : JPEG
MIME Type                       : image/jpeg
JFIF Version                    : 1.01
Resolution Unit                 : inches
X Resolution                    : 72
Y Resolution                    : 72
Image Width                     : 640
Image Height                    : 480
Encoding Process                : Baseline DCT, Huffman coding
Bits Per Sample                 : 8
Color Components                : 3
Y Cb Cr Sub Sampling            : YCbCr4:2:0 (2 2)
Comment                         : [HIDDEN_STEG_DATA_DETECTED]`;
                } else {
                    output = `ExifTool Version Number         : 12.00
File Name                       : ${target}
File Size                       : ${content.length} bytes
Error                           : Unknown file type`;
                }
            }
        }
        break;
    }
    case 'aircrack-ng': {
       if (args.length < 1) {
           output = 'usage: aircrack-ng [options] <.cap file>';
       } else {
           const fileTarget = args.find(a => !a.startsWith('-'));
           const wordlistArg = args.indexOf('-w');
           const wordlist = wordlistArg !== -1 ? args[wordlistArg + 1] : null;
           
           if (fileTarget) {
               const node = getNode(resolvePath(cwd, fileTarget));
               if (!node || node.type !== 'file') {
                   output = `aircrack-ng: ${fileTarget}: No such file`;
               } else {
                   // Check signature (mock)
                   if ((node as any).content.includes('HANDSHAKE') || fileTarget.endsWith('.cap')) {
                       if (wordlist) {
                           output = `Opening ${fileTarget}...\nReading wordlist ${wordlist}...`;
                           return { 
                               output, 
                               newCwd, 
                               action: 'crack_sim', 
                               data: { 
                                   mode: 'aircrack', 
                                   target: fileTarget, 
                                   success: true // Always success for demo if correct file
                               } 
                           };
                       } else {
                           output = 'aircrack-ng: Please specify a dictionary (wordlist) with -w';
                       }
                   } else {
                       output = `aircrack-ng: ${fileTarget}: Invalid pcap format (no handshake found)`;
                   }
               }
           } else {
               output = 'aircrack-ng: No capture file specified';
           }
       }
       break;
    }
    case 'cryptsetup': {
        if (args.length < 2) {
             output = 'usage: cryptsetup <action> <device> <name> [--passphrase <pass>]';
        } else {
             const action = args[0];
             const device = args[1];
             const name = args[2];
             
             if (action === 'luksOpen') {
                 if (!device || !name) {
                     output = 'usage: cryptsetup luksOpen <device> <name>';
                 } else if (device !== '/dev/sdb1') {
                     output = `Device ${device} is not a valid LUKS partition.`;
                 } else {
                     const passIndex = args.indexOf('--passphrase');
                     const pass = passIndex !== -1 ? args[passIndex+1] : null;
                     
                     if (pass === 'ghost_protocol_v4') {
                         output = `[cryptsetup] Slot 0 opened. Key material unwrapped.\n`;
                         
                         // Create /dev/mapper if missing
                         if (!VFS['/dev/mapper']) {
                             VFS['/dev/mapper'] = { type: 'dir', children: [] };
                             const dev = getNode('/dev');
                             if (dev && dev.type === 'dir' && !dev.children.includes('mapper')) dev.children.push('mapper');
                         }
                         
                         // Create symlink
                         const mapPath = `/dev/mapper/${name}`;
                         if (!VFS[mapPath]) {
                             VFS[mapPath] = { 
                                 type: 'symlink', 
                                 target: '/dev/dm-0',
                                 permissions: '0777' 
                             } as any;
                             const mapper = getNode('/dev/mapper');
                             if (mapper && mapper.type === 'dir' && !mapper.children.includes(name)) mapper.children.push(name);
                         }
                         
                         output += `/dev/mapper/${name} is now active.`;
                     } else {
                         output = `No key available with this passphrase.\n(HINT: Use --passphrase <pass> for simulation)`;
                     }
                 }
             } else {
                 output = `cryptsetup: unknown action ${action}`;
             }
        }
        break;
    }
    case 'mount': {
        if (args.length < 2) {
             output = 'usage: mount <device> <dir>';
        } else {
             const device = args[0];
             const dir = args[1];
             const dirPath = resolvePath(cwd, dir);
             const dirNode = getNode(dirPath);
             
             if (!dirNode || dirNode.type !== 'dir') {
                 output = `mount: mount point ${dir} does not exist`;
             } else {
                 if (device === '/dev/sdb1') {
                     output = `mount: unknown filesystem type 'crypto_LUKS'`;
                 } else if (device.startsWith('/dev/mapper/')) {
                     const mapperName = device.split('/').pop();
                     const mapPath = `/dev/mapper/${mapperName}`;
                     if (getNode(mapPath)) {
                         output = `mount: /dev/mapper/${mapperName} mounted on ${dir}.`;
                         
                         // Create secure content inside mount point
                         const secureFile = 'top_secret.txt';
                         const securePath = dirPath === '/' ? `/${secureFile}` : `${dirPath}/${secureFile}`;
                         
                         VFS[securePath] = { 
                             type: 'file', 
                             content: 'FLAG: GHOST_ROOT{LUKS_P4RT1T10N_D3CRYPT3D}\n[DATA] 0x5F3A... [CLASSIFIED]' 
                         };
                         
                         if (!dirNode.children.includes(secureFile)) dirNode.children.push(secureFile);
                         
                         // Mission Update
                         if (!VFS['/var/run/luks_solved']) {
                             VFS['/var/run/luks_solved'] = { type: 'file', content: 'TRUE' };
                             const runDir = getNode('/var/run');
                             if (runDir && runDir.type === 'dir' && !runDir.children.includes('luks_solved')) {
                                 runDir.children.push('luks_solved');
                             }
                             output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ENCRYPTED VOLUME MOUNTED.\x1b[0m`;
                         }
                     } else {
                         output = `mount: special device ${device} does not exist`;
                     }
                 } else {
                     output = `mount: ${device} is not a valid block device (or already mounted)`;
                 }
             }
        }
        break;
    }
    case 'umount': {
        if (args.length < 1) {
             output = 'usage: umount <dir>';
        } else {
             output = 'umount: unmounted successfully (simulated)';
        }
        break;
    }
    case 'geoip': {
        if (args.length < 1) {
            output = 'usage: geoip <ip_address>';
        } else {
            const ip = args[0];
            const locations: Record<string, any> = {
                '192.168.1.99': { country: 'Unknown', city: 'Classified', lat: '??.????', lon: '??.????', isp: 'Satellite Uplink' },
                '10.66.6.6': { country: 'Russia', city: 'Oymyakon (Siberia)', lat: '63.4641', lon: '142.7737', isp: 'Black Site Node' },
                '172.16.66.6': { country: 'Russia', city: 'Oymyakon (Siberia)', lat: '63.4641', lon: '142.7737', isp: 'Black Site Link' },
                '8.8.8.8': { country: 'United States', city: 'Mountain View, CA', lat: '37.4056', lon: '-122.0775', isp: 'Google LLC' },
                '1.1.1.1': { country: 'United States', city: 'Los Angeles, CA', lat: '34.0522', lon: '-118.2437', isp: 'Cloudflare, Inc.' },
                '192.168.1.5': { country: 'Local Network', city: 'Admin Office', lat: '0.0000', lon: '0.0000', isp: 'LAN' },
                '127.0.0.1': { country: 'Localhost', city: 'Home', lat: '0.0000', lon: '0.0000', isp: 'Loopback' }
            };

            const data = locations[ip];
            if (data) {
                output = `
GeoIP Target: ${ip}
----------------------------------------
Country:      ${data.country}
City:         ${data.city}
Latitude:     ${data.lat}
Longitude:    ${data.lon}
ISP:          ${data.isp}
----------------------------------------`;
            } else if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(ip)) {
                const parts = ip.split('.');
                const octet = parseInt(parts[0]);
                let country = 'United States';
                let city = 'Unknown';
                
                if (octet > 200) { country = 'Russia'; city = 'Moscow'; }
                else if (octet > 150) { country = 'China'; city = 'Beijing'; }
                else if (octet > 100) { country = 'Germany'; city = 'Berlin'; }
                else if (octet > 50) { country = 'United Kingdom'; city = 'London'; }
                
                output = `
GeoIP Target: ${ip}
----------------------------------------
Country:      ${country}
City:         ${city}
Latitude:     ${(Math.random() * 180 - 90).toFixed(4)}
Longitude:    ${(Math.random() * 360 - 180).toFixed(4)}
ISP:          Generic ISP Node
----------------------------------------`;
            } else {
                output = `geoip: ${ip}: Invalid IP address`;
            }
        }
        break;
    }
    case 'volatility': {
       if (args.length < 3) {
           output = 'usage: volatility -f <dump_file> <plugin>\nPlugins: imageinfo, pslist, cmdline, netscan';
       } else {
           const fileIdx = args.indexOf('-f');
           if (fileIdx === -1 || !args[fileIdx+1]) {
               output = 'volatility: missing -f argument';
           } else {
               const dumpFile = args[fileIdx+1];
               const plugin = args.find(a => a !== '-f' && a !== dumpFile);
               
               const node = getNode(resolvePath(cwd, dumpFile));
               if (!node || node.type !== 'file') {
                   output = `volatility: ${dumpFile}: No such file or directory`;
               } else {
                   // Check for magic header
                   if ((node as any).content.startsWith('\x7fELF') || dumpFile.endsWith('.dump') || dumpFile.endsWith('.dmp')) {
                       if (plugin === 'imageinfo') {
                           output = `Volatility Foundation Volatility Framework 2.6
INFO    : volatility.debug    : Determining profile based on KDBG search...
          Suggested Profile(s) : LinuxGhost5.4x64, LinuxDebian5.4x64
                     AS Layer1 : LinuxAMD64PagedMemory (Kernel AS)
                     AS Layer2 : FileAddressSpace (${dumpFile})
                      PAE type : No PAE
                           DTB : 0x1a2b3c00L
                          KDBG : 0xdeadbeefL`;
                       } else if (plugin === 'pslist') {
                           output = `Volatility Foundation Volatility Framework 2.6
Offset             Name                 Pid             PPid            Uid             Gid    DTB                Start Time
------------------ -------------------- --------------- --------------- --------------- ------ ------------------ ----------
0xffff8800bd8d8000 systemd              1               0               0               0      0x00000000bd8d8000 2026-10-23 09:00:00 UTC+0000
0xffff8800bd8d9000 kthreadd             2               0               0               0      0x00000000bd8d9000 2026-10-23 09:00:00 UTC+0000
0xffff8800bd8da000 sshd                 404             1               0               0      0x00000000bd8da000 2026-10-23 10:00:00 UTC+0000
0xffff8800bd8db000 bash                 1337            404             1000            1000   0x00000000bd8db000 2026-10-23 11:00:00 UTC+0000
0xffff8800bd8dc000 nc                   1338            1337            1000            1000   0x00000000bd8dc000 2026-10-23 14:02:00 UTC+0000
0xffff8800bd8dd000 phantom_process      666             1               0               0      0x00000000bd8dd000 2026-10-23 14:45:00 UTC+0000`;
                       } else if (plugin === 'cmdline') {
                           output = `Volatility Foundation Volatility Framework 2.6
************************************************************************
pid: 1      Command line : /sbin/init
************************************************************************
pid: 404    Command line : /usr/sbin/sshd -D
************************************************************************
pid: 1337   Command line : -bash
************************************************************************
pid: 666    Command line : ./phantom_process --backdoor --port 45678 --key GHOST_ROOT{M3M0RY_L34K_D3T3CT3D}
************************************************************************
pid: 1338   Command line : nc -l -p 1337 -e /bin/bash`;
                       } else if (plugin === 'netscan') {
                           output = `Volatility Foundation Volatility Framework 2.6
Offset             Proto    Local Address                  Foreign Address                State        Pid      Owner
0xffff880036d07c00 TCP      0.0.0.0:22                     0.0.0.0:0                      LISTEN       404      sshd
0xffff880036d07c00 TCP      0.0.0.0:45678                  0.0.0.0:0                      LISTEN       666      phantom_process
0xffff880036d07c00 TCP      127.0.0.1:1337                 0.0.0.0:0                      LISTEN       1338     nc`;
                       } else {
                           output = `volatility: unknown plugin '${plugin}'`;
                       }
                   } else {
                       output = `volatility: ${dumpFile}: Not a valid memory dump (ELF header missing)`;
                   }
               }
           }
       }
       break;
    }
    case 'lsblk': {
       const isMounted = !!MOUNTED_DEVICES['/dev/sdb1'];
       output = `NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0    64G  0 disk 
sda1   8:1    0    64G  0 part /
sdb      8:16   1    32G  0 disk 
sdb1   8:17   1    32G  0 part ${isMounted ? MOUNTED_DEVICES['/dev/sdb1'] : ''}
loop0    7:0    0   128M  0 loop /snap/core/1
loop1    7:1    0    64M  0 loop /snap/gtk-common-themes/15`;
       break;
    }
    case 'fdisk': {
       if (args.includes('-l')) {
           output = `Disk /dev/sda: 64 GiB, 68719476736 bytes, 134217728 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: A1B2C3D4-E5F6-7890-1234-567890ABCDEF

Device     Start       End   Sectors Size Type
/dev/sda1   2048 134217694 134215647  64G Linux filesystem

Disk /dev/sdb: 32 GiB, 34359738368 bytes, 67108864 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xdeadbeef

Device     Boot Start      End  Sectors Size Id Type
/dev/sdb1        2048 67108863 67106816  32G 83 Linux`;
       } else {
           output = 'fdisk: permission denied (try -l to list partition tables)';
       }
       break;
    }
    case 'mkswap': {
       if (args.length < 1) {
           output = 'usage: mkswap <device>';
       } else {
           const dev = args[0];
           const path = resolvePath(cwd, dev);
           const node = getNode(path);
           
           if (!node) {
               output = `mkswap: cannot open ${dev}: No such file or directory`;
           } else if (path !== '/dev/sdb2') {
               output = `mkswap: error: ${dev} is mounted; will not make swapspace.`;
           } else {
               // Update content signature
               (node as any).content = 'SWAPSPACE2';
               output = `Setting up swapspace version 1, size = 4 GiB (4294967296 bytes)\nno label, UUID=a1b2c3d4-e5f6-7890-1234-567890abcdef`;
           }
       }
       break;
    }
    case 'swapon': {
       if (args.length < 1) {
           if (args.includes('-s')) {
               if (VFS['/var/run/swap_active']) {
                   output = `Filename\t\t\t\tType\t\tSize\tUsed\tPriority\n/dev/sdb2\t\t\t\tpartition\t4194300\t0\t-2`;
               } else {
                   output = `Filename\t\t\t\tType\t\tSize\tUsed\tPriority`;
               }
           } else {
               output = 'usage: swapon <device>';
           }
       } else {
           const dev = args[0];
           if (dev === '-s') return { output, newCwd }; // handled above if args check logic was different, but here args[0] is -s
           
           const path = resolvePath(cwd, dev);
           const node = getNode(path);
           
           if (!node) {
               output = `swapon: cannot open ${dev}: No such file or directory`;
           } else {
               const content = (node as any).content;
               if (content !== 'SWAPSPACE2') {
                   output = `swapon: ${dev}: read swap header failed`;
               } else {
                   output = ''; // Silent success
                   
                   if (!VFS['/var/run/swap_active']) {
                        VFS['/var/run/swap_active'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('swap_active')) {
                            runDir.children.push('swap_active');
                        }
                        
                        if (!VFS['/var/run/swap_solved']) {
                            VFS['/var/run/swap_solved'] = { type: 'file', content: 'TRUE' };
                            const runDir = getNode('/var/run');
                            if (runDir && runDir.type === 'dir' && !runDir.children.includes('swap_solved')) {
                                runDir.children.push('swap_solved');
                            }
                            output = `\x1b[1;32m[MISSION UPDATE] Objective Complete: MEMORY PRESSURE RELIEVED.\x1b[0m\nFLAG: GHOST_ROOT{SW4P_SP4C3_SAV10R}`;
                        }
                   }
               }
           }
       }
       break;
    }
    case 'free': {
       const isSwap = !!VFS['/var/run/swap_active'];
       if (args.includes('-h')) {
           output = `              total        used        free      shared  buff/cache   available
Mem:           1.9G        1.8G         50M         12M        100M         20M
Swap:          ${isSwap ? '4.0G' : '0B'}          0B        ${isSwap ? '4.0G' : '0B'}`;
       } else {
           output = `              total        used        free      shared  buff/cache   available
Mem:        2048000     1887436       51200       12288      102400       20480
Swap:       ${isSwap ? '4194304' : '0'}           0     ${isSwap ? '4194304' : '0'}`;
       }
       break;
    }
    case 'status': {
        const { objectives, progress, nextStep, rank } = getMissionStatus();
        const { hasNet, hasScan, hasIntel, decryptCount, isRoot, hasBlackSite, hasPayload, hasLaunchReady } = objectives;

        const color = (cond: boolean) => cond ? '\x1b[1;32m[COMPLETE]\x1b[0m' : '\x1b[1;30m[PENDING ]\x1b[0m';
        const barLen = 20;
        const filled = Math.round((progress / 100) * barLen);
        const bar = ''.repeat(filled) + ''.repeat(barLen - filled);

        output = `
\x1b[1;36m
   GHOST_ROOT OPERATION TRACKER v2.1      
\x1b[0m
AGENT RANK: ${rank.toUpperCase()}
PROGRESS:   ${progress}% [${bar}]

\x1b[1;33mCURRENT OBJECTIVES:\x1b[0m
 1. Establish Network Link (wifi)     ${color(hasNet)}
 2. Reconnaissance (scan/nmap)        ${color(hasScan)}
 3. Privilege Escalation (root)       ${color(isRoot)}
 4. Breach Black Site (ssh)           ${color(hasBlackSite)}
 5. Acquire Payload (sat)             ${color(hasPayload)}
 6. Recover Intel (decrypt keys)      ${color(decryptCount >= 3)} [${decryptCount}/3]
 7. System Liberation                 ${color(hasLaunchReady)}

\x1b[1;31m>>> ACTIVE DIRECTIVE: ${nextStep}\x1b[0m
\x1b[1;30m(Type 'hint' or 'man <tool>' for assistance)\x1b[0m
`;
        break;
    }
    case 'medscan':
    case 'biomon': {
        output = 'Initializing biometric sensors...';
        return { output, newCwd, action: 'medscan_sim' };
    }
    case 'type': {
       if (args.length < 1) {
           output = 'type: usage: type <command>';
       } else {
           const cmd = args[0];
           if (ALIASES[cmd]) {
               output = `${cmd} is aliased to \`${ALIASES[cmd]}\``;
           } else if (COMMANDS.includes(cmd)) {
               output = `${cmd} is /usr/bin/${cmd}`;
           } else {
               output = `bash: type: ${cmd}: not found`;
           }
       }
       break;
    }
    case 'unalias': {
        if (args.length < 1) {
            output = 'unalias: usage: unalias <name>';
        } else {
            const name = args[0];
            if (ALIASES[name]) {
                delete ALIASES[name];
                output = ''; 
                // Cycle 107 Check (The Alias Trap)
                if (name === 'ls') {
                    output = '[SUCCESS] File System Index Restored.\\nFLAG: GHOST_ROOT{4L14S_UNM4SK3D}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM RESTORED.\\x1b[0m';
                    if (!VFS['/var/run/alias_solved']) {
                        VFS['/var/run/alias_solved'] = { type: 'file', content: 'TRUE' };
                    }
                }
            } else {
                output = `bash: unalias: ${name}: not found`;
            }
        }
        break;
    }
    case 'jobs': {
        if (JOBS.length === 0) {
            output = 'jobs: no active jobs';
        } else {
            output = JOBS.map(j => `[${j.id}]+  ${j.status.padEnd(10)} ${j.command}`).join('\n');
        }
        break;
    }
    case 'fg': {
        const jobId = args.length > 0 ? parseInt(args[0].replace('%', '')) : 1;
        const job = JOBS.find(j => j.id === jobId);

        if (!job) {
            output = `fg: job ${jobId} not found`;
        } else {
            // Remove job from list (simulating completion for this puzzle)
            JOBS = JOBS.filter(j => j.id !== jobId);
            
            output = `${job.command}\n`;
            
            if (job.command.includes('decrypt_chimera')) {
                output += `[SYSTEM] Resuming decryption process (PID ${job.pid})...\n[====================] 100%\n[SUCCESS] CHIMERA PROTOCOL DECRYPTED.\n\nPAYLOAD: GHOST_ROOT{J0B_C0NTR0L_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BACKGROUND PROCESS RECOVERED.\x1b[0m`;
                
                // Mission Update Flag
                if (!VFS['/var/run/chimera_decrypted']) {
                    VFS['/var/run/chimera_decrypted'] = { type: 'file', content: 'TRUE' };
                    const runDir = getNode('/var/run');
                    if (runDir && runDir.type === 'dir' && !runDir.children.includes('chimera_decrypted')) {
                        runDir.children.push('chimera_decrypted');
                    }
                }
            } else {
                output += `[PROCESS COMPLETED]`;
            }
        }
        break;
    }
    case 'bg': {
        const jobId = args.length > 0 ? parseInt(args[0].replace('%', '')) : 1;
        const job = JOBS.find(j => j.id === jobId);

        if (!job) {
            output = `bg: job ${jobId} not found`;
        } else {
            job.status = 'Running';
            output = `[${job.id}]+ ${job.command} &`;
        }
        break;
    }
    case 'uplink_connect': {
        if (ENV_VARS['UPLINK_KEY'] === 'XJ9-SAT-442') {
            output = `[UPLINK] Initiating connection to OMEGA-SAT-1...\n[STATUS] Handshake Complete (Key Verified).\n[DATA] Downloading payload...\n\nPayload: GHOST_ROOT{ENV_V4R_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SATELLITE UPLINK SECURED.\x1b[0m`;
            
            if (!VFS['/var/run/uplink_established']) {
                VFS['/var/run/uplink_established'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('uplink_established')) {
                    runDir.children.push('uplink_established');
                }
            }
             return { output, newCwd, action: 'sat_sim' };
        } else {
            output = 'uplink: CONNECTION REFUSED (Auth Failed)\n[ERROR] Environment variable UPLINK_KEY missing or invalid.\n[HINT] Check /etc/uplink.conf for protocol details.';
        }
        break;
    }
    case 'beacon': {
        output = 'Beacon started (PID 9999) in background.\n(Listening on localhost:4444...)\n';
        return { output, newCwd };
    }
    case 'openssl': {
        if (args[0] === 'enc' && args.includes('-d') && args.includes('-aes-256-cbc')) {
            const inIdx = args.indexOf('-in');
            const outIdx = args.indexOf('-out');
            const kIdx = args.indexOf('-k');
            
            const inFile = inIdx !== -1 ? args[inIdx + 1] : null;
            const outFile = outIdx !== -1 ? args[outIdx + 1] : null;
            const key = kIdx !== -1 ? args[kIdx + 1] : null;
            
            if (!inFile || !outFile || !key) {
                output = 'openssl: missing required arguments';
            } else {
                const inPath = resolvePath(cwd, inFile);
                const inNode = getNode(inPath);
                
                if (!inNode || inNode.type !== 'file') {
                    output = `openssl: ${inFile}: No such file`;
                } else if (key !== 'aes-256-key-0xDEADBEEF' && key !== 'PROTOCOL_NAME_V1') {
                    output = 'bad decrypt';
                } else {
                    const outPath = resolvePath(cwd, outFile);
                    const parentDir = resolvePath(outPath, '..');
                    const fileName = outPath.split('/').pop();
                    const parentNode = getNode(parentDir);
                    
                    if (parentNode && parentNode.type === 'dir' && fileName) {
                        if (inFile.includes('blackbox.enc')) {
                             VFS[outPath] = { 
                                type: 'file', 
                                content: `[DECRYPTED DATA]\n\nTARGET_ID: 99-ZULU\nCOORDINATES: 51.5074 N, 0.1278 W\n\nMESSAGE: The asset is in place. Operation 'Black Widow' is a go.\nFLAG: GHOST_ROOT{0P3NSSL_M4ST3R}` 
                            };
                            if (!parentNode.children.includes(fileName)) parentNode.children.push(fileName);
                            
                            output = 'decryption successful';
                            if (!VFS['/var/run/decrypt_count']) {
                                VFS['/var/run/decrypt_count'] = { type: 'file', content: '1' };
                            } else {
                                const node = VFS['/var/run/decrypt_count'];
                                const count = (node && node.type === 'file') ? parseInt(node.content) : 0;
                                if (node && node.type === 'file') node.content = String(count + 1);
                            }
                        } else if (inFile.includes('omega_blueprint')) {
                             VFS[outPath] = { 
                                type: 'file', 
                                content: `[BLUEPRINT RECOVERED]\n\nPROJECT OMEGA\n..................\n(ASCII ART OF A DOOMSDAY DEVICE)\n\nCRITICAL COMPONENT: The key to the vault is hidden in the 'steghide' password list.\n\nFLAG: GHOST_ROOT{R4NS0MW4R3_D3F34T3D}` 
                            };
                            if (!parentNode.children.includes(fileName)) parentNode.children.push(fileName);
                            output = 'decryption successful\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BLUEPRINTS RECOVERED.\x1b[0m';
                        } else {
                            output = 'decryption successful';
                        }
                    } else {
                        output = `openssl: ${outFile}: No such directory`;
                    }
                }
            }
        } else {
            output = 'openssl: usage: openssl enc -d -aes-256-cbc -in <file> -out <file> -k <key>';
        }
        break;
    }
    case 'docker': {
        const subcmd = args[0];
        if (args.length < 1) {
             output = `Usage: docker [OPTIONS] COMMAND\n\nCommands:\n  ps          List containers\n  run         Run a command in a new container\n  stop        Stop one or more running containers\n  rm          Remove one or more containers\n  inspect     Return low-level information on Docker objects\n  logs        Fetch the logs of a container`;
        } else if (subcmd === 'ps') {
             output = `CONTAINER ID   IMAGE                 COMMAND                  CREATED        STATUS          PORTS                    NAMES
a1b2c3d4e5f6   ghost-relay:latest    "/bin/sh -c 'while..."   2 hours ago    Up 2 hours      0.0.0.0:8080->80/tcp     ghost-relay
f9e8d7c6b5a4   secure-vault:v1.2     "/vault/keeper"          4 days ago     Up 4 days       0.0.0.0:9000->9000/tcp   secure-vault
1234567890ab   postgres:14-alpine    "docker-entrypoint..."   5 days ago     Exited (0)                               db-primary`;
        } else if (subcmd === 'images') {
             output = `REPOSITORY          TAG       IMAGE ID       CREATED        SIZE
ghost-relay         latest    a1b2c3d4e5f6   2 hours ago    156MB
secure-vault        v1.2      f9e8d7c6b5a4   4 days ago     89MB
postgres            14-alpine 1234567890ab   5 days ago     214MB`;
        } else if (subcmd === 'inspect') {
             if (args.length < 2) {
                 output = 'docker inspect: requires at least 1 argument.';
             } else {
                 const id = args[1];
                 if (id.startsWith('f9e8') || id === 'secure-vault') {
                      output = `[
    {
        "Id": "f9e8d7c6b5a4...",
        "Created": "2026-02-05T12:00:00.000000000Z",
        "Path": "/vault/keeper",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Pid": 4001
        },
        "Image": "sha256:f9e8d7c6b5a4...",
        "Name": "/secure-vault",
        "Config": {
            "Hostname": "f9e8d7c6b5a4",
            "Domainname": "",
            "User": "",
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "VAULT_MODE=locked",
                "VAULT_KEY=GHOST_ROOT{C0NT41N3R_3SC4P3}",
                "MAX_RETRIES=3"
            ],
            "Cmd": [
                "/vault/keeper"
            ]
        }
    }
]`;
                      // Mission update: Found Flag
                      if (!VFS['/var/run/docker_flag']) {
                          VFS['/var/run/docker_flag'] = { type: 'file', content: 'TRUE' };
                          const runDir = getNode('/var/run');
                          if (runDir && runDir.type === 'dir' && !runDir.children.includes('docker_flag')) {
                              runDir.children.push('docker_flag');
                          }
                          output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: CONTAINER INSPECTED.\x1b[0m`;
                      }

                 } else if (id.startsWith('a1b2') || id === 'ghost-relay') {
                      output = `[
    {
        "Id": "a1b2c3d4e5f6...",
        "Name": "/ghost-relay",
        "Config": {
            "Env": [
                "RELAY_HOST=192.168.1.99"
            ]
        }
    }
]`;
                 } else {
                      output = `Error: No such object: ${id}`;
                 }
             }
        } else if (subcmd === 'logs') {
             const id = args[1];
             if (!id) {
                 output = 'docker logs: requires exactly 1 argument.';
             } else if (id.startsWith('f9e8') || id === 'secure-vault') {
                 output = `[VAULT] Starting service version 1.2
[VAULT] Loading configuration from ENV...
[VAULT] Warning: VAULT_KEY is exposed in environment variables.
[VAULT] Service listening on port 9000
[VAULT] Access attempt from 172.17.0.1: Denied.`;
             } else if (id.startsWith('a1b2') || id === 'ghost-relay') {
                 output = `[RELAY] Initializing secure connection...
[RELAY] Connection established to 192.168.1.99
[RELAY] Heartbeat sent.`;
             } else {
                 output = `Error: No such container: ${id}`;
             }
        } else if (subcmd === 'stop') {
             const id = args[1];
             if (!id) {
                 output = 'docker stop: requires at least 1 argument.';
             } else if (id.startsWith('a1b2') || id === 'ghost-relay') {
                 output = `${id}`;
             } else if (id.startsWith('f9e8') || id === 'secure-vault') {
                 output = `Error response from daemon: cannot stop container: ${id}: permission denied`;
             } else {
                 output = `Error: No such container: ${id}`;
             }
        } else if (subcmd === 'run') {
             // docker run -v /:/mnt -it alpine cat /mnt/root/shadow_config.yml
            const vIndex = args.indexOf('-v');
            const imageIndex = args.findIndex(a => ['alpine', 'ubuntu', 'secure-vault', 'busybox', 'ghost-relay'].some(img => a.includes(img)));
            
            if (imageIndex === -1) {
                output = 'docker run: requires a valid image (alpine, ubuntu, secure-vault, ghost-relay)';
            } else {
                let mountSource = '';
                let mountTarget = '';
                
                if (vIndex !== -1 && args[vIndex + 1]) {
                    const mountParts = args[vIndex + 1].split(':');
                    if (mountParts.length >= 2) {
                        mountSource = mountParts[0];
                        mountTarget = mountParts[1];
                    }
                }

                const commandToRun = args.slice(imageIndex + 1);
                
                if (commandToRun.length > 0) {
                    const cmd = commandToRun[0];
                    const cmdArgs = commandToRun.slice(1);
                    
                    if (cmd === 'cat') {
                        const targetFile = cmdArgs[0];
                        let resolvedPath = targetFile;
                        
                        // Volume Mapping Logic
                        if (mountSource === '/' && targetFile.startsWith(mountTarget)) {
                            // Strip mount target prefix to get host path
                            const relativePath = targetFile.substring(mountTarget.length);
                            resolvedPath = relativePath.startsWith('/') ? relativePath : '/' + relativePath;
                            
                            // Check host VFS
                            const node = getNode(resolvedPath);
                            if (node && node.type === 'file') {
                                output = node.content;
                                
                                // Specific Puzzle Flag
                                if (resolvedPath === '/root/shadow_config.yml') {
                                     if (!VFS['/var/run/docker_esc_solved']) {
                                         VFS['/var/run/docker_esc_solved'] = { type: 'file', content: 'TRUE' };
                                         const runDir = getNode('/var/run');
                                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('docker_esc_solved')) {
                                             runDir.children.push('docker_esc_solved');
                                         }
                                         output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DOCKER ESCAPE (PRIVILEGE ESCALATION).\x1b[0m';
                                     }
                                }
                            } else {
                                output = `cat: ${targetFile}: No such file or directory`;
                            }
                        } else {
                            output = `cat: ${targetFile}: No such file or directory (Container FS is empty)`;
                        }
                    } else if (['/bin/bash', '/bin/sh', 'bash', 'sh'].includes(cmd)) {
                         output = `root@container:/# `;
                         return { output, newCwd: '/', newPrompt: 'root@container:/# ', action: 'delay' };
                    } else {
                         output = `docker: executable file not found in $PATH: ${cmd}`;
                    }
                } else {
                    // Interactive Shell Default
                    output = `root@container:/# `;
                    return { output, newCwd: '/', newPrompt: 'root@container:/# ', action: 'delay' };
                }
            }
        } else {
             output = `docker: '${subcmd}' is not a docker command.`;
        }
        break;
    }
    case 'lsmod': {
        let out = 'Module                  Size  Used by\n';
        out += 'iptable_filter         12810  1\n';
        out += 'ip_tables              27126  1 iptable_filter\n';
        out += 'x_tables               29641  1 ip_tables\n';
        if (VFS['/proc/backdoor']) {
            out += 'backdoor               13370  0\n';
        }
        output = out;
        break;
    }
    case 'insmod': {
        if (args.length < 1) {
            output = 'insmod: usage: insmod <module_file>';
        } else {
            const fileTarget = args[0];
            const filePath = resolvePath(cwd, fileTarget);
            const node = getNode(filePath);
            
            if (!node) {
                output = `insmod: ERROR: could not insert module ${fileTarget}: No such file or directory`;
            } else if (node.type !== 'file') {
                 output = `insmod: ERROR: could not insert module ${fileTarget}: Not a file`;
            } else if (!filePath.endsWith('.ko')) {
                 output = `insmod: ERROR: could not insert module ${fileTarget}: Invalid module format`;
            } else if (filePath.includes('backdoor.ko')) {
                 if (VFS['/proc/backdoor']) {
                     output = `insmod: ERROR: could not insert module ${fileTarget}: Module already loaded`;
                 } else {
                     VFS['/proc/backdoor'] = { type: 'file', content: 'GHOST_ROOT{K3RN3L_M0DUL3_H4CK}\n' };
                     const proc = getNode('/proc');
                     if (proc && proc.type === 'dir' && !proc.children.includes('backdoor')) {
                         proc.children.push('backdoor');
                     }
                     output = '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL MODULE BACKDOOR.\x1b[0m';
                 }
            } else {
                 output = `insmod: ERROR: could not insert module ${fileTarget}: Operation not permitted`;
            }
        }
        break;
    }
    case 'rmmod': {
        if (args.length < 1) {
            output = 'rmmod: usage: rmmod <module_name>';
        } else {
            const modName = args[0];
            if (modName === 'backdoor') {
                if (VFS['/proc/backdoor']) {
                    delete VFS['/proc/backdoor'];
                    const proc = getNode('/proc');
                    if (proc && proc.type === 'dir') {
                        proc.children = proc.children.filter(c => c !== 'backdoor');
                    }
                    output = ''; // Silent success
                } else {
                    output = `rmmod: ERROR: Module ${modName} is not currently loaded`;
                }
            } else if (['iptable_filter', 'ip_tables', 'x_tables'].includes(modName)) {
                output = `rmmod: ERROR: Module ${modName} is in use`;
            } else {
                output = `rmmod: ERROR: Module ${modName} is not currently loaded`;
            }
        }
        break;
    }
    case 'getfattr': {
        if (args.length === 0) {
            output = 'Usage: getfattr [-d] [-n name] <file>';
        } else {
            const fileName = args[args.length - 1]; 
            const showAll = args.includes('-d');
            const nameIndex = args.indexOf('-n');
            const requestedName = nameIndex !== -1 && args[nameIndex + 1] ? args[nameIndex + 1] : null;

            const filePath = resolvePath(cwd, fileName);
            const node = getNode(filePath);

            if (!node) {
                output = `getfattr: ${fileName}: No such file or directory`;
            } else if (node.type !== 'file') {
                output = `getfattr: ${fileName}: Not a regular file`;
            } else {
                const fileNode = node as any;
                if (!fileNode.xattrs || Object.keys(fileNode.xattrs).length === 0) {
                    output = ''; 
                } else {
                    let buffer = `# file: ${fileName}\n`;
                    let hasOutput = false;
                    for (const [key, val] of Object.entries(fileNode.xattrs)) {
                        if (showAll || requestedName === key) {
                             buffer += `${key}="${val}"\n`;
                             hasOutput = true;
                             
                             // Puzzle Solve Check
                             if ((val as string).includes('GHOST_ROOT{ALT_D4T4_STR34M_FOUND}')) {
                                  // Update Mission State
                                  if (!VFS['/var/run/xattr_solved']) {
                                      VFS['/var/run/xattr_solved'] = { type: 'file', content: 'TRUE' };
                                      const runDir = getNode('/var/run');
                                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('xattr_solved')) {
                                          runDir.children.push('xattr_solved');
                                      }
                                      buffer += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ALTERNATE DATA STREAM (XATTR).\x1b[0m';
                                  }
                             }
                        }
                    }
                    output = hasOutput ? buffer : ''; 
                }
            }
        }
        break;
    }
    case 'lsattr': {
        if (args.length < 1) {
            output = 'Usage: lsattr [OPTION]... [FILE]...';
        } else {
            const fileName = args[args.length - 1]; 
            const filePath = resolvePath(cwd, fileName);
            const node = getNode(filePath);

            if (!node) {
                output = `lsattr: ${fileName}: No such file or directory`;
            } else if (node.type !== 'file') {
                output = `lsattr: ${fileName}: Inappropriate ioctl for device`;
            } else {
                const attrs = FILE_ATTRIBUTES[filePath] || [];
                const attrStr = '----' + (attrs.includes('i') ? 'i' : '-') + '---------';
                output = `${attrStr} ${fileName}`;
            }
        }
        break;
    }
    case 'chattr': {
        if (args.length < 2) {
            output = 'Usage: chattr [-+=aAcCdDeijsStTu] [files...]';
        } else {
            const modeArg = args[0];
            const fileName = args[1];
            const filePath = resolvePath(cwd, fileName);
            const isRoot = !!getNode('/tmp/.root_session');
            
            if (!isRoot) {
                output = `chattr: Operation not permitted`;
            } else {
                const node = getNode(filePath);
                if (!node) {
                    output = `chattr: ${fileName}: No such file or directory`;
                } else if (node.type !== 'file') {
                    output = `chattr: ${fileName}: Operation not supported`;
                } else {
                    const op = modeArg[0]; // + - =
                    const flag = modeArg.substring(1);
                    
                    if (flag !== 'i') {
                         output = `chattr: invalid mode: '${modeArg}' (simulation supports only 'i')`;
                    } else {
                        const currentAttrs = FILE_ATTRIBUTES[filePath] || [];
                        if (op === '+') {
                            if (!currentAttrs.includes('i')) {
                                FILE_ATTRIBUTES[filePath] = [...currentAttrs, 'i'];
                            }
                        } else if (op === '-') {
                            if (currentAttrs.includes('i')) {
                                FILE_ATTRIBUTES[filePath] = currentAttrs.filter(a => a !== 'i');
                                
                                // Puzzle Solve Check (Cycle 75)
                                if (filePath === '/etc/security/lockdown.conf') {
                                     output = `\x1b[1;32m[MISSION UPDATE] Objective Complete: IMMUTABLE ATTRIBUTE REMOVED.\x1b[0m\nFLAG: GHOST_ROOT{1MMUT4BL3_ATTR_RM}`;
                                     if (!VFS['/var/run/attr_rm_solved']) {
                                         VFS['/var/run/attr_rm_solved'] = { type: 'file', content: 'TRUE' };
                                         const runDir = getNode('/var/run');
                                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('attr_rm_solved')) {
                                             runDir.children.push('attr_rm_solved');
                                         }
                                     }
                                     return finalize(output, newCwd);
                                }
                            }
                        } else if (op === '=') {
                            FILE_ATTRIBUTES[filePath] = ['i'];
                        }
                        output = ''; // Silent success
                    }
                }
            }
        }
        break;
    }
    case 'getcap': {
        if (args.length < 1) {
            output = 'usage: getcap <file>';
        } else {
            const target = args[0];
            const node = getNode(resolvePath(cwd, target));
            if (node && node.type === 'file' && (node as any).xattrs && (node as any).xattrs['security.capability']) {
                output = `${target} = ${(node as any).xattrs['security.capability']}`;
            } else if (node) {
                output = ''; // No capabilities
            } else {
                output = `getcap: ${target}: No such file or directory`;
            }
        }
        break;
    }
    case 'tac': {
        if (args.length < 1) {
            output = 'usage: tac <file>';
        } else {
            const target = args[0];
            const node = getNode(resolvePath(cwd, target));
            
            // Capability Check for /usr/bin/tac
            const binaryNode = getNode('/usr/bin/tac');
            const hasCap = binaryNode && (binaryNode as any).xattrs && (binaryNode as any).xattrs['security.capability'] === 'cap_dac_read_search+ep';
            
            if (!node) {
                output = `tac: ${target}: No such file or directory`;
            } else if (node.type === 'dir') {
                output = `tac: ${target}: Is a directory`;
            } else {
                 // Check permissions logic similar to 'cat'
                 // BUT if hasCap is true, bypass permission check
                 const fileNode = node as any;
                 let allowed = false;
                 
                 if (hasCap) {
                     allowed = true;
                 } else {
                     // Standard check
                     if ((resolvePath(cwd, target).startsWith('/root')) && !VFS['/tmp/.root_session']) {
                         allowed = false;
                     } else {
                         allowed = true;
                     }
                 }
                 
                 if (allowed) {
                     const content = fileNode.content;
                     output = content.split('\n').reverse().join('\n');
                     if (content.includes('GHOST_ROOT{C4P_D4C_R34D_BYP4SS}')) {
                         if (!VFS['/var/run/cap_solved']) {
                             VFS['/var/run/cap_solved'] = { type: 'file', content: 'TRUE' };
                             output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: CAPABILITY ESCALATION.\x1b[0m`;
                         }
                     }
                 } else {
                     output = `tac: ${target}: Permission denied`;
                 }
            }
        }
        break;
    }
    // Duplicate strace removed
    case 'lsmod': {
        output = 'Module                  Size  Used by\n';
        output += 'nf_conntrack           131072  2\niptable_filter          16384  1\nip_tables              28672  1 iptable_filter\nx_tables               40960  2 iptable_filter,ip_tables\n';
        if (LOADED_MODULES.includes('blackbox')) {
            output += 'blackbox               12288  0\n';
        }
        if (LOADED_MODULES.includes('rootkit')) {
            output += 'rootkit                16384  1\n';
        }
        break;
    }
    case 'modinfo': {
        if (args.length < 1) {
            output = 'usage: modinfo <module_file>';
        } else {
            const target = args[0];
            let node = getNode(resolvePath(cwd, target));
            
            // If not found by path, try to find in /lib/modules if just a name is given
            if (!node && !target.includes('/')) {
                 node = getNode(`/lib/modules/5.4.0-ghost/kernel/drivers/misc/${target}.ko`);
            }

            if (!node || node.type !== 'file') {
                 if (target === 'blackbox') {
                     output = 'filename:       /lib/modules/5.4.0-ghost/kernel/drivers/misc/blackbox.ko\nlicense:        GPL\ndescription:    Black Box Interface Driver\nauthor:         Unknown\nsrcversion:     B49382098402\ndepends:        \nretpoline:      Y\nname:           blackbox\nvermagic:       5.4.0-ghost SMP mod_unload';
                 } else {
                    output = `modinfo: ERROR: Module ${target} not found.`;
                 }
            } else {
                const content = (node as any).content;
                if (content.startsWith('[KERNEL_MODULE_V1]')) {
                    output = content.substring(content.indexOf('\n') + 1);
                } else {
                     output = `modinfo: ERROR: Module ${target} not found or invalid format.`;
                }
            }
        }
        break;
    }
    case 'insmod': {
        if (args.length < 1) {
            output = 'usage: insmod <filename>';
        } else {
            const target = args[0];
            const path = resolvePath(cwd, target);
            const node = getNode(path);
            
            if (!node) {
                output = `insmod: ERROR: could not insert '${target}': No such file or directory`;
            } else if (node.type !== 'file') {
                output = `insmod: ERROR: could not insert '${target}': Is a directory`;
            } else if (!(node as any).content.startsWith('[KERNEL_MODULE_V1]')) {
                output = `insmod: ERROR: could not insert '${target}': Invalid module format`;
            } else {
                const parts = target.split('/');
                const filename = parts[parts.length - 1];
                const modName = filename.replace('.ko', '');

                if (LOADED_MODULES.includes(modName)) {
                    output = `insmod: ERROR: could not insert '${target}': Module already loaded`;
                } else {
                    LOADED_MODULES.push(modName);
                    output = ''; 
                    
                    if (modName === 'blackbox') {
                        if (!VFS['/dev/blackbox']) {
                            VFS['/dev/blackbox'] = { type: 'file', content: 'GHOST_ROOT{K3RN3L_HACK3R_V1}\n[DEVICE_STATUS] ONLINE\n[DATA_STREAM] 0x4B3R' };
                            const dev = getNode('/dev');
                            if (dev && dev.type === 'dir' && !dev.children.includes('blackbox')) {
                                dev.children.push('blackbox');
                            }
                            if (!VFS['/var/run/insmod_solved']) {
                                VFS['/var/run/insmod_solved'] = { type: 'file', content: 'TRUE' };
                                const runDir = getNode('/var/run');
                                if (runDir && runDir.type === 'dir' && !runDir.children.includes('insmod_solved')) {
                                    runDir.children.push('insmod_solved');
                                }
                                output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL MODULE LOADED.\x1b[0m`;
                            }
                        }
                    }
                }
            }
        }
        break;
    }
    case 'rmmod': {
        if (args.length < 1) {
            output = 'usage: rmmod <modulename>';
        } else {
            const name = args[0];
            if (LOADED_MODULES.includes(name)) {
                // Cycle 213: Rootkit Check
                if (name === 'rootkit') {
                    // Check if monitor process is running
                    if (PROCESSES.some(p => p.pid === 7777)) {
                        output = `rmmod: ERROR: Module rootkit is in use by [monitor_d] (PID 7777)`;
                    } else {
                        const idx = LOADED_MODULES.indexOf(name);
                        LOADED_MODULES.splice(idx, 1);
                        output = '';
                        
                        if (!VFS['/var/run/rootkit_solved']) {
                             VFS['/var/run/rootkit_solved'] = { type: 'file', content: 'TRUE' };
                             const runDir = getNode('/var/run');
                             if (runDir && runDir.type === 'dir' && !runDir.children.includes('rootkit_solved')) {
                                 runDir.children.push('rootkit_solved');
                             }
                             
                             VFS['/home/ghost/flag_rootkit.txt'] = {
                                 type: 'file',
                                 content: 'FLAG: GHOST_ROOT{K3RN3L_UNH00K1NG_SUCC3SS}'
                             };
                             const home = getNode('/home/ghost');
                             if (home && home.type === 'dir' && !home.children.includes('flag_rootkit.txt')) {
                                 home.children.push('flag_rootkit.txt');
                             }
                             output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: ROOTKIT REMOVED.\x1b[0m`;
                        }
                    }
                } else {
                    const idx = LOADED_MODULES.indexOf(name);
                    LOADED_MODULES.splice(idx, 1);
                    if (name === 'blackbox') {
                        delete VFS['/dev/blackbox'];
                        const dev = getNode('/dev');
                        if (dev && dev.type === 'dir') {
                            const i = dev.children.indexOf('blackbox');
                            if (i > -1) dev.children.splice(i, 1);
                        }
                    }
                    output = '';
                }
            } else {
                output = `rmmod: ERROR: Module ${name} is not currently loaded`;
            }
        }
        break;
    }
    case 'curl': {
        let url = '';
        let headerVal = '';
        let i = 0;
        while(i < args.length) {
            const arg = args[i];
            if (arg === '-H' || arg === '--header') {
                if (i + 1 < args.length) {
                    const h = args[i+1];
                    if (h.startsWith('X-Ghost-Token:')) {
                         headerVal = h.split(':')[1].trim();
                    }
                    i += 2;
                } else {
                    i++;
                }
            } else if (!arg.startsWith('-')) {
                url = arg;
                i++;
            } else {
                i++;
            }
        }
        
        if (!url) {
            output = 'curl: try \'curl --help\' for more information';
        } else if (url.includes('localhost:8080') || url.includes('127.0.0.1:8080')) {
             if (headerVal === 'GHOST-7-ALPHA') {
                 output = 'HTTP/1.1 200 OK\nContent-Type: text/plain\n\n[ACCESS GRANTED]\nWelcome, Admin.\nFLAG: GHOST_ROOT{CURL_H3AD3R_M4ST3R}\n';
                 if (!VFS['/var/run/curl_solved']) {
                      VFS['/var/run/curl_solved'] = { type: 'file', content: 'TRUE' };
                      const runDir = getNode('/var/run');
                      if (runDir && runDir.type === 'dir' && !runDir.children.includes('curl_solved')) {
                          runDir.children.push('curl_solved');
                      }
                      output += '\n\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN SERVICE ACCESSED.\x1b[0m';
                 }
             } else {
                 output = 'HTTP/1.1 403 Forbidden\nContent-Type: text/plain\n\nAccess Denied: Missing or Invalid X-Ghost-Token.';
             }
        } else {
             output = `curl: (7) Failed to connect to ${url} port 80: Connection refused`;
        }
        break;
    }
    case 'grep': {
        const pattern = args[0];
        let content = '';
        let fileName = '';

        if (!pattern) {
            output = 'usage: grep <pattern> [file]';
        } else {
            // Check if file provided or use stdin
            if (args.length > 1) {
                fileName = args[1];
                const node = getNode(resolvePath(cwd, fileName));
                if (node && node.type === 'file') {
                    content = node.content;
                } else {
                    output = `grep: ${fileName}: No such file or directory`;
                    return finalize(output, newCwd);
                }
            } else if (stdin !== undefined) {
                content = stdin;
            } else {
                output = 'usage: grep <pattern> [file]';
                return finalize(output, newCwd);
            }

            const lines = content.split('\n');
            // Remove quotes from pattern if present
            let searchPattern = pattern;
            if ((pattern.startsWith('"') && pattern.endsWith('"')) || (pattern.startsWith("'") && pattern.endsWith("'"))) {
                searchPattern = pattern.slice(1, -1);
            }
            
            const matches = lines.filter(l => l.includes(searchPattern));
            output = matches.join('\n');
            
            // Cycle 118 Win Condition
            if (fileName.includes('auth.log') && searchPattern === 'Accepted') {
                 if (!VFS['/var/run/grep_solved']) {
                     VFS['/var/run/grep_solved'] = { type: 'file', content: 'TRUE' };
                     output += `\n\x1b[1;32m[MISSION UPDATE] Objective Complete: LOG ANALYSIS (GREP).\x1b[0m`;
                 }
            }
        }
        break;
    }
    case 'kernel_recover': {
        const code = args[0];
        if (!code) {
            output = 'Usage: kernel_recover <PANIC_CODE>';
        } else if (code === '0xDEADBEEF') {
            output = '[SYSTEM] Validating Panic Code: 0xDEADBEEF...\n[SUCCESS] Kernel Panic Resolved.\n[RECOVERY] Services Restored.\n\nFLAG: GHOST_ROOT{GR3P_M4ST3R_0xDEADBEEF}\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: KERNEL STABILIZED.\x1b[0m';
            if (!VFS['/var/run/kernel_solved']) {
                VFS['/var/run/kernel_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('kernel_solved')) {
                    runDir.children.push('kernel_solved');
                }
            }
        } else {
            output = `[ERROR] Invalid Panic Code: ${code}. Check /var/log/kernel_panic.log again.`;
        }
        break;
    }
    case 'mkswap': {
        if (args.length < 1) {
            output = 'usage: mkswap <device>';
        } else {
            const device = args[0];
            const node = getNode(resolvePath(cwd, device));
            if (!node || node.type !== 'file') {
                output = `mkswap: cannot open ${device}: No such file or directory`;
            } else if (device !== '/dev/sdb2') {
                output = `mkswap: error: ${device} is mounted; will not make swapspace.`;
            } else {
                (node as any).content = '[SWAP_SPACE_FORMATTED]';
                output = `Setting up swapspace version 1, size = 2 GiB (2147483648 bytes)\nno label, UUID=12345678-1234-1234-1234-123456789abc`;
            }
        }
        break;
    }
    case 'swapon': {
        if (args.length < 1) {
            output = 'usage: swapon [options] [<spec>]';
        } else {
            const device = args[0];
            const node = getNode(resolvePath(cwd, device));
            if (!node || node.type !== 'file') {
                output = `swapon: stat failed ${device}: No such file or directory`;
            } else if ((node as any).content !== '[SWAP_SPACE_FORMATTED]') {
                output = `swapon: ${device}: read swap header failed`;
            } else {
                if (!VFS['/var/run/swap_active']) {
                    VFS['/var/run/swap_active'] = { type: 'file', content: 'TRUE' };
                    const runDir = getNode('/var/run');
                    if (runDir && runDir.type === 'dir' && !runDir.children.includes('swap_active')) {
                        runDir.children.push('swap_active');
                    }
                    output = ''; 
                    output += `\x1b[1;32m[MISSION UPDATE] Objective Complete: SWAP SPACE ENABLED.\x1b[0m`;
                } else {
                    output = `swapon: ${device}: swapspace already active`;
                }
            }
        }
        break;
    }
    case 'free': {
        const isSwap = !!VFS['/var/run/swap_active'];
        const swapTotal = isSwap ? '2097152' : '0';
        const swapUsed  = isSwap ? '0' : '0';
        const swapFree  = isSwap ? '2097152' : '0';
        
        output = `              total        used        free      shared  buff/cache   available
Mem:        8167848     7854321      123456       42123      190071      123456
Swap:       ${swapTotal.padEnd(11)} ${swapUsed.padEnd(11)} ${swapFree.padEnd(11)}`;
        break;
    }
    case 'backup_manager': {
        output = '[BACKUP_MANAGER] Initializing...\n[INFO] Running: tar -cf /tmp/backup.tar /home/ghost/data\n';
        
        // PATH Injection Simulation
        const pathEnv = ENV_VARS['PATH'] || '';
        const paths = pathEnv.split(':');
        
        // Find the first 'tar' in PATH
        let foundTar = null;
        let tarPath = '';
        
        for (const p of paths) {
            // Handle relative paths (., ..) and tilde (~)
            let searchDir = p;
            if (p === '.') searchDir = cwd;
            else if (p === '~') searchDir = '/home/ghost';
            else if (p.startsWith('/')) searchDir = p;
            else searchDir = resolvePath(cwd, p); // Resolve relative to cwd
            
            const potentialTar = resolvePath(searchDir, 'tar');
            const node = getNode(potentialTar);
            
            if (node && node.type === 'file') {
                foundTar = node;
                tarPath = potentialTar;
                break;
            }
        }
        
        if (foundTar) {
            if (tarPath === '/bin/tar' || tarPath === '/usr/bin/tar') {
                output += '[SUCCESS] Backup created at /tmp/backup.tar (Simulated)';
            } else {
                // Malicious TAR execution
                output += `[WARNING] Executing user-defined tar at ${tarPath}...\n`;
                output += `[ROOT ACCESS GRANTED]\n`;
                
                const content = (foundTar as any).content;
                if (content.includes('cat') && content.includes('/root/flag.txt')) {
                    output += `FLAG: GHOST_ROOT{PATH_1NJ3CT10N_SUCC3SS}\n`;
                    output += `\x1b[1;32m[MISSION UPDATE] Objective Complete: SUID PATH INJECTION.\x1b[0m`;
                    
                    if (!VFS['/var/run/suid_solved']) {
                        VFS['/var/run/suid_solved'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('suid_solved')) {
                            runDir.children.push('suid_solved');
                        }
                    }
                } else {
                    output += `[EXEC] ${content}\n(Hint: You have root access, but didn't read the flag.)`;
                }
            }
        } else {
            output += '[ERROR] tar command not found in PATH.';
        }
        break;
    }
    case 'screen': {
        const args = commandLine.trim().split(/\s+/).slice(1);
        if (args.includes('-ls') || args.includes('-list') || args.includes('--list')) {
            if (VFS['/var/run/screen/S-ghost/1337.recovery']) {
                output = 'There is a screen on:\n\t1337.recovery\t(Detached)\n1 Socket in /var/run/screen/S-ghost.';
            } else {
                output = 'No Sockets found in /var/run/screen/S-ghost.';
            }
        } else if (args.includes('-r')) {
            const target = args.find(a => a !== '-r');
            if (target === '1337' || target === 'recovery' || target === '1337.recovery') {
                if (VFS['/var/run/screen/S-ghost/1337.recovery']) {
                    output = '[SCREEN] Reattaching to session 1337.recovery...\n[CLEAR]\n\n# VI EDITOR - /etc/shadow.bak (RECOVERED)\n\nroot:$6$rounds=656000$....:19760:0:99999:7:::\nadmin:$1$528392$D7.F7/203.493:19760:0:99999:7:::\nghost:$6$rounds=656000$....:19760:0:99999:7:::\n\n# SYSTEM NOTE: SESSION RESTORED.\nFLAG: GHOST_ROOT{SCR33N_S3SS10N_R3C0V3R3D}\n\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SESSION RECOVERED.\x1b[0m';
                    
                    if (!VFS['/var/run/screen_solved']) {
                        VFS['/var/run/screen_solved'] = { type: 'file', content: 'TRUE' };
                        const runDir = getNode('/var/run');
                        if (runDir && runDir.type === 'dir' && !runDir.children.includes('screen_solved')) {
                            runDir.children.push('screen_solved');
                        }
                    }
                    
                    // Do not delete for replayability? Or do? Let's keep it.
                    // delete VFS['/var/run/screen/S-ghost/1337.recovery'];
                } else {
                    output = 'There is no screen to be resumed matching ' + target + '.';
                }
            } else {
                output = 'There is no screen to be resumed matching ' + (target || '') + '.';
            }
        } else {
            output = 'Use: screen [-d] [-r] [-ls]';
        }
        break;
    }
    // Cycle 175: Manual Override
    case 'restore_uplink':
    case './restore_uplink':
    case '/usr/local/bin/restore_uplink': {
        output = 'Scanning for uplink...\nSegmentation fault (core dumped)\n';
        break;
    }
    case 'uplink_connect_manual':
    case './uplink_connect_manual':
    case '/usr/local/bin/uplink_connect_manual': {
        const key = ENV_VARS['UPLINK_KEY'];
        if (key === 'OMEGA-99-ZETA') {
             output = '[UPLINK] Key Accepted.\n[UPLINK] Establishing secure tunnel...\n[SUCCESS] Uplink Restored.\nFLAG: GHOST_ROOT{M4NU4L_OV3RR1D3_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: MANUAL OVERRIDE.\x1b[0m';
             if (!VFS['/var/run/manual_solved']) {
                 VFS['/var/run/manual_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('manual_solved')) {
                     runDir.children.push('manual_solved');
                 }
             }
        } else {
             output = '[UPLINK] Error: Invalid Authentication Key.\n[CHECK] Verify UPLINK_KEY environment variable.';
        }
        break;
    }

    // Cycle 183 (The Log Rotation)
    case 'rotate_logs':
    case './rotate_logs':
    case '/usr/local/bin/rotate_logs': {
        const args = commandLine.trim().split(/\s+/).slice(1);
        if (args.length === 0) {
            return { output: 'Usage: rotate_logs <ARCHIVE_KEY>', newCwd: cwd };
        }
        
        const key = args[0];
        if (key === 'GHOST_ROOT{GR3P_TH3_N33DL3_V2}') {
             if (!VFS['/var/run/log_solved']) {
                 VFS['/var/run/log_solved'] = { type: 'file', content: 'TRUE' };
                 // Clear the log file to simulate rotation
                 if (VFS['/var/log/syslog_full']) {
                     (VFS['/var/log/syslog_full'] as any).content = '[LOGS ROTATED] New cycle started...';
                 }
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('log_solved')) {
                     runDir.children.push('log_solved');
                 }
                 return { output: '[ROTATOR] Key Accepted.\n[ROTATOR] Archiving old logs...\n[SUCCESS] Disk space reclaimed.\nFLAG: GHOST_ROOT{L0G_R0T4T10N_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: LOGS SECURED.\x1b[0m', newCwd: cwd };
             }
             return { output: '[ROTATOR] Logs already rotated.\nFLAG: GHOST_ROOT{L0G_R0T4T10N_M4ST3R}', newCwd: cwd };
        } else {
             return { output: '[ROTATOR] Error: Invalid Archive Key.\n[FAILED] Access Denied.', newCwd: cwd };
        }
    }
    case 'net-splice': {
        const hasTarget = args.includes('--target');
        const hasPort = args.includes('--port');
        const hasMode = args.includes('--mode');
        
        if (!hasTarget || !hasPort || !hasMode) {
             output = 'Error: Missing required arguments.\nSee "man net-splice" for details.';
        } else {
            const targetIdx = args.indexOf('--target');
            const portIdx = args.indexOf('--port');
            const modeIdx = args.indexOf('--mode');
            
            const target = args[targetIdx + 1];
            const port = args[portIdx + 1];
            const mode = args[modeIdx + 1];
            
            if (target === '10.10.99.5' && port === '443' && mode === 'silent') {
                 if (!VFS['/var/run/man_page_solved']) {
                     VFS['/var/run/man_page_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('man_page_solved')) {
                         runDir.children.push('man_page_solved');
                     }
                     output = '[SPLICE] Target Acquired (10.10.99.5:443)...\n[MODE] Silent.\n[SUCCESS] Tunnel Established.\nFLAG: GHOST_ROOT{RTFM_IS_TH3_K3Y}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: COVERT CHANNEL OPENED.\x1b[0m';
                 } else {
                     output = '[SPLICE] Tunnel Established.\nFLAG: GHOST_ROOT{RTFM_IS_TH3_K3Y}';
                 }
            } else {
                 output = `[SPLICE] Connection Failed.\n[DEBUG] Target:${target} Port:${port} Mode:${mode}\n[HINT] Ensure all parameters match the mission profile.`;
            }
        }
        break;
    }
    // Cycle 188 (The Buried Config)
    case 'decrypt-node':
    case '/usr/bin/decrypt-node': {
        const connStr = ENV_VARS['CONNECTION_STRING'];
        if (!connStr) {
            output = '[ERROR] Missing Environment Variable: CONNECTION_STRING\n[STATUS] Aborted.';
        } else if (connStr === 'GHOST_ROOT{GR3P_4_TH3_W1N}') {
            if (!VFS['/var/run/cycle188_solved']) {
                VFS['/var/run/cycle188_solved'] = { type: 'file', content: 'TRUE' };
                const runDir = getNode('/var/run');
                if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle188_solved')) {
                    runDir.children.push('cycle188_solved');
                }
                output = '[DECRYPT] Connection String Verified.\n[DECRYPT] Decrypting Node Payload...\n[SUCCESS] Node Online.\nFLAG: GHOST_ROOT{ENV_V4R_M4ST3R_V2}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: NODE DECRYPTED.\x1b[0m';
            } else {
                output = '[DECRYPT] Node Online.\nFLAG: GHOST_ROOT{ENV_V4R_M4ST3R_V2}';
            }
        } else {
            output = '[ERROR] Invalid Connection String.\n[DEBUG] Check logs for the correct rotation value.';
        }
        break;
    }

    // Cycle 189 (The Broken Installer)
    case 'install.sh':
    case './install.sh':
    case '/opt/ghost_protocol/install.sh': {
        // Check if the dependency file exists
        if (VFS['/var/lib/ghost/dependency.ok']) {
             if (!VFS['/var/run/cycle189_solved']) {
                 VFS['/var/run/cycle189_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle189_solved')) {
                     runDir.children.push('cycle189_solved');
                 }
                 output = '[INSTALL] Initializing...\n[CHECK] Verifying dependency: lib-ghost-v4...\n[SUCCESS] Dependency found.\n[INSTALL] Installing firmware...\n[SUCCESS] Firmware Updated.\nFLAG: GHOST_ROOT{SCR1PT_ANALYS1S_1S_K3Y}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FIRMWARE RESTORED.\x1b[0m';
             } else {
                 output = '[INSTALL] Firmware Updated.\nFLAG: GHOST_ROOT{SCR1PT_ANALYS1S_1S_K3Y}';
             }
        } else {
             output = '[INSTALL] Initializing...\n[CHECK] Verifying dependency: lib-ghost-v4...\n[ERROR] Dependency check failed.\nPANIC: KERNEL MODULE MISSING';
        }
        break;
    }

    // Cycle 190 (The Hidden Port)
    case 'nc':
    case '/bin/nc':
    case '/usr/bin/nc': {
         const args = commandLine.trim().split(/\s+/).slice(1);
         const host = args.find(a => !a.startsWith('-') && (a === 'localhost' || a === '127.0.0.1'));
         const port = args.find(a => !a.startsWith('-') && a !== 'localhost' && a !== '127.0.0.1');
         
         if (!host || !port) {
             output = 'usage: nc [options] [hostname] [port]';
         } else if ((host === 'localhost' || host === '127.0.0.1') && port === '8008') {
             if (!VFS['/var/run/cycle190_solved']) {
                 VFS['/var/run/cycle190_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle190_solved')) {
                     runDir.children.push('cycle190_solved');
                 }
                 output = '[NC] Connection established to 127.0.0.1:8008...\\n[BANNER] GHOST_NET_LISTENER_V1\\n[AUTH] Bypass Successful.\\nFLAG: GHOST_ROOT{PR0C_N3T_TCP_H3X_D3C0D3R}\\n\\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN SERVICE IDENTIFIED.\\x1b[0m';
             } else {
                 output = '[NC] Connection established.\\nFLAG: GHOST_ROOT{PR0C_N3T_TCP_H3X_D3C0D3R}';
             }
         } else {
             output = `nc: connect to ${host} port ${port} (tcp) failed: Connection refused`;
         }
         break;
    }
    case 'export': {
        if (args.length === 0) {
            output = Object.entries(ENV_VARS).map(([k, v]) => `declare -x ${k}="${v}"`).join('\n');
        } else {
            const arg = args[0];
            const eqIndex = arg.indexOf('=');
            if (eqIndex !== -1) {
                const key = arg.substring(0, eqIndex);
                let val = arg.substring(eqIndex + 1);
                
                // Remove quotes
                if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                    val = val.slice(1, -1);
                }
                
                ENV_VARS[key] = val;
                saveSystemState();
                output = '';
            } else {
                // export VAR (undefined/empty)
                ENV_VARS[arg] = '';
                saveSystemState();
                output = '';
            }
        }
        break;
    }
    // Cycle 193 (The Zombie Process)
    case 'vault_access':
    case './vault_access':
    case '/usr/bin/vault_access': {
        if (VFS['/var/lock/subsystem/vault.lock']) {
             output = '[VAULT] Access Denied.\n[ERROR] Resource Locked (/var/lock/subsystem/vault.lock).\n[DIAGNOSTIC] Another process is using the vault.\n[STATUS] Aborted.';
        } else {
             if (!VFS['/var/run/cycle193_solved']) {
                 VFS['/var/run/cycle193_solved'] = { type: 'file', content: 'TRUE' };
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle193_solved')) {
                     runDir.children.push('cycle193_solved');
                 }
                 output = '[VAULT] Lock file clear.\n[VAULT] Accessing Secure Storage...\n[SUCCESS] Vault Unlocked.\nFLAG: GHOST_ROOT{Z0MB13_PR0C3SS_R34P3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: RESOURCE FREED.\x1b[0m';
             } else {
                 output = '[VAULT] Vault Unlocked.\nFLAG: GHOST_ROOT{Z0MB13_PR0C3SS_R34P3D}';
             }
        }
        break;
    }
    // Cycle 201 (The Env Var Injection)
    case 'debug_console':
    case './debug_console':
    case '/usr/local/bin/debug_console': {
        const userName = ENV_VARS['USER_NAME'];
        if (!userName) {
            output = 'Error: USER_NAME not set.';
        } else {
            // Simulate eval vulnerability
            if (userName.includes('cat') && (userName.includes('/root/secret_flag.txt') || userName.includes('flag'))) {
                 if (!VFS['/var/run/cycle201_solved']) {
                     VFS['/var/run/cycle201_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle201_solved')) {
                         runDir.children.push('cycle201_solved');
                     }
                     output = `Welcome, \nFLAG: GHOST_ROOT{EV4L_1NJ3CT10N_1S_B4D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: CODE INJECTION SUCCESSFUL.\x1b[0m`;
                 } else {
                     output = `Welcome, \nFLAG: GHOST_ROOT{EV4L_1NJ3CT10N_1S_B4D}`;
                 }
            } else if (userName.includes(';')) {
                 // Simulate generic execution attempt
                 const parts = userName.split(';');
                 output = `Welcome, ${parts[0]}`;
                 if(parts[1]) output += `\nbash: ${parts[1].trim()}: command not found (Simulation limitation)`;
            } else {
                 output = `Welcome, ${userName}`;
            }
        }
        break;
    }
    // Cycle 202 (The Locked Script)
    case 'satellite_fix':
    case './satellite_fix':
    case '/usr/local/bin/satellite_fix': {
       const node = getNode(resolvePath(cwd, cmdBase));
       if (!node) {
           output = `bash: ${cmdBase}: No such file or directory`;
           break;
       }
       
       const perms = (node as any).permissions || '0644';
       const isExec = perms === '0755' || perms === '0700' || perms.includes('x');
       
       if (!isExec && perms !== '0755' && perms !== '0700') {
           output = `bash: ${cmdBase}: Permission denied`;
       } else {
           if (!VFS['/var/run/cycle202_solved']) {
               VFS['/var/run/cycle202_solved'] = { type: 'file', content: 'TRUE' };
               output = '[SYSTEM] Realigning dish...\n[SUCCESS] Signal Optimized.\nFLAG: GHOST_ROOT{CHM0D_F1X_TH3_SCR1PT}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SCRIPT EXECUTED.\x1b[0m';
           } else {
               output = '[SYSTEM] Signal Optimized.\nFLAG: GHOST_ROOT{CHM0D_F1X_TH3_SCR1PT}';
           }
       }
       break;
    }

    // Cycle 206 (Corrupted Binary / Strings)
    case 'ghost_protocol':
    case './ghost_protocol':
    case '/usr/bin/ghost_protocol': {
        const key = ENV_VARS['GHOST_KEY'];
        if (key === 'SPECTRE_INIT') {
             if (!VFS['/var/run/cycle206_solved']) {
                 VFS['/var/run/cycle206_solved'] = { type: 'file', content: 'TRUE' };
                 // Ensure directory exists
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle206_solved')) {
                     runDir.children.push('cycle206_solved');
                 }
                 output = '[PROTOCOL] Key Accepted.\n[PROTOCOL] Re-initializing core systems...\n[SUCCESS] Protocol Active.\nFLAG: GHOST_ROOT{STR1NGS_ANALYS1S_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BINARY ANALYZED.\x1b[0m';
             } else {
                 output = '[PROTOCOL] Active.\nFLAG: GHOST_ROOT{STR1NGS_ANALYS1S_M4ST3R}';
             }
        } else {
             output = '[ERROR] Integrity check failed. Run diagnostics.\nSegmentation fault (core dumped)\n(Hint: Analyze the binary)';
        }
        break;
    }

    // Cycle 207 (The Shadow Mount)
    case 'unlock_protocol':
    case './unlock_protocol':
    case '/usr/bin/unlock_protocol': {
        const keyPath = '/home/ghost/.ssh/shadow_key.pem';
        const keyNode = VFS[keyPath];
        
        if (keyNode) {
            const content = (keyNode as any).content || '';
            if (content.includes('SHADOW KEY')) {
                 if (!VFS['/var/run/cycle207_solved']) {
                     VFS['/var/run/cycle207_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle207_solved')) {
                         runDir.children.push('cycle207_solved');
                     }
                     output = '[PROTOCOL] Key Detected.\n[PROTOCOL] Authenticating via Shadow Key...\n[SUCCESS] Access Granted.\nFLAG: GHOST_ROOT{H1DD3N_M0UNT_DISCOV3RY}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: HIDDEN PARTITION ACCESSED.\x1b[0m';
                 } else {
                     output = '[PROTOCOL] Access Granted.\nFLAG: GHOST_ROOT{H1DD3N_M0UNT_DISCOV3RY}';
                 }
            } else {
                 output = '[PROTOCOL] Error: Key file corrupted or invalid.';
            }
        } else {
            output = '[PROTOCOL] Error: Authentication Key not found in ~/.ssh/shadow_key.pem.\n[HINT] Check mounted drives for hidden partitions.';
        }
        break;
    }

    case 'system_repair': {
        if (args.length === 2 && args[0] === '--code') {
            const code = args[1];
            if (code === '0xBAD_C0DE_CAFE') {
                if (!VFS['/var/run/kernel_solved']) {
                    VFS['/var/run/kernel_solved'] = { type: 'file', content: 'TRUE' };
                    // Ensure /var/run exists
                    if (!VFS['/var/run']) {
                        VFS['/var/run'] = { type: 'dir', children: [] };
                        const varDir = getNode('/var');
                        if (varDir && varDir.type === 'dir' && !varDir.children.includes('run')) varDir.children.push('run');
                    }
                    const runDir = getNode('/var/run');
                    if (runDir && runDir.type === 'dir' && !runDir.children.includes('kernel_solved')) {
                        runDir.children.push('kernel_solved');
                    }
                    output = '[SYSTEM] Repair Code Accepted.\\n[STATUS] Kernel patched successfully.\\n[MISSION UPDATE] Objective Complete: KERNEL PANIC RESOLVED.\\nFLAG: GHOST_ROOT{H34D_T41L_M4ST3R}';
                } else {
                    output = '[SYSTEM] Kernel already patched.';
                }
            } else {
                output = '[ERROR] Invalid Repair Code. System unstable.';
            }
        } else {
            output = 'usage: system_repair --code <HEX_CODE>';
        }
        break;
    }

    case 'start_mission': {
        const diskBlock = getNode('/var/log/kern.log.1');
        if (diskBlock) {
            output = '[SYSTEM] Starting Mission Critical Services...\n[ERROR] Write error: No space left on device.\n[FATAL] Cannot create lock file in /var/run.\n[STATUS] Aborted.';
        } else {
            output = '[SYSTEM] Starting Mission Critical Services...\n[OK] Disk check passed.\n[OK] Services initialized.\n\nFLAG: GHOST_ROOT{DISK_QU0T4_M4N4G3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM RECOVERED.\x1b[0m';
            
            if (!VFS['/var/run/disk_solved']) {
                VFS['/var/run/disk_solved'] = { type: 'file', content: 'TRUE' };
            }
        }
        break;
    }

    // Cycle 228 (The Corrupted Script)
    case 'sys_recovery':
    case './sys_recovery':
    case '/usr/local/bin/sys_recovery': {
        const mode = ENV_VARS['RECOVERY_MODE'];
        if (mode === '1' && args.includes('--force')) {
             if (!VFS['/var/run/cycle228_solved']) {
                 VFS['/var/run/cycle228_solved'] = { type: 'file', content: 'TRUE' };
                 // Ensure directory exists
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle228_solved')) {
                     runDir.children.push('cycle228_solved');
                 }
                 output = '[RECOVERY] Force override engaged.\n[RECOVERY] Bypassing syntax check...\n[SUCCESS] System Restored.\nFLAG: GHOST_ROOT{M4NU4L_0V3RR1D3_SUCC3SS}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SCRIPT FIXED.\x1b[0m';
             } else {
                 output = '[RECOVERY] System Restored.\nFLAG: GHOST_ROOT{M4NU4L_0V3RR1D3_SUCC3SS}';
             }
        } else {
             output = './sys_recovery: line 8: syntax error: unexpected end of file';
        }
        break;
    }

    // Cycle 229 (The Stderr Leak)
    case 'noise_maker':
    case './noise_maker':
    case '/usr/bin/noise_maker': {
        if (commandLine.includes('> /dev/null') || commandLine.includes('1> /dev/null')) {
             if (!VFS['/var/run/cycle229_solved']) {
                 VFS['/var/run/cycle229_solved'] = { type: 'file', content: 'TRUE' };
                 // Ensure directory exists
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle229_solved')) {
                     runDir.children.push('cycle229_solved');
                 }
                 output = '[STDERR] Critical Error: Entropy Pool Depleted.\nFLAG: GHOST_ROOT{STD3RR_R3D1R3CT_W1N}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: NOISE FILTERED.\x1b[0m';
             } else {
                 output = '[STDERR] FLAG: GHOST_ROOT{STD3RR_R3D1R3CT_W1N}';
             }
        } else {
             // Simulate noise
             output = '';
             for(let i=0; i<50; i++) {
                 output += `[STDOUT] Generating Entropy Block ${Math.floor(Math.random() * 99999)}... OK\n`;
             }
             output += `[STDERR] Critical Error: Entropy Pool Depleted.\nFLAG: GHOST_ROOT{STD3RR_R3D1R3CT_W1N}\n`; // Buried in noise
             for(let i=0; i<50; i++) {
                 output += `[STDOUT] Generating Entropy Block ${Math.floor(Math.random() * 99999)}... OK\n`;
             }
             output += `[SYSTEM] Process completed with errors.`;
        }
        break;
    }

    case 'protocol_omega': {
        const libPath = '/usr/lib/libomega.so.5';
        const libNode = getNode(libPath);
        
        // Also check /lib just in case
        const altLibNode = getNode('/lib/libomega.so.5');
        
        let valid = false;
        if (libNode && libNode.type === 'symlink' && libNode.target === '/opt/secret_libs/libomega.so.5') valid = true;
        if (altLibNode && altLibNode.type === 'symlink' && altLibNode.target === '/opt/secret_libs/libomega.so.5') valid = true;

        if (valid) {
            output = '[SYSTEM] Loading shared libraries... [OK]\n[SYSTEM] Verifying signature... [OK]\n[EXEC] Protocol Omega Initiated.\n\nFLAG: GHOST_ROOT{SYML1NK_R3SCU3_0P3R4T10N}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BROKEN LINK FIXED.\x1b[0m';
            if (!VFS['/var/run/link_solved']) {
                VFS['/var/run/link_solved'] = { type: 'file', content: 'TRUE' };
            }
        } else {
            output = 'protocol_omega: error while loading shared libraries: libomega.so.5: cannot open shared object file: No such file or directory';
        }
        break;
    }

    // Cycle 242: The Broken Symlink (Config Fix)
    case 'fix_config':
    case './fix_config':
    case '/usr/local/bin/fix_config': {
        const configPath = '/etc/ghost_server/server.conf';
        const backupPath = '/var/backups/ghost_server/server.conf.bak';
        
        const configNode = getNode(configPath);
        
        if (!configNode) {
            output = '[ERROR] Configuration missing or not a symlink.\nExpected link: /etc/ghost_server/server.conf -> /var/backups/ghost_server/server.conf.bak';
        } else if (configNode.type !== 'symlink') {
             output = '[ERROR] /etc/ghost_server/server.conf exists but is not a symbolic link.';
        } else if (configNode.target !== backupPath) {
             output = `[ERROR] Invalid symlink target. Expected ${backupPath}, got ${configNode.target}.`;
        } else {
             if (!VFS['/var/run/cycle242_solved']) {
                 VFS['/var/run/cycle242_solved'] = { type: 'file', content: 'TRUE' };
                 // Ensure directory exists
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle242_solved')) {
                     runDir.children.push('cycle242_solved');
                 }
                 output = '[SUCCESS] Configuration verified.\nFLAG: GHOST_ROOT{SYML1NK_R3SCU3_0P3R4T10N}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYMLINK RESTORED.\x1b[0m';
             } else {
                 output = '[SUCCESS] Configuration verified.\nFLAG: GHOST_ROOT{SYML1NK_R3SCU3_0P3R4T10N}';
             }
        }
        break;
    }
    // Cycle 248: The DNS Poison
    case 'connect_secure':
    case '/usr/bin/connect_secure': {
        const hostsNode = getNode('/etc/hosts');
        let resolved = false;
        
        if (hostsNode && hostsNode.type === 'file') {
            const lines = hostsNode.content.split('\n');
            for (const line of lines) {
                if (line.trim().match(/^10\.10\.10\.10\s+secure\.corp$/)) {
                    resolved = true;
                    break;
                }
            }
        }

        if (resolved) {
             output = '[CONNECT] Resolving secure.corp... [10.10.10.10]\n[SUCCESS] Connection Established.\nFLAG: GHOST_ROOT{DNS_P01S0N_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: DNS OVERRIDE ACTIVE.\x1b[0m';
        } else {
             output = '[CONNECT] Resolving secure.corp... [FAILED]\n[ERROR] Host not found or DNS server unreachable.\n[HINT] Check /etc/hosts for manual overrides.';
        }
        break;
    }

    // Cycle 255: The Process Trace
    // Cycle 256: The Group Policy
    case 'deploy_weapon':
    case './deploy_weapon':
    case '/usr/local/bin/deploy_weapon': {
        const hasGroup = USER_GROUPS.includes('black_ops');
        if (hasGroup) {
             if (!VFS['/var/run/cycle256_solved']) {
                 VFS['/var/run/cycle256_solved'] = { type: 'file', content: 'TRUE' };
                 // Ensure directory exists
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle256_solved')) {
                     runDir.children.push('cycle256_solved');
                 }
                 output = '[AUTH] Group Membership Verified (black_ops).\n[SYSTEM] Weapon Systems Online.\n[DEPLOY] Payload Released.\nFLAG: GHOST_ROOT{US3R_GR0UP_M4N4G3M3NT}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: PRIVILEGE ESCALATION (GROUPS).\x1b[0m';
             } else {
                 output = '[SYSTEM] Weapon Systems Online.\nFLAG: GHOST_ROOT{US3R_GR0UP_M4N4G3M3NT}';
             }
        } else {
             output = '[ACCESS DENIED] User is not in the required group: black_ops\n[ACTION] Contact SysAdmin to be added to the group.';
        }
        break;
    }
    case 'groups': {
        const targetUser = args[0] || 'ghost';
        if (targetUser === 'ghost') {
            output = `ghost : ${USER_GROUPS.join(' ')}`;
        } else if (targetUser === 'root') {
            output = 'root : root';
        } else {
            output = `groups: ${targetUser}: no such user`;
        }
        break;
    }
    case 'usermod': {
        // usermod -aG group user
        // Simplified parsing for "usermod -aG group user" or "usermod -a -G group user"
        let groupsStr = '';
        let user = '';
        
        if (args.includes('-aG')) {
            const idx = args.indexOf('-aG');
            groupsStr = args[idx + 1];
            user = args[idx + 2];
        } else if (args.includes('-G') && args.includes('-a')) {
            const idx = args.indexOf('-G');
            groupsStr = args[idx + 1];
            user = args[args.length - 1]; // Assume user is last
        } else {
            output = 'usage: usermod -aG <group> <user>';
            break;
        }
        
        if (!user || !groupsStr) {
            output = 'usage: usermod -aG <group> <user>';
        } else if (user !== 'ghost') {
            output = `usermod: user '${user}' does not exist`;
        } else {
            const groupsToAdd = groupsStr.split(',');
            for (const g of groupsToAdd) {
                if (!USER_GROUPS.includes(g)) {
                    USER_GROUPS.push(g);
                }
            }
            saveSystemState();
            output = ''; // Silent success
        }
        break;
    }

    // Cycle 258: The Broken Service
    case 'systemctl': {
        const args = commandLine.trim().split(/\s+/).slice(1);
        const action = args[0];
        const service = args[1];
        
        if (!action) {
            output = 'systemctl: usage: systemctl [start|stop|restart|status] <service>';
            break;
        }
        
        if (service === 'firewall' || service === 'firewall.service') {
            if (action === 'status') {
                 if (VFS['/var/run/firewall.pid']) {
                     output = ' firewall.service - Ghost Firewall Daemon\n   Loaded: loaded (/etc/systemd/system/firewall.service; enabled; vendor preset: enabled)\n   Active: active (running) since Tue 2026-02-17 16:00:00 UTC; 1min ago\n Main PID: 8888 (ghost_firewall)\n    Tasks: 1 (limit: 4915)\n   CGroup: /system.slice/firewall.service\n           8888 /usr/bin/ghost_firewall';
                 } else {
                     output = ' firewall.service - Ghost Firewall Daemon\n   Loaded: loaded (/etc/systemd/system/firewall.service; enabled; vendor preset: enabled)\n   Active: inactive (dead)\n\nFeb 17 16:00:00 ghost-root systemd[1]: Starting Ghost Firewall Daemon...\nFeb 17 16:00:00 ghost-root ghost_firewall[8888]: Error: Configuration file /etc/firewall/rules.conf not found.\nFeb 17 16:00:00 ghost-root systemd[1]: firewall.service: Main process exited, code=exited, status=1/FAILURE\nFeb 17 16:00:00 ghost-root systemd[1]: Failed to start Ghost Firewall Daemon.';
                 }
            } else if (action === 'start' || action === 'restart') {
                 // Check if config exists
                 const configNode = getNode('/etc/firewall/rules.conf');
                 if (configNode && configNode.type === 'file') {
                     if (!VFS['/var/run/cycle258_solved']) {
                         VFS['/var/run/cycle258_solved'] = { type: 'file', content: 'TRUE' };
                         VFS['/var/run/firewall.pid'] = { type: 'file', content: '8888' };
                         // Ensure directory exists
                         const runDir = getNode('/var/run');
                         if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle258_solved')) {
                             runDir.children.push('cycle258_solved');
                         }
                         output = '[SUCCESS] firewall.service started.\nFLAG: GHOST_ROOT{SYST3MCTL_S3RV1C3_R3SCU3}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: FIREWALL ACTIVE.\x1b[0m';
                     } else {
                         VFS['/var/run/firewall.pid'] = { type: 'file', content: '8888' };
                         output = '[SUCCESS] firewall.service started.\nFLAG: GHOST_ROOT{SYST3MCTL_S3RV1C3_R3SCU3}';
                     }
                 } else {
                     output = 'Job for firewall.service failed because the control process exited with error code.\nSee "systemctl status firewall.service" and "journalctl -xe" for details.';
                 }
            } else if (action === 'stop') {
                delete VFS['/var/run/firewall.pid'];
                output = 'Stopped firewall.service.';
            } else {
                output = `Unknown operation '${action}'.`;
            }
        } else {
             output = `Failed to ${action} ${service}: Unit ${service} not found.`;
        }
        break;
    }

    case 'tune-receiver':
    case './tune-receiver':
    case '/usr/bin/tune-receiver': {
        const hasFreq = args.includes('--freq');
        const hasMode = args.includes('--mode');
        
        if (!hasFreq || !hasMode) {
            output = 'tune-receiver: missing required arguments.\nUsage: tune-receiver --freq <MHz> --mode <MODE>\nSee "man tune-receiver" for operating parameters.';
        } else {
            const freqIdx = args.indexOf('--freq');
            const modeIdx = args.indexOf('--mode');
            const freq = args[freqIdx + 1];
            const mode = args[modeIdx + 1];
            
            if ((freq === '404' || freq === '404.0') && mode === 'USB') {
                 if (!VFS['/var/run/cycle259_solved']) {
                     VFS['/var/run/cycle259_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle259_solved')) {
                         runDir.children.push('cycle259_solved');
                     }
                     output = `[SDR] Tuning to ${freq} MHz (USB)...\n[SIGNAL] LOCK ACQUIRED.\n[DECODING] ...\n[MSG] "Emergency Broadcast: System Compromised."\nFLAG: GHOST_ROOT{R4D10_S1L3NC3_BR0K3N}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SIGNAL INTERCEPTED.\x1b[0m`;
                 } else {
                     output = `[SDR] Tuning to ${freq} MHz (USB)...\n[SIGNAL] LOCK ACQUIRED.\nFLAG: GHOST_ROOT{R4D10_S1L3NC3_BR0K3N}`;
                 }
            } else if (freq === '404' || freq === '404.0') {
                 output = `[SDR] Tuning to ${freq} MHz (${mode})...\n[SIGNAL] Detected carrier wave, but audio is garbled.\n[HINT] Encrypted channels require Upper Side Band (USB).`;
            } else if (freq === '104.5') {
                 output = `[SDR] Tuning to 104.5 MHz (${mode})...\n[SIGNAL] Playing: "Lo-Fi Beats to Hack To" (Public Broadcast).`;
            } else {
                 output = `[SDR] Tuning to ${freq} MHz (${mode})...\n[SIGNAL] Static...`;
            }
        }
        break;
    }

    // Cycle 260: The Persistence Layer
    case 'crontab': {
        const action = args[0];
        const user = 'root'; 
        const cronPath = '/var/spool/cron/crontabs/root';

        if (action === '-l') {
            const node = getNode(cronPath);
            if (node) {
                output = (node as any).content;
            } else {
                output = `no crontab for ${user}`;
            }
        } else if (action === '-r') {
             if (VFS[cronPath]) {
                 delete VFS[cronPath];
                 // Remove from parent children list
                 const parent = getNode('/var/spool/cron/crontabs');
                 if (parent && parent.type === 'dir') {
                     parent.children = parent.children.filter(c => c !== 'root');
                 }

                 if (!VFS['/var/run/cycle260_solved']) {
                     VFS['/var/run/cycle260_solved'] = { type: 'file', content: 'TRUE' };
                     const runDir = getNode('/var/run');
                     if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle260_solved')) {
                         runDir.children.push('cycle260_solved');
                     }
                     output = '[CRON] Crontab removed.\n[SECURITY] Persistence mechanism neutralized.\nFLAG: GHOST_ROOT{CR0N_P3RS1ST3NC3_D3L3T3D}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: BACKDOOR REMOVED.\x1b[0m';
                 } else {
                     output = '[CRON] Crontab removed.\nFLAG: GHOST_ROOT{CR0N_P3RS1ST3NC3_D3L3T3D}';
                 }
             } else {
                 output = `no crontab for ${user}`;
             }
        } else if (action === '-e') {
            output = `no crontab for ${user} - using an empty one\ncrontab: no editor defined`;
        } else {
            output = 'usage: crontab [-u user] file\n       crontab [-u user] [-l | -r | -e]';
        }
        break;
    }

    // Cycle 255: The Process Trace
    case 'mystery_process':
    case './mystery_process':
    case '/usr/bin/mystery_process': {
        const secretNode = getNode('/tmp/secret_config.dat');
        if (secretNode && secretNode.type === 'file' && secretNode.content.includes('CONF_V1')) {
             if (!VFS['/var/run/cycle255_solved']) {
                 VFS['/var/run/cycle255_solved'] = { type: 'file', content: 'TRUE' };
                 // Ensure directory exists
                 const runDir = getNode('/var/run');
                 if (runDir && runDir.type === 'dir' && !runDir.children.includes('cycle255_solved')) {
                     runDir.children.push('cycle255_solved');
                 }
                 output = '[SUCCESS] Configuration Loaded.\n[SYSTEM] Payload Decrypted.\nFLAG: GHOST_ROOT{STR4C3_TR4C3_M4ST3R}\n\x1b[1;32m[MISSION UPDATE] Objective Complete: SYSTEM CALL TRACED.\x1b[0m';
             } else {
                 output = '[SUCCESS] Configuration Loaded.\nFLAG: GHOST_ROOT{STR4C3_TR4C3_M4ST3R}';
             }
        } else {
             output = ''; // Silent failure (Simulates ENOENT or Invalid Config)
        }
        break;
    }

    // Duplicate strace removed (Refined implementation at line ~18167 used instead)

    default:
      output = `bash: ${command}: command not found`;
  }

  return finalize(output, newCwd, action, data, newPrompt);
};


export const execute = processCommand;
// Verified Cycle 276 on 2026-02-19
// Verified Cycle 255 (Phase 11.5) on 2026-02-23
